[
  {
    "id": "gs_cantina_aragon_katana_001",
    "report_url": "https://cantina.xyz/portfolio/83c52210-6fff-4675-b8bf-a5e4d88d1fac",
    "project_name": "Aragon Katana",
    "github_url": "https://github.com/aragon/katana-governance",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-15",
    "vulnerability_type": "privilege_escalation",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Auto-Compound Strategy's Rewards Can Be Stolen via Swapper Privilege Escalation",
    "description": "The AragonMerklAutoCompoundStrategy sets the Swapper contract as an operator to allow claim execution. However, this grants the Swapper dangerous privileges: any user with a valid claim can call claimAndSwap with their claim and arbitrary actions, allowing them to execute delegatecalls that claim rewards on behalf of the auto-compounder and steal those rewards. The Swapper's arbitrary execution capability is exploitable through the auto-compounder's trust relationship.",
    "primary_file": {
      "name": "Swapper.sol",
      "path": "src/Swapper.sol",
      "lines": "60-90",
      "content": "function claimAndSwap(\n    Claim calldata _claim,\n    Action[] calldata _actions,\n    uint256 percentageToLock\n) external returns (uint256 tokenAmountGained, uint256 tokenId) {\n    // Step 1: Claim rewards from Merkl Distributor\n    // This succeeds if msg.sender has a valid claim\n    rewardDistributor.claim(\n        _claim.users,\n        _claim.tokens,\n        _claim.amounts,\n        _claim.proofs\n    );\n    \n    // BUG: After claiming, this function executes arbitrary actions\n    // via delegatecall to the Executor contract\n    // Any user with a valid claim can pass ANY _actions\n    \n    // Step 2: Execute arbitrary actions (via delegatecall)\n    for (uint256 i = 0; i < _actions.length; i++) {\n        Action memory action = _actions[i];\n        \n        // Executor.execute performs delegatecall with arbitrary data\n        executor.execute(\n            action.target,\n            action.value,\n            action.data  // BUG: Can contain any function calls\n        );\n    }\n    \n    // Step 3: Check final balance\n    uint256 finalBalance = escrowToken.balanceOf(address(this));\n    tokenAmountGained = finalBalance - initialBalance;\n    \n    // VULNERABILITY FLOW:\n    // 1. AragonMerklAutoCompoundStrategy sets Swapper as operator\n    //    via rewardDistributor.toggleOperator(swapper)\n    // 2. Alice has a valid claim on rewardDistributor\n    // 3. Alice calls claimAndSwap with:\n    //    - Her valid claim (passes validation)\n    //    - _actions containing: rewardDistributor.claim(autoCompounder, ...)\n    // 4. Swapper claims Alice's rewards (line above)\n    // 5. Swapper then executes _actions via delegatecall\n    // 6. _actions calls rewardDistributor.claim on behalf of autoCompounder\n    //    (This succeeds because Swapper is an operator)\n    // 7. Rewards sent to Swapper (if it's set as recipient)\n    // 8. Next action: send rewards from Swapper to Alice\n    // 9. Alice steals autoCompounder's rewards\n}\n\n// ATTACK CODE EXAMPLE:\n// Alice's _actions array contains:\n// Action 1: {\n//     target: rewardDistributor,\n//     data: rewardDistributor.claim.selector +\n//           encode([autoCompounder], [rewardToken], [amount], [merkleProof])\n// }\n// Action 2: {\n//     target: rewardToken,\n//     data: rewardToken.transfer.selector +\n//           encode(alice, swapperBalance)\n// }\n//\n// Execution:\n// 1. Swapper.claimAndSwap(aliceClaim, [action1, action2], 0)\n// 2. Step 1: Claim Alice's rewards\n// 3. Step 2: Execute actions via delegatecall\n//    - Action 1: Swapper calls rewardDistributor.claim for autoCompounder\n//      (Succeeds because msg.sender check sees Swapper is operator)\n//    - Rewards go to Swapper (or Alice if she set recipient)\n//    - Action 2: Transfer from Swapper to Alice\n// 4. Result: Alice has both her and autoCompounder's rewards"
    },
    "context_files": [
      {
        "name": "Merkl Distributor Operator Check",
        "path": "src/interfaces/IRewardsDistributor.sol",
        "relevance": "Shows how Merkl validates claim operations",
        "content": "// From Merkl Distributor:\nfunction claim(\n    address[] calldata users,\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    bytes32[][] calldata proofs\n) external {\n    // Merkl's validation:\n    for (uint256 i = 0; i < users.length; i++) {\n        address user = users[i];\n        \n        // VULNERABLE CHECK: Allows if msg.sender is an operator\n        if (\n            msg.sender != user &&\n            tx.origin != user &&\n            operators[user][msg.sender] == 0  // Swapper is trusted operator\n        ) {\n            revert NotWhitelisted();\n        }\n        \n        // If check passes, claim is processed for 'user'\n        // Tokens go to recipient (owner or configured recipient)\n    }\n}\n\n// AragonMerklAutoCompoundStrategy setup:\nfunction initialize(...) external {\n    // Sets Swapper as operator to allow claims\n    rewardDistributor.toggleOperator(swapper);\n    // Now: operators[autoCompounder][swapper] = 1\n}\n\n// Attack flow:\n// 1. Swapper is a trusted operator for autoCompounder\n// 2. Any caller with a valid claim can use Swapper\n// 3. Swapper can then claim on behalf of autoCompounder\n// 4. Because check sees: operators[autoCompounder][swapper] != 0"
      },
      {
        "name": "Delegatecall Execution Pattern",
        "path": "src/Executor.sol",
        "relevance": "Shows how Executor enables arbitrary calls",
        "content": "// Executor contract (from osx-commons):\ncontract Executor {\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) external {\n        // Simple delegatecall wrapper\n        // All calls execute in Swapper's context\n        (bool success, ) = target.delegatecall(\n            data  // BUG: No validation of what's being called\n        );\n        require(success, \"Execute failed\");\n    }\n}\n\n// When Swapper calls executor.execute:\n// - msg.sender in the called contract is Swapper\n// - This is sufficient for Merkl's operators check\n// - Swapper can claim on behalf of any account it's an operator for\n\n// Example malicious data:\n// rewardDistributor.claim(\n//     [autoCompounder],\n//     [rewardToken],\n//     [amount],\n//     [merkleProof]\n// )\n// When executed via delegatecall in Swapper's context:\n// - msg.sender = Swapper\n// - operators[autoCompounder][Swapper] = 1 (already set)\n// - Claim succeeds\n// - Tokens go to recipient (Swapper or configured address)"
      },
      {
        "name": "Reward Theft Scenario",
        "path": "reference/aragon_reward_theft.md",
        "relevance": "Documents the full attack scenario",
        "content": "SCENARIO: Attacker Steals Auto-Compounder Rewards\n\nSetup:\n- AragonMerklAutoCompoundStrategy deployed\n- Connected to Merkl Distributor\n- Has USDC, DAI, and USDE as reward tokens\n- Swapper set as operator: rewardDistributor.toggleOperator(swapper)\n- autoCompounder has earned 1000 USDC + 2000 DAI in rewards\n- Alice has earned 100 USDC in rewards (separate claim)\n\nAttack Steps:\n\n1. Alice constructs malicious _actions array:\n\n   Action 1: {\n       target: rewardDistributor,\n       data: abi.encodeWithSelector(\n           rewardDistributor.claim.selector,\n           [autoCompounder, autoCompounder],\n           [USDC, DAI],\n           [1000e18, 2000e18],\n           [merkleProofUSDC, merkleProofDAI]\n       )\n   }\n   \n   Action 2: {\n       target: USDC,\n       data: abi.encodeWithSelector(\n           USDC.transfer.selector,\n           alice,\n           swapper.balance(USDC)  // Steal all USDC from Swapper\n       )\n   }\n   \n   Action 3: {\n       target: DAI,\n       data: abi.encodeWithSelector(\n           DAI.transfer.selector,\n           alice,\n           swapper.balance(DAI)  // Steal all DAI from Swapper\n       )\n   }\n\n2. Alice calls:\n   swapper.claimAndSwap(\n       Claim({\n           users: [alice],\n           tokens: [USDC],\n           amounts: [100e18],\n           proofs: [merkleProofAlice]\n       }),\n       _actions,  // Malicious actions\n       0\n   )\n\n3. Execution Flow:\n\n   Step 1: rewardDistributor.claim(alice, USDC, 100e18, ...)\n   - Alice's 100 USDC claimed\n   - Sent to Swapper (or Alice if she set recipient)\n   \n   Step 2: Execute Action 1 via delegatecall\n   - Calls rewardDistributor.claim(autoCompounder, [USDC, DAI], ...)\n   - msg.sender = Swapper\n   - operators[autoCompounder][Swapper] = 1 ✓ Check passes\n   - autoCompounder's 1000 USDC + 2000 DAI claimed\n   - Sent to Swapper (default recipient)\n   \n   Step 3: Execute Action 2 via delegatecall\n   - Calls USDC.transfer(alice, swapperBalance)\n   - Swapper transfers 1000 + 100 = 1100 USDC to Alice\n   \n   Step 4: Execute Action 3 via delegatecall\n   - Calls DAI.transfer(alice, swapperBalance)\n   - Swapper transfers 2000 DAI to Alice\n\n4. Result:\n   - Alice receives: 100 (her own) + 1000 + 2000 = 3100 tokens\n   - autoCompounder receives: 0 (all stolen)\n   - autoCompounder's balance: 0 USDC, 0 DAI\n   - No deposits made to escrow\n\nImpact:\n- autoCompounder's rewards completely drained\n- No escrow deposits = no voting power gains\n- Protocol functionality broken\n- Any user with a valid claim can perform this attack\n\nRoot Cause:\n- Swapper should not be a persistent operator\n- Swapper should not execute arbitrary delegatecalls\n- No access control on _actions in claimAndSwap"
      }
    ],
    "call_flow": [
      "1. AragonMerklAutoCompoundStrategy initializes",
      "2. Sets Swapper as operator: rewardDistributor.toggleOperator(swapper)",
      "3. autoCompounder earns rewards from Merkl Distributor",
      "4. Attacker Alice constructs claim + malicious _actions",
      "5. Alice calls swapper.claimAndSwap(aliceClaim, _actions, ...)",
      "6. Swapper executes: rewardDistributor.claim(alice, ...)",
      "7. Alice's claim passes Merkl validation",
      "8. Alice's rewards transferred to Swapper",
      "9. Swapper executes _actions[0] via delegatecall",
      "10. _actions[0] calls: rewardDistributor.claim(autoCompounder, ...)",
      "11. Merkl checks: operators[autoCompounder][swapper] = 1 ✓",
      "12. autoCompounder's rewards claimed, sent to Swapper",
      "13. Swapper executes _actions[1] via delegatecall",
      "14. _actions[1] transfers all tokens from Swapper to Alice",
      "15. Alice now owns both her and autoCompounder's rewards",
      "16. autoCompounder receives nothing"
    ],
    "context_hint": "The core issue is granting Swapper permanent operator status. The auto-compounder trusts Swapper for legitimate claim execution, but that trust is exploited via arbitrary delegatecall capabilities. Any user with a valid Merkl claim can abuse the operator status to claim on behalf of others. The vulnerability combines two separate trust failures: (1) persistent operator grant, and (2) arbitrary delegatecall execution.",
    "expert_notes": "This is a sophisticated privilege escalation attack that exploits the boundary between two trusted components (Merkl Distributor and Swapper). The Merkl protocol correctly trusts operator status, but Aragon's use of that operator status through an uncontrolled Swapper is unsafe. Cantina recommended either: (1) toggling operator on/off per transaction, (2) not using Swapper as operator, or (3) checking that _actions never call the Distributor. Aragon implemented solution (1) in PR #21.",
    "fix_description": "Toggle the Swapper's operator status only during the claim operation, revoking it before and after to prevent abuse. Additionally, never set Swapper as a persistent operator.",
    "fix_code": "function claimAndCompound(\n    address[] calldata _tokens,\n    uint256[] calldata _amounts,\n    bytes32[][] calldata _proofs,\n    Action[] calldata _actions\n) public virtual auth(AUTOCOMPOUND_STRATEGY_CLAIM_COMPOUND_ROLE) returns (uint256) {\n    // FIXED: Grant operator status only for this transaction\n    _toggleSwapperOperator();  // Toggle ON\n    \n    try {\n        // Set swapper as recipient to ensure tokens go to swapper\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IRewardsDistributor(rewardsDistributor).setClaimRecipient(\n                swapper,\n                _tokens[i]\n            );\n        }\n        \n        ISwapper.Claim memory claimTokens = ISwapper.Claim(\n            _tokens,\n            _amounts,\n            _proofs\n        );\n        \n        (uint256 claimedAmount, ) = ISwapper(swapper).claimAndSwap(\n            claimTokens,\n            _actions,\n            0\n        );\n        \n        // Clear recipient\n        for (uint256 i = 0; i < _tokens.length; ++i) {\n            IRewardsDistributor(rewardsDistributor).setClaimRecipient(\n                address(0),\n                _tokens[i]\n            );\n        }\n        \n        if (claimedAmount > 0) {\n            _deposit(claimedAmount);\n        }\n        \n        return claimedAmount;\n    } finally {\n        // FIXED: Revoke operator status immediately\n        _toggleSwapperOperator();  // Toggle OFF\n    }\n}\n\n// This ensures:\n// 1. Swapper only has operator status during claimAndSwap call\n// 2. No other user can exploit it in parallel transactions\n// 3. If claimAndSwap is reentered or exploited, operator is revoked\n// 4. Claim recipient is set explicitly, preventing fund rerouting"
  },
  {
    "id": "gs_cantina_aragon_katana_002",
    "report_url": "https://cantina.xyz/portfolio/83c52210-6fff-4675-b8bf-a5e4d88d1fac",
    "project_name": "Aragon Katana",
    "github_url": "https://github.com/aragon/katana-governance",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-15",
    "vulnerability_type": "fund_loss",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "integration",
    "is_vulnerable": true,
    "title": "AragonMerklAutoCompoundStrategy Does Not Set Swapper as Claim Recipient, Causing Fund Loss",
    "description": "The auto-compounder calls Swapper to claim and swap rewards, but does not set Swapper as the claim recipient in the Merkl Distributor. The Merkl protocol redirects claims to the contract owner if no recipient is configured. This causes claimed tokens to be sent to the auto-compounder instead of the Swapper, preventing swaps and deposits. Tokens remain stuck in the auto-compounder without being compounded.",
    "primary_file": {
      "name": "AragonMerklAutoCompoundStrategy.sol",
      "path": "src/AragonMerklAutoCompoundStrategy.sol",
      "lines": "130-160",
      "content": "function claimAndCompound(\n    address[] calldata _tokens,\n    uint256[] calldata _amounts,\n    bytes32[][] calldata _proofs,\n    Action[] calldata _actions\n) public virtual auth(AUTOCOMPOUND_STRATEGY_CLAIM_COMPOUND_ROLE) returns (uint256) {\n    // Step 1: Call Swapper to claim and swap\n    ISwapper.Claim memory claimTokens = ISwapper.Claim(\n        _tokens,\n        _amounts,\n        _proofs\n    );\n    \n    (uint256 claimedAmount, ) = ISwapper(swapper).claimAndSwap(\n        claimTokens,\n        _actions,\n        0\n    );\n    \n    // BUG: Merkl Distributor.claim behavior:\n    // When msg.sender != user and no recipient is set:\n    // recipient = user (not the operator/msg.sender)\n    // \n    // Flow:\n    // 1. Swapper calls rewardDistributor.claim(autoCompounder, ...)\n    // 2. Merkl checks claimRecipient[autoCompounder][token]\n    // 3. If not set, defaults to autoCompounder (the user)\n    // 4. Tokens sent to autoCompounder, NOT Swapper\n    // 5. Swapper balance remains 0\n    // 6. claimedAmount = 0 (no tokens received)\n    // 7. _deposit(0) does nothing\n    // 8. Tokens stuck in autoCompounder\n    \n    if (claimedAmount > 0) {\n        _deposit(claimedAmount);\n    }\n    \n    return claimedAmount;\n    // Returns 0 because Swapper received 0 tokens\n}\n\n// MERKL DISTRIBUTOR LOGIC (relevant excerpt):\n// function claim(\n//     address[] users,\n//     address[] tokens,\n//     uint256[] amounts,\n//     bytes32[][] proofs\n// ) external {\n//     for (uint i = 0; i < users.length; i++) {\n//         // msg.sender = Swapper\n//         // user = autoCompounder\n//         \n//         if (msg.sender != user && tx.origin != user) {\n//             require(operators[user][msg.sender] != 0);\n//             // operators[autoCompounder][Swapper] = 1 ✓\n//         }\n//         \n//         address recipient = recipients[user][token];\n//         if (msg.sender != user || recipient == address(0)) {\n//             // BUG: This condition is ALWAYS true\n//             // msg.sender (Swapper) != user (autoCompounder)\n//             recipient = recipients[user][token];  // Still address(0)\n//             if (recipient == address(0)) {\n//                 recipient = user;  // Default to autoCompounder\n//             }\n//         }\n//         \n//         // Transfer to recipient (autoCompounder, not Swapper)\n//         token.transfer(recipient, amount);\n//     }\n// }\n\n// SYMPTOM:\n// claimAndSwap returns (0, tokenId)\n// No tokens received in Swapper\n// No swaps executed (no input)\n// No deposit made\n// claimAndCompound returns 0\n// Tokens accumulate in autoCompounder"
    },
    "context_files": [
      {
        "name": "Merkl Recipient Logic",
        "path": "src/interfaces/IRewardsDistributor.sol",
        "relevance": "Shows how Merkl determines claim recipient",
        "content": "// Merkl Distributor recipient logic:\n\n// Storage:\nmapping(address user => mapping(address token => address recipient)) \n    public claimRecipient;\n\n// Claim execution:\nfunction claim(\n    address[] calldata users,\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    bytes32[][] calldata proofs\n) external {\n    for (uint256 i = 0; i < users.length; i++) {\n        address user = users[i];\n        address token = tokens[i];\n        uint256 amount = amounts[i];\n        \n        // Determine recipient\n        address recipient = claimRecipient[user][token];\n        \n        // If caller is not user or no custom recipient set:\n        if (msg.sender != user || recipient == address(0)) {\n            // Option 1: Use configured recipient\n            address userSetRecipient = claimRecipient[user][token];\n            if (userSetRecipient != address(0)) {\n                recipient = userSetRecipient;\n            } else {\n                // Option 2: Default to user\n                recipient = user;\n            }\n        }\n        \n        // Transfer to recipient\n        token.transfer(recipient, amount);\n    }\n}\n\n// Setting recipient:\nfunction setClaimRecipient(\n    address recipient,\n    address token\n) external {\n    claimRecipient[msg.sender][token] = recipient;\n}\n\n// Current behavior:\n// Swapper.claimAndSwap(autoCompounder, [token], ...)\n// ↓\n// rewardDistributor.claim(\n//     [autoCompounder],\n//     [token],\n//     [amount],\n//     [proof]\n// )\n// ↓\n// msg.sender = Swapper\n// user = autoCompounder\n// msg.sender != user → TRUE\n// claimRecipient[autoCompounder][token] = address(0) (never set)\n// → recipient = autoCompounder\n// ↓\n// token.transfer(autoCompounder, amount)  ← Wrong recipient!\n// Swapper receives: 0\n// autoCompounder receives: amount"
      },
      {
        "name": "Stuck Funds Scenario",
        "path": "reference/aragon_stuck_funds.md",
        "relevance": "Documents the fund loss scenario",
        "content": "SCENARIO: Tokens Stuck in Auto-Compounder, No Compounding\n\nSetup:\n- AragonMerklAutoCompoundStrategy deployed\n- Merkl Distributor configured for USDC rewards\n- autoCompounder has earned 1000 USDC in rewards\n- Swapper address: 0xSwapper...\n- Auto-Compounder address: 0xAutoComp...\n\nExpected Flow (Intended):\n1. claimAndCompound([USDC], [1000e18], [proof], [swapActions])\n2. Swapper claims 1000 USDC from Merkl\n3. Swapper receives 1000 USDC\n4. Swapper executes swap actions (DAI → KAT, etc.)\n5. Swapper returns KAT to auto-compounder\n6. auto-compounder deposits KAT to escrow\n7. Result: 1000 USDC compounded into KAT voting power\n\nActual Flow (With Bug):\n1. claimAndCompound([USDC], [1000e18], [proof], [swapActions])\n2. Swapper calls: rewardDistributor.claim(\n       [autoCompounder],\n       [USDC],\n       [1000e18],\n       [proof]\n   )\n3. Merkl checks:\n   - msg.sender (Swapper) != user (autoCompounder)? YES\n   - claimRecipient[autoCompounder][USDC] set? NO (address(0))\n   - → Default recipient = autoCompounder\n4. USDC transferred to autoCompounder (NOT Swapper)\n5. Swapper balance = 0\n6. Swapper cannot execute swaps (no input tokens)\n7. claimedAmount = 0\n8. auto-compounder does not deposit (claimedAmount == 0)\n9. 1000 USDC sits in autoCompounder, never compounded\n\nImpact:\n- Tokens permanently stuck\n- No escrow deposits = no voting power gains\n- Gauge incentives not earned\n- Strategy broken\n- Rewards lost (unless manually recovered)\n\nRecovery:\n- Manual intervention required\n- Contract upgrade needed\n- Or tokens must be swept by admin\n\nOccurrence Frequency:\n- Every single call to claimAndCompound\n- 100% failure rate\n- All rewards inaccessible"
      }
    ],
    "call_flow": [
      "1. claimAndCompound called with token list and proofs",
      "2. Creates claim: Claim([USDC], [1000e18], [proof])",
      "3. Calls: ISwapper(swapper).claimAndSwap(claim, actions, 0)",
      "4. Swapper executes: rewardDistributor.claim([autoCompounder], ...)",
      "5. Merkl validates claim (passes)",
      "6. Merkl determines recipient:",
      "7.   - msg.sender (Swapper) != user (autoCompounder)? YES",
      "8.   - claimRecipient[autoCompounder][USDC] == address(0)? YES",
      "9.   - → Default to user: autoCompounder",
      "10. USDC transferred to autoCompounder, not Swapper",
      "11. Swapper checks balance: 0 USDC",
      "12. claimedAmount = 0",
      "13. Return (0, tokenId)",
      "14. Back in claimAndCompound: if (0 > 0) → skip deposit",
      "15. Return 0",
      "16. No deposit made",
      "17. Tokens stuck in autoCompounder"
    ],
    "context_hint": "This is an integration bug where the auto-compounder fails to configure Merkl correctly for its Swapper flow. The Merkl protocol works as designed (defaulting to the owner), but the auto-compounder's assumption that tokens go to Swapper is violated. The fix requires explicitly setting Swapper as the claim recipient before calling it.",
    "expert_notes": "This is a common pattern in multi-contract integrations: when contract A delegates to contract B, intermediate contracts must be explicitly configured to route assets correctly. The auto-compounder assumed Merkl would send tokens to the caller (Swapper), but Merkl's default behavior sends them to the original user. Cantina recommended calling setClaimRecipient before claimAndSwap to ensure correct token routing.",
    "fix_description": "Call setClaimRecipient on the Merkl Distributor to explicitly set Swapper as the recipient before calling claimAndSwap, then clear the recipient afterward.",
    "fix_code": "function claimAndCompound(\n    address[] calldata _tokens,\n    uint256[] calldata _amounts,\n    bytes32[][] calldata _proofs,\n    Action[] calldata _actions\n) public virtual auth(AUTOCOMPOUND_STRATEGY_CLAIM_COMPOUND_ROLE) returns (uint256) {\n    // FIXED: Set swapper as claim recipient before calling it\n    for (uint256 i = 0; i < _tokens.length; ++i) {\n        IRewardsDistributor(rewardsDistributor).setClaimRecipient(\n            swapper,\n            _tokens[i]\n        );\n    }\n    \n    // Now when Swapper calls claim, tokens will go to Swapper\n    ISwapper.Claim memory claimTokens = ISwapper.Claim(\n        _tokens,\n        _amounts,\n        _proofs\n    );\n    \n    (uint256 claimedAmount, ) = ISwapper(swapper).claimAndSwap(\n        claimTokens,\n        _actions,\n        0\n    );\n    \n    // FIXED: Clear recipient after claiming\n    for (uint256 i = 0; i < _tokens.length; ++i) {\n        IRewardsDistributor(rewardsDistributor).setClaimRecipient(\n            address(0),\n            _tokens[i]\n        );\n    }\n    \n    // Now claimedAmount > 0 and deposit proceeds\n    if (claimedAmount > 0) {\n        _deposit(claimedAmount);\n    }\n    \n    return claimedAmount;\n}\n\n// With fix:\n// 1. setClaimRecipient(swapper, USDC) called\n// 2. claimRecipient[autoCompounder][USDC] = swapper\n// 3. Swapper claims on behalf of autoCompounder\n// 4. Merkl finds: claimRecipient[autoCompounder][USDC] = swapper\n// 5. Tokens transferred to swapper\n// 6. Swapper receives tokens, executes swaps\n// 7. claimedAmount > 0\n// 8. Deposit executes, escrow receives tokens\n// 9. setClaimRecipient(address(0), USDC) clears recipient"
  }
]