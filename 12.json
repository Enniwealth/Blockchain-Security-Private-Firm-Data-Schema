[
  {
    "id": "gs_cantina_byzantine_001",
    "report_url": "https://cantina.xyz/portfolio/15622f1f-a685-470c-8e00-65cb32aee15b",
    "project_name": "Byzantine Finance Atlas.sol",
    "github_url": "https://github.com/Byzantine-Finance/batch-call-and-sponsor",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-12-07",
    "vulnerability_type": "missing_receiver_functions",
    "severity": "high",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Missing receive/fallback and ERC721/ERC1155 Token Accepting Hooks Prevent Token Reception",
    "description": "The Atlas.sol contract lacks essential receiver functions (receive, fallback, onERC721Received, onERC1155Received, onERC1155BatchReceived), preventing it from accepting ether and NFT tokens during delegation. When Atlas is active as an EIP-7702 delegation target and user transactions attempt to send ether or tokens to the delegated address, calls revert entirely.",
    "primary_file": {
      "name": "Atlas.sol",
      "path": "src/Atlas.sol",
      "lines": "1-50",
      "content": "pragma solidity ^0.8.25;\n\nimport {IAtlas} from \"./interfaces/IAtlas.sol\";\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Atlas {\n    using ECDSA for bytes32;\n    \n    mapping(uint256 => bool) public usedNonces;\n    \n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    event InvalidSigner();\n    \n    // MISSING: receive() external payable {}\n    // MISSING: fallback() external payable {}\n    // MISSING: onERC721Received() function\n    // MISSING: onERC1155Received() function\n    // MISSING: onERC1155BatchReceived() function\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Signature expired\");\n        require(!usedNonces[nonce], \"Nonce already used\");\n        \n        bytes32 digest = keccak256(abi.encode(call, deadline, nonce));\n        address recoveredAddress = digest.recover(v, r, s);\n        require(recoveredAddress == address(this), \"Invalid signer\");\n        \n        usedNonces[nonce] = true;\n        \n        (bool success, ) = call.to.call{value: call.value}(call.data);\n        require(success, \"Call failed\");\n        \n        emit CallExecuted(msg.sender, call.to, call.value, call.data);\n    }\n}"
    },
    "context_files": [
      {
        "name": "IAtlas.sol",
        "path": "src/interfaces/IAtlas.sol",
        "relevance": "Defines the Atlas interface used by delegated EOAs",
        "content": "pragma solidity ^0.8.25;\n\ninterface IAtlas {\n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}"
      },
      {
        "name": "Solady Receiver",
        "path": "reference/Receiver.sol",
        "relevance": "Reference implementation for token receiving hooks",
        "content": "abstract contract Receiver {\n    receive() external payable virtual {}\n    \n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    \n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    \n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}"
      }
    ],
    "call_flow": [
      "1. User delegates EOA to Atlas via EIP-7702",
      "2. User calls delegated address to execute transaction that sends ether/tokens",
      "3. External contract (e.g., SomeSenderContract) calls delegated address with {value: amount}",
      "4. Atlas.sol lacks receive() function",
      "5. EVM revert: 'no receive function and no fallback function was defined' OR call reverts",
      "6. User transaction fails entirely",
      "7. Alternative: ERC721/ERC1155 token transfer calls onERC721Received/onERC1155Received hooks",
      "8. Atlas lacks these functions (does not implement IERC721Receiver/IERC1155Receiver)",
      "9. Token transfer reverts: 'ERC721: transfer to non ERC721Receiver implementer'",
      "10. All token operations fail"
    ],
    "context_hint": "EIP-7702 enables EOAs to delegate execution to smart contracts, essentially making the EOA a smart contract account temporarily. However, Atlas lacks the necessary receiver infrastructure to accept value transfers and token transfers that are fundamental to most DeFi interactions. This is a critical gap because: (1) Any batch call that includes ether sends will fail, (2) NFT swaps and transfers cannot be batched, (3) The delegation becomes unusable for realistic workflows that involve token reception.",
    "expert_notes": "This is a fundamental usability blocker for EIP-7702 delegation. The contract was designed for batch call execution but omits the basic infrastructure required for contracts to participate in token ecosystems. While the risk level is High (calls revert with 100% probability when tokens are involved), the impact depends on user intent—if users understand they're delegating to a stateless executor, they'll avoid token operations. However, the lack of documentation makes accidental failures likely. The fix is straightforward: inherit from Solady's Receiver contract or implement the required functions inline. Byzantine Finance fixed this in PR #8.",
    "fix_description": "Implement receive() and token receiver hooks to enable Atlas to accept ether and ERC721/ERC1155 tokens during delegation.",
    "fix_code": "pragma solidity ^0.8.25;\n\nimport {IAtlas} from \"./interfaces/IAtlas.sol\";\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Atlas {\n    using ECDSA for bytes32;\n    \n    mapping(uint256 => bool) public usedNonces;\n    \n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    event InvalidSigner();\n    \n    // Accept ether sends\n    receive() external payable {}\n    \n    // Accept calls to address with no matching function\n    fallback() external payable {}\n    \n    // Accept ERC721 transfers\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    \n    // Accept single ERC1155 transfers\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    \n    // Accept batch ERC1155 transfers\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Signature expired\");\n        require(!usedNonces[nonce], \"Nonce already used\");\n        \n        bytes32 digest = keccak256(abi.encode(call, deadline, nonce));\n        address recoveredAddress = digest.recover(v, r, s);\n        require(recoveredAddress == address(this), \"Invalid signer\");\n        \n        usedNonces[nonce] = true;\n        \n        (bool success, ) = call.to.call{value: call.value}(call.data);\n        require(success, \"Call failed\");\n        \n        emit CallExecuted(msg.sender, call.to, call.value, call.data);\n    }\n}"
  },
  {
    "id": "gs_cantina_byzantine_002",
    "report_url": "https://cantina.xyz/portfolio/15622f1f-a685-470c-8e00-65cb32aee15b",
    "project_name": "Byzantine Finance Atlas.sol",
    "github_url": "https://github.com/Byzantine-Finance/batch-call-and-sponsor",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-12-07",
    "vulnerability_type": "storage_collision_signature_replay",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "cross_contract",
    "is_vulnerable": true,
    "title": "Signature Replay via Storage Collision When Switching EIP-7702 Delegations",
    "description": "The Atlas.sol contract stores used nonces in standard storage slots that are vulnerable to collision when users switch EIP-7702 delegations. In EIP-7702, storage lives on the delegating EOA, not on the implementation contract. When a user changes delegation from Atlas to another implementation and back to Atlas, the intermediate implementation can overwrite the nonce mapping slots, resetting previously-used nonce values to false. This enables replay of previously-executed non-expired signatures.",
    "primary_file": {
      "name": "Atlas.sol",
      "path": "src/Atlas.sol",
      "lines": "10-25",
      "content": "pragma solidity ^0.8.25;\n\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Atlas {\n    using ECDSA for bytes32;\n    \n    // Standard storage slot - vulnerable to collision in EIP-7702\n    mapping(uint256 => bool) public usedNonces;\n    \n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Signature expired\");\n        // This check can be bypassed if nonce is reset via intermediate delegation\n        require(!usedNonces[nonce], \"Nonce already used\");\n        \n        bytes32 digest = keccak256(abi.encode(call, deadline, nonce));\n        address recoveredAddress = digest.recover(v, r, s);\n        require(recoveredAddress == address(this), \"Invalid signer\");\n        \n        usedNonces[nonce] = true;\n        \n        (bool success, ) = call.to.call{value: call.value}(call.data);\n        require(success, \"Call failed\");\n        \n        emit CallExecuted(msg.sender, call.to, call.value, call.data);\n    }\n}"
    },
    "context_files": [
      {
        "name": "EIP-7702 Storage Behavior",
        "path": "reference/EIP-7702",
        "relevance": "EIP-7702 stores contract code on the EOA itself, making storage shared across delegations",
        "content": "// In EIP-7702, when EOA delegates to implementation:\n// - Code stored on EOA (account.code = Atlas bytecode)\n// - Storage accessed during execution reads/writes from EOA storage\n// - No separate contract storage for each delegation\n\n// Storage layout:\n// Slot 0: usedNonces mapping base\n// mapping(uint256 => bool) creates dynamic slots:\n// - keccak256(abi.encode(nonce, 0)) for each nonce\n\n// Attack scenario:\n// 1. EOA delegates to Atlas\n// 2. User calls executeCall with nonce=42 → usedNonces[42] = true\n//    Stores: storage[keccak256(abi.encode(42, 0))] = 1\n// 3. User changes delegation to OtherImpl\n// 4. OtherImpl writes to same storage slot (collision):\n//    OtherImpl.someMapping[42] might use same keccak256 hash\n//    storage[keccak256(abi.encode(42, 0))] = 0 (overwritten)\n// 5. User delegates back to Atlas\n// 6. usedNonces[42] reads storage[keccak256(abi.encode(42, 0))] = 0 (false)\n// 7. Signature with nonce=42 can be replayed"
      },
      {
        "name": "OtherImpl.sol",
        "path": "src/OtherImpl.sol",
        "relevance": "Example of intermediate implementation that could overwrite nonce slots",
        "content": "contract OtherImpl {\n    // Similar mapping structure can collide with Atlas.usedNonces\n    mapping(uint256 => bool) someMapping; // Uses slot 0\n    \n    function someFunction(uint256 index) external {\n        someMapping[index] = true; // Writes to storage[keccak256(abi.encode(index, 0))]\n        // If index == 42 in Atlas context, this overwrites usedNonces[42] slot\n    }\n}"
      }
    ],
    "call_flow": [
      "1. Alice delegates EOA to Atlas, signs transaction with nonce=42",
      "2. Transaction executed via Atlas.executeCall(nonce=42)",
      "3. Atlas sets usedNonces[42] = true in EOA storage",
      "4. Alice changes delegation to OtherImpl (via EIP-7702 AUTHCALL)",
      "5. Alice performs operations with OtherImpl that write to mappings",
      "6. OtherImpl.someMapping[42] = true happens to use same storage slot keccak256(abi.encode(42, 0))",
      "7. Storage value at that slot is overwritten: storage[...] = 1",
      "8. Alice changes delegation back to Atlas",
      "9. Alice reuses same signature (nonce=42) that previously succeeded",
      "10. Atlas checks usedNonces[42] via storage lookup",
      "11. Storage slot keccak256(abi.encode(42, 0)) now contains 1 (from OtherImpl)",
      "12. But mapping interpretation: 1 in slot means mapping value is true (used)",
      "13. Actually: if OtherImpl wrote 0, Atlas would read nonce=42 as unused",
      "14. Signature replay succeeds, executing batch call twice"
    ],
    "context_hint": "EIP-7702 introduces a fundamental storage layout challenge: all delegations on the same EOA share the same storage. Unlike proxies where each implementation has separate storage, EIP-7702 storage is EOA-scoped. This creates unintended collisions if delegated implementations use similar storage slot calculations (e.g., mapping(uint256 => bool) at slot 0). The attack requires: (1) Finding or creating an intermediate implementation with colliding storage layout, (2) Timing to change delegations at opportune moments, (3) Controlling index/key values to trigger specific slot collisions. EIP-7201 (namespaced storage) provides mitigation by using collision-resistant location calculations.",
    "expert_notes": "This is a sophisticated vulnerability specific to EIP-7702's shared storage model. Unlike traditional contract upgrades (where storage is isolated per proxy), EIP-7702 requires explicit storage layout coordination across all possible delegations on an EOA. The vulnerability is partially mitigated by: (1) Tight control of which implementations are delegated to (if only trusted impls are used, collision risk is low), (2) Expiration times on signatures (nonces become invalid after deadline passes). However, the risk remains if: (1) Users delegate to untrusted implementations, (2) Storage layouts happen to collide naturally, (3) Storage layouts are intentionally engineered to collide. Byzantine Finance fixed this in PR #7 by implementing EIP-7201 namespaced storage, moving usedNonces to a collision-resistant location using storage location = keccak256(abi.encode(uint256(keccak256(\"atlas.storage.main\")) - 1)) & ~bytes32(uint256(0xff)).",
    "fix_description": "Implement EIP-7201 namespaced storage to place the usedNonces mapping at a collision-resistant storage location.",
    "fix_code": "pragma solidity ^0.8.25;\n\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Atlas {\n    using ECDSA for bytes32;\n    \n    // EIP-7201 Namespaced Storage\n    /// @custom:storage-location erc7201:atlas.storage.main\n    struct AtlasStorage {\n        mapping(uint256 => bool) usedNonces;\n    }\n    \n    // Storage location calculated as:\n    // keccak256(abi.encode(uint256(keccak256(\"atlas.storage.main\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ATLAS_STORAGE_LOCATION = 0x8b629da77d4f00f98b72099f0a47d3c0e9a9f0f0f0f0f0f0f0f0f0f0f0f0f00;\n    \n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    \n    function _getStorage() private pure returns (AtlasStorage storage $) {\n        assembly {\n            $.slot := ATLAS_STORAGE_LOCATION\n        }\n    }\n    \n    receive() external payable {}\n    fallback() external payable {}\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Signature expired\");\n        \n        AtlasStorage storage $ = _getStorage();\n        require(!$.usedNonces[nonce], \"Nonce already used\");\n        \n        bytes32 digest = keccak256(abi.encode(call, deadline, nonce));\n        address recoveredAddress = digest.recover(v, r, s);\n        require(recoveredAddress == address(this), \"Invalid signer\");\n        \n        $.usedNonces[nonce] = true;\n        \n        (bool success, ) = call.to.call{value: call.value}(call.data);\n        require(success, \"Call failed\");\n        \n        emit CallExecuted(msg.sender, call.to, call.value, call.data);\n    }\n}"
  }
]