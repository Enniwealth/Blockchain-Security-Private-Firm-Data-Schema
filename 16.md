[
  {
    "id": "gs_cantina_abraxas_001",
    "report_url": "https://cantina.xyz/portfolio/be15a789-e084-4bd9-873a-01c2d824bbe1",
    "project_name": "Abraxas MintHub",
    "github_url": "https://github.com/abraxaslabs-io/minthub-contracts",
    "language": "solidity",
    "chain": "monad",
    "contest_date": "2025-10-30",
    "vulnerability_type": "dos_grief",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Griefing: Users Can Cause DoS by Reverting Native Token Transfers in returnDeposits",
    "description": "The returnDeposits function uses _performTransfer to send user balances back, but a malicious user can revert the native token transfer by implementing a receive function that fails. This prevents the admin from forcefully removing the user from the platform, allowing griefing users to squat in the limited MAX_PLATFORM_USERS slots (10M cap) without actually participating in raffles, blocking legitimate users from accessing the platform.",
    "primary_file": {
      "name": "MintHub.sol",
      "path": "src/MintHub.sol",
      "lines": "320-350",
      "content": "function returnDeposits(\n    uint32[] calldata raffleIds_,\n    address[] calldata users_\n) external onlyRole(PLATFORM_ADMIN_ROLE) {\n    require(raffleIds_.length == users_.length, \"ArrayLengthMismatch\");\n    \n    for (uint256 i = 0; i < raffleIds_.length; i++) {\n        uint32 raffleId = raffleIds_[i];\n        address user = users_[i];\n        \n        Raffle storage raffle = raffles[raffleId];\n        uint256 userBalance = userBalances[user];\n        \n        // BUG: If user has a malicious receive function, this reverts\n        // And the user cannot be removed from the platform\n        _performTransfer(user, userBalance);\n        \n        // If _performTransfer fails, this line is never reached\n        userBalances[user] = 0;\n    }\n}\n\nfunction _performTransfer(\n    address recipient_,\n    uint256 value_\n) internal {\n    // BUG: No gas limit, no fallback mechanism\n    // If recipient has receive() { revert(); }, this fails\n    (bool succeeded, ) = recipient_.call{value: value_}(\"\");\n    if (!succeeded) {\n        revert(\"Transfer failed\");\n    }\n}\n\n// ATTACK SCENARIO:\n// contract MaliciousUser {\n//     receive() external payable {\n//         revert(\"No transfers!\");\n//     }\n// }\n//\n// 1. Malicious user deposits MON (their address is a contract)\n// 2. Admin tries returnDeposits([raffleId], [maliciousUser])\n// 3. _performTransfer calls maliciousUser.call{value: balance}(\"\")\n// 4. Malicious receive() reverts\n// 5. returnDeposits transaction reverts\n// 6. userBalances[maliciousUser] is never set to 0\n// 7. User remains in platform, occupying MAX_PLATFORM_USERS slot\n// 8. User can continue to squat without participating in raffles\n// 9. Legitimate users cannot join because platform is at MAX_PLATFORM_USERS"
    },
    "context_files": [
      {
        "name": "Platform User Limit Logic",
        "path": "src/MintHub.sol",
        "relevance": "Shows how MAX_PLATFORM_USERS constraint is checked and enforced",
        "content": "// Maximum simultaneous users on platform\nconstant MAX_PLATFORM_USERS = 10_000_000;\n\nfunction depositForUser(\n    address user_,\n    uint256 amount_\n) external payable {\n    // Enforce platform user limit\n    bool newKey = !hasEverDeposited[user_];\n    if (newKey && userBalances.length >= (MAX_PLATFORM_USERS - 1)) {\n        revert(\"Max platform users reached\");\n    }\n    \n    // User can now access raffles\n    // If they deposit, they occupy a slot for life\n    // Admin can only remove them via returnDeposits\n    // But if user reverts transfers, they cannot be removed\n    \n    if (newKey) {\n        userBalances[user_] = amount_;\n        hasEverDeposited[user_] = true;\n    } else {\n        userBalances[user_] += amount_;\n    }\n}\n\n// The only way to free up a user slot:\nfunction returnDeposits(\n    uint32[] calldata raffleIds_,\n    address[] calldata users_\n) external onlyRole(PLATFORM_ADMIN_ROLE) {\n    // If ANY user reverts the transfer, entire batch fails\n    // And no users are removed, wasting admin effort\n    for (uint256 i = 0; i < raffleIds_.length; i++) {\n        _performTransfer(users_[i], userBalances[users_[i]]);\n        // If this reverts, we never reach the cleanup:\n        userBalances[users_[i]] = 0;  // Never executed\n    }\n}"
      },
      {
        "name": "Griefing Attack Scenario",
        "path": "reference/minthub_griefing_scenario.md",
        "relevance": "Documents the attack flow and impact",
        "content": "GRIEFING SCENARIO: Occupying MAX_PLATFORM_USERS slots\n\nSetup:\n- Platform has MAX_PLATFORM_USERS = 10,000,000\n- Current users: 9,999,998 (nearly full)\n- Legitimate user wants to join but cannot: at capacity\n\nAttack Flow:\n\n1. Attacker creates contract with malicious receive:\n   ```solidity\n   contract MaliciousUser {\n       receive() external payable {\n           revert(\"I reject transfers!\");\n       }\n   }\n   ```\n\n2. Attacker deposits to MintHub:\n   - depositForUser(maliciousUserContract, 1 MON)\n   - userBalances[maliciousUserContract] = 1 MON\n   - Now occupying a user slot (10,000,000 reached)\n   - No intention to participate in raffles\n\n3. Admin notices user 9,999,999 is not participating, tries removal:\n   - returnDeposits([raffleId], [maliciousUserContract])\n   - Calls _performTransfer(maliciousUserContract, 1 MON)\n   - Transfer triggers maliciousUserContract.receive()\n   - receive() reverts with \"I reject transfers!\"\n   - Entire returnDeposits transaction REVERTS\n\n4. User remains on platform:\n   - userBalances[maliciousUserContract] still = 1 MON\n   - hasEverDeposited[maliciousUserContract] = true\n   - User slot still occupied\n\n5. Impact on legitimate users:\n   - Platform at MAX_PLATFORM_USERS capacity\n   - Legitimate user cannot join (capacity check blocks them)\n   - Malicious user can keep blocking slot indefinitely\n   - Admin cannot force-remove due to revert griefing\n\nIMPACT AMPLIFICATION:\n- With multiple griefing contracts, attackers can occupy many slots\n- Legitimate users are locked out completely\n- Platform cannot admit new users despite having better candidates\n- Each griefing contract pays only 1 MON but consumes a valuable slot\n\nROOT CAUSE:\n- _performTransfer has no failure handling\n- returnDeposits reverts on ANY transfer failure\n- No atomic removal guarantee (transfer must succeed for cleanup to execute)\n- Malicious receive function can block transfers indefinitely"
      },
      {
        "name": "Transfer Revert Patterns",
        "path": "reference/malicious_receive_examples.md",
        "relevance": "Shows different ways a receive function can revert transfers",
        "content": "Common patterns for reverting native token transfers:\n\nPattern 1: Unconditional revert\n```solidity\ncontract AlwaysRevert {\n    receive() external payable {\n        revert(\"No transfers\");\n    }\n}\n```\n\nPattern 2: Conditional revert (e.g., on specific value)\n```solidity\ncontract ConditionalRevert {\n    receive() external payable {\n        if (msg.value < 1 ether) revert(\"Min amount\");\n        // Or revert if from specific address\n        if (msg.sender == address(mintHub)) revert(\"MintHub blocked\");\n    }\n}\n```\n\nPattern 3: Out-of-gas revert\n```solidity\ncontract OutOfGasAttack {\n    uint256 x;\n    receive() external payable {\n        // Expensive loop to consume gas\n        for (uint256 i = 0; i < 1e6; i++) {\n            x = keccak256(abi.encode(i));\n        }\n    }\n}\n```\n\nPattern 4: Fallback revert\n```solidity\ncontract FallbackRevert {\n    fallback() external payable {\n        revert(\"Fallback blocked\");\n    }\n    // No receive, so fallback is called\n}\n```\n\nAll of these prevent _performTransfer from succeeding:\n- (bool succeeded, ) = recipient_.call{value: value_}(\"\");\n- If receive/fallback reverts, succeeded = false\n- returnDeposits checks !succeeded and reverts entire transaction\n- User cannot be removed"
      }
    ],
    "call_flow": [
      "1. Attacker deploys contract with malicious receive()",
      "2. Attacker calls depositForUser(maliciousContract, minimal_amount)",
      "3. MintHub checks: newKey && userBalances.length < MAX_PLATFORM_USERS - 1",
      "4. Attacker is added to platform (occupying one of MAX_PLATFORM_USERS slots)",
      "5. Attacker never participates in raffles, just squats",
      "6. Admin detects unused account, calls returnDeposits([id], [attacker])",
      "7. returnDeposits calls _performTransfer(attacker, balance)",
      "8. _performTransfer executes: attacker.call{value: balance}(\"\")",
      "9. Call triggers attacker's receive() function",
      "10. receive() reverts with custom error",
      "11. (bool succeeded, ) = ... returns succeeded = false",
      "12. _performTransfer reverts: revert(\"Transfer failed\")",
      "13. returnDeposits transaction reverts, never reaches userBalances[attacker] = 0",
      "14. Attacker remains in platform, slot still occupied",
      "15. Legitimate user cannot join: capacity is full"
    ],
    "context_hint": "This is a classic griefing vulnerability where a user can deliberately make themselves impossible to remove by reverting transfers. The platform has a hard capacity limit (MAX_PLATFORM_USERS), making slot squatting an effective attack. The vulnerability chains two issues: (1) transfer failure causes entire admin operation to revert, (2) no alternative removal mechanism when transfers fail.",
    "expert_notes": "The fix requires decoupling the transfer operation from the cleanup operation, or wrapping native tokens so transfers cannot revert. Cantina recommended wrapping native tokens (e.g., WMON) for reward distribution to ensure atomic success. The deeper issue is the assumption that transfer failures are exceptional rather than attack vectors. InfiniFi fixed this in PR #b1e429c by implementing wrapped token handling and recovery mechanisms.",
    "fix_description": "Implement wrapped token fallback to ensure transfers cannot be griefed by malicious receive functions. Also add rescue mechanisms for tokens that cannot be transferred.",
    "fix_code": "function returnDeposits(\n    uint32[] calldata raffleIds_,\n    address[] calldata users_\n) external onlyRole(PLATFORM_ADMIN_ROLE) {\n    require(raffleIds_.length == users_.length, \"ArrayLengthMismatch\");\n    \n    for (uint256 i = 0; i < raffleIds_.length; i++) {\n        uint32 raffleId = raffleIds_[i];\n        address user = users_[i];\n        uint256 userBalance = userBalances[user];\n        \n        // FIXED: First attempt native token transfer\n        bool transferred = _performTransferSafe(user, userBalance);\n        \n        // If native transfer fails, wrap into WMON and transfer wrapped token\n        if (!transferred) {\n            _performWrappedTransfer(user, userBalance);\n        }\n        \n        // Always clear balance regardless of transfer success\n        userBalances[user] = 0;\n        \n        // Remove from active user tracking\n        _removeUserFromActiveSlot(user);\n    }\n}\n\nfunction _performTransferSafe(\n    address recipient_,\n    uint256 value_\n) internal returns (bool) {\n    // Limit gas passed to receive function to prevent out-of-gas attacks\n    (bool succeeded, ) = recipient_.call{value: value_, gas: 2300}(\"\");\n    return succeeded;\n}\n\nfunction _performWrappedTransfer(\n    address recipient_,\n    uint256 value_\n) internal {\n    // FIXED: If native transfer fails, wrap into WMON\n    // WMON.deposit{value: value_}();\n    // IERC20(WMON).transfer(recipient_, value_);\n    // Wrapped token transfers use ERC20 standard and cannot be griefed via receive\n}\n\nfunction _removeUserFromActiveSlot(\n    address user_\n) internal {\n    // Track removal to free up a slot for legitimate users\n    hasEverDeposited[user_] = false;  // Reset so they can rejoin if desired\n    emit UserRemoved(user_);\n}"
  }
]