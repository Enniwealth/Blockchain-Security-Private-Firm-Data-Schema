{
  "id": "gs_auditors_arcadia_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Arcadia Accounts V2 Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Arcadia-security-review-October.pdf",
  "github_repo_url": "https://github.com/arcadia-finance/accounts-v2/tree/08bc2a06dcc73ec13d326fe812179d865e3c67c5",
  "contest_date": "2025-10-24",
  
  "severity": "medium",
  "vulnerability_type": "incorrect_transfer_recipient",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "ETH withdrawn is sent to msg.sender instead of the to address",
  "finding_description": "In the AccountSpot contract, the `_withdraw` function does not use the `to` address as the recipient of the withdrawn funds in the case of an ETH withdrawal but instead uses `msg.sender` as the recipient. This removes the ability of the withdrawer to specify a different address to receive the funds and, what is more, can lead to the loss of funds if the caller is expecting the funds to be sent to the `to` address, as the NatSpec comment explicitly states that the `to` address is the recipient of the withdrawn funds.",
  "attack_scenario": "A user or contract calls the `_withdraw` function and specifies a custom recipient address in the `to` parameter (e.g., a cold wallet or a relayer contract). However, when withdrawing native ETH (`assetAddresses[i] == address(0)`), the function sends the ETH to `msg.sender` instead of the specified `to` address. This violates the documented behavior, potentially causing the calling contract to hold unexpected funds or the user to lose track of the assets if they were expecting them at the specified `to` address.",
  "fix_description": "Use the `to` address as the recipient of the withdrawn funds in the case of an ETH withdrawal. Change the vulnerable line from `payable(msg.sender).call{value: assetAmounts[i]}(\"\")` to `payable(to).call{value: assetAmounts[i]}(\"\")`. If the expected behavior is that funds can only be withdrawn to the caller, add a condition to check that `to == msg.sender` and revert otherwise.",
  
  "primary_file": {
    "path": "src/accounts/AccountSpot.sol",
    "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AccountErrors } from "../libraries/Errors.sol";\nimport { AccountStorageV1 } from "./AccountStorageV1.sol";\nimport { ActionData, IActionBase } from "../interfaces/IActionBase.sol";\nimport { ERC20, SafeTransferLib } from "../../lib/solmate/src/utils/SafeTransferLib.sol";\nimport { IAccount } from "../interfaces/IAccount.sol";\nimport { IERC721 } from "../interfaces/IERC721.sol";\nimport { IERC1155 } from "../interfaces/IERC1155.sol";\nimport { IPermit2 } from "../interfaces/IPermit2.sol";\n\n/**\n * @title Arcadia Spot Account\n * @author Pragma Labs\n * @notice Arcadia Spot Accounts enables individuals, DAOs, and other protocols to deposit and manage a variety of assets easily through Asset Managers.\n * Asset Managers are selected by Spot Account holders and can facilitate automation for tasks such as Liquidity Management and Compounding, among others.\n */\ncontract AccountSpot is AccountStorageV1, IAccount {\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The current Account Version.\n    uint256 public constant ACCOUNT_VERSION = 2;\n    // The cool-down period after an account action, that might be disadvantageous for a new Owner,\n    // during which ownership cannot be transferred to prevent the old Owner from frontrunning a transferFrom().\n    uint256 public constant COOL_DOWN_PERIOD = 5 minutes;\n    // Storage slot with the address of the current implementation.\n    // This is the hardcoded keccak-256 hash of: "eip1967.proxy.implementation" subtracted by 1.\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    // The contract address of the Arcadia Accounts Factory.\n    address public immutable FACTORY;\n    // Uniswap Permit2 contract\n    IPermit2 internal immutable PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    // Storage slot for the Account implementation, a struct to avoid storage conflict when dealing with upgradeable contracts.\n    struct AddressSlot {\n        address value;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AssetManagerSet(address indexed owner, address indexed assetManager, bool value);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @dev Throws if function is reentered.\n     */\n    modifier nonReentrant() {\n        if (locked != 1) revert AccountErrors.NoReentry();\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /**\n     * @dev Throws if called by any address other than an Asset Manager or the owner.\n     */\n    modifier onlyAssetManager() {\n        // A custom error would need to read out owner + isAssetManager storage\n        require(msg.sender == owner || isAssetManager[owner][msg.sender], "A: Only Asset Manager");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the Factory address.\n     */\n    modifier onlyFactory() {\n        if (msg.sender != FACTORY) revert AccountErrors.OnlyFactory();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the owner.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert AccountErrors.OnlyOwner();\n        _;\n    }\n\n    /**\n     * @dev Starts the cool-down period during which ownership cannot be transferred.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    modifier updateActionTimestamp() {\n        lastActionTimestamp = uint32(block.timestamp);\n        _;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @param factory The contract address of the Arcadia Accounts Factory.\n     */\n    constructor(address factory) {\n        // This will only be the owner of the Account implementation.\n        // and will not affect any subsequent proxy implementation using this Account implementation.\n        owner = msg.sender;\n\n        FACTORY = factory;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          ACCOUNT MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Initiates the variables of the Account.\n     * @param owner_ The sender of the 'createAccount' on the Factory\n     * @param registry_ The 'beacon' contract with the external logic to price assets.\n     * @dev A proxy will be used to interact with the Account implementation.\n     * This function will only be called (once) in the same transaction as the proxy Account creation through the Factory.\n     * @dev initialize has implicitly a nonReentrant guard, since the "locked" variable has value zero until the end of the function.\n     * @dev The Registry is not used in spot accounts, but a valid registry must be set to be compatible with V1 Accounts.\n     */\n    function initialize(address owner_, address registry_, address) external onlyFactory {\n        if (registry_ == address(0)) revert AccountErrors.InvalidRegistry();\n        owner = owner_;\n        registry = registry_;\n\n        locked = 1;\n    }\n\n    /**\n     * @notice Upgrades the Account version and stores a new address in the EIP1967 implementation slot.\n     * @param newImplementation The new contract address of the Account implementation.\n     * @param newRegistry The Registry for this specific newImplementation.\n     * @param data Arbitrary data, can contain instructions to execute when updating Account to new implementation.\n     * @dev This function MUST be added to new Account implementations.\n     */\n    function upgradeAccount(address newImplementation, address newRegistry, uint256, bytes calldata data)\n        external\n        onlyFactory\n        nonReentrant\n        updateActionTimestamp\n    {\n        // Cache old parameters.\n        address oldImplementation = _getAddressSlot(IMPLEMENTATION_SLOT).value;\n        uint256 oldVersion = ACCOUNT_VERSION;\n\n        // Store new parameters.\n        _getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n        registry = newRegistry;\n\n        // Hook on the new logic to finalize upgrade.\n        // Used to eg. Remove exposure from old Registry and add exposure to the new Registry.\n        // Extra data can be added by the Factory for complex instructions.\n        this.upgradeHook(oldImplementation, address(0), oldVersion, data);\n\n        // Event emitted by Factory.\n    }\n\n    /**\n     * @notice Returns the "AddressSlot" with member "value" located at "slot".\n     * @param slot The slot where the address of the Logic contract is stored.\n     * @return r The address stored in slot.\n     */\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @notice Finalizes the Upgrade from a different Account version to this version.\n     * param oldImplementation The old contract address of the Account implementation.\n     * param oldRegistry The Registry of the old version (might be identical to the new registry)\n     * param oldVersion The old version of the Account implementation.\n     * param data Arbitrary data, can contain instructions to execute in this function.\n     * @dev If upgradeHook() is implemented, it MUST verify that msg.sender == address(this).\n     * @dev We delete the deprecated AccountStorageV1 variables.\n     */\n    function upgradeHook(address, address, uint256, bytes calldata) external {\n        if (msg.sender != address(this)) revert AccountErrors.OnlySelf();\n        if (registry == address(0)) revert AccountErrors.InvalidRegistry();\n\n        // Require that no creditor is set and no auctions are ongoing.\n        // (This should always be enforced in the old Version we upgrade from, but we do a redundant safety check).\n        if (creditor != address(0) || inAuction) revert AccountErrors.InvalidUpgrade();\n\n        // Delete margin account related storage data (should normally already be empty).\n        delete liquidator;\n        delete minimumMargin;\n        delete numeraire;\n\n        // Delete asset related storage data.\n        uint256 erc20StoredLength = erc20Stored.length;\n        for (uint256 i = 0; i < erc20StoredLength; ++i) {\n            delete erc20Balances[erc20Stored[i]];\n        }\n        delete erc20Stored;\n\n        delete erc721Stored;\n        delete erc721TokenIds;\n\n        uint256 erc1155StoredLength = erc1155Stored.length;\n        for (uint256 j = 0; j < erc1155StoredLength; ++j) {\n            delete erc1155Balances[erc1155Stored[j]][erc1155TokenIds[j]];\n        }\n        delete erc1155Stored;\n        delete erc1155TokenIds;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        OWNERSHIP MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Transfers ownership of the contract to a new Account.\n     * @param newOwner The new owner of the Account.\n     * @dev Can only be called by the current owner via the Factory.\n     * A transfer of ownership of the Account is triggered by a transfer\n     * of ownership of the accompanying ERC721 Account NFT, issued by the Factory.\n     * Owner of Account NFT = owner of Account\n     * @dev Function uses a cool-down period during which ownership cannot be transferred.\n     * Cool-down period is triggered after any account action, that might be disadvantageous for a new Owner.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    function transferOwnership(address newOwner) external onlyFactory {\n        if (block.timestamp <= lastActionTimestamp + COOL_DOWN_PERIOD) revert AccountErrors.CoolDownPeriodNotPassed();\n\n        // The Factory will check that the new owner is not address(0).\n        owner = newOwner;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       ASSET MANAGER ACTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or remove an Asset Manager.\n     * @param assetManager The address of the Asset Manager.\n     * @param value A boolean giving permissions to or taking permissions from an Asset Manager.\n     * @dev Only set trusted addresses as Asset Manager. Asset Managers have full control over assets in the Account.\n     * @dev No need to set the Owner as Asset Manager as they will automatically have all permissions of an Asset Manager.\n     * @dev Potential use-cases of the Asset Manager might be to:\n     * - Liquidity Management.\n     * - Do flash actions (optimistic actions).\n     * - Compounding.\n     * - Chain multiple interactions together.\n     * @dev Anyone can set the Asset Manager for themselves, this will not impact the current owner of the Account\n     * since the combination of "stored owner -> asset manager" is used in authentication checks.\n     * This guarantees that when the ownership of the Account is transferred, the asset managers of the old owner have no\n     * impact on the new owner. But the new owner can still remove any existing asset managers before the transfer.\n     */\n    function setAssetManager(address assetManager, bool value) external {\n        emit AssetManagerSet(msg.sender, assetManager, isAssetManager[msg.sender][assetManager] = value);\n    }\n\n    /**\n     * @notice Executes a flash action.\n     * @param actionTarget The contract address of the actionTarget to execute external logic.\n     * @param actionData A bytes object containing three structs and two bytes objects.\n     * The first struct contains the info about the assets to withdraw from this Account to the actionTarget.\n     * The second struct contains the info about the owner's assets that need to be transferred from the owner to the actionTarget.\n     * The third struct contains the permit for the Permit2 transfer.\n     * The first bytes object contains the signature for the Permit2 transfer.\n     * The second bytes object contains the encoded input for the actionTarget.\n     * @dev This function optimistically chains multiple actions together (= do a flash action):\n     * - It can optimistically withdraw assets from the Account to the actionTarget.\n     * - It can transfer assets directly from the owner to the actionTarget.\n     * - It can execute external logic on the actionTarget, and interact with any DeFi protocol to swap, stake, claim...\n     * - It can deposit all recipient tokens from the actionTarget back into the Account.\n     */\n    function flashAction(address actionTarget, bytes calldata actionData)\n        external\n        payable\n        onlyAssetManager\n        nonReentrant\n        updateActionTimestamp\n    {\n        // Decode flash action data.\n        (\n            ActionData memory withdrawData,\n            ActionData memory transferFromOwnerData,\n            IPermit2.PermitBatchTransferFrom memory permit,\n            bytes memory signature,\n            bytes memory actionTargetData\n        ) = abi.decode(actionData, (ActionData, ActionData, IPermit2.PermitBatchTransferFrom, bytes, bytes));\n\n        // Withdraw assets to the actionTarget.\n        _withdraw(\n            withdrawData.assets, withdrawData.assetIds, withdrawData.assetAmounts, withdrawData.assetTypes, actionTarget\n        );\n\n        // Transfer assets from owner (that are not assets in this account) to the actionTarget.\n        if (transferFromOwnerData.assets.length > 0) {\n            _transferFromOwner(transferFromOwnerData, actionTarget);\n        }\n\n        // If the function input includes a signature and non-empty token permissions,\n        // initiate a transfer from the owner to the actionTarget via Permit2.\n        if (signature.length > 0 && permit.permitted.length > 0) {\n            _transferFromOwnerWithPermit(permit, signature, actionTarget);\n        }\n\n        // Execute external logic on the actionTarget.\n        ActionData memory depositData = IActionBase(actionTarget).executeAction(actionTargetData);\n\n        // Deposit assets from actionTarget into Account.\n        _deposit(\n            depositData.assets, depositData.assetIds, depositData.assetAmounts, depositData.assetTypes, actionTarget\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Deposits assets into the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     */\n    function deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes\n    ) external payable onlyOwner nonReentrant {\n        _deposit(assetAddresses, assetIds, assetAmounts, assetTypes, msg.sender);\n    }\n\n    /**\n     * @notice Deposits assets into the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     * @param from The assets deposited into the Account will come from this address.\n     */\n    function _deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes,\n        address from\n    ) internal {\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent transferring addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetTypes[i] == 1) {\n                ERC20(assetAddresses[i]).safeTransferFrom(from, address(this), assetAmounts[i]);\n            } else if (assetTypes[i] == 2) {\n                IERC721(assetAddresses[i]).safeTransferFrom(from, address(this), assetIds[i]);\n            } else if (assetTypes[i] == 3) {\n                IERC1155(assetAddresses[i]).safeTransferFrom(from, address(this), assetIds[i], assetAmounts[i], "");\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws assets from the Account to the owner.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     */\n    function withdraw(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes\n    ) public onlyOwner nonReentrant updateActionTimestamp {\n        _withdraw(assetAddresses, assetIds, assetAmounts, assetTypes, msg.sender);\n    }\n\n    /**\n     * @notice Withdraws assets from the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     * @param to The address to withdraw to.\n     */\n    function _withdraw(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes,\n        address to\n    ) internal {\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent transferring addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetAddresses[i] == address(0)) {\n                (bool success, bytes memory result) = payable(msg.sender).call{ value: assetAmounts[i] }("");\n                require(success, string(result));\n            } else if (assetTypes[i] == 1) {\n                ERC20(assetAddresses[i]).safeTransfer(to, assetAmounts[i]);\n            } else if (assetTypes[i] == 2) {\n                IERC721(assetAddresses[i]).safeTransferFrom(address(this), to, assetIds[i]);\n            } else if (assetTypes[i] == 3) {\n                IERC1155(assetAddresses[i]).safeTransferFrom(address(this), to, assetIds[i], assetAmounts[i], "");\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers assets directly from the owner to the actionTarget contract.\n     * @param transferFromOwnerData A struct containing the info of all assets transferred from the owner that are not in this account.\n     * @param to The address to withdraw to.\n     */\n    function _transferFromOwner(ActionData memory transferFromOwnerData, address to) internal {\n        uint256 assetAddressesLength = transferFromOwnerData.assets.length;\n        address owner_ = owner;\n        for (uint256 i; i < assetAddressesLength; ++i) {\n            // Skip if amount is 0 to prevent transferring 0 balances.\n            if (transferFromOwnerData.assetAmounts[i] == 0) continue;\n\n            if (transferFromOwnerData.assetTypes[i] == 1) {\n                ERC20(transferFromOwnerData.assets[i]).safeTransferFrom(\n                    owner_, to, transferFromOwnerData.assetAmounts[i]\n                );\n            } else if (transferFromOwnerData.assetTypes[i] == 2) {\n                IERC721(transferFromOwnerData.assets[i]).safeTransferFrom(owner_, to, transferFromOwnerData.assetIds[i]);\n            } else if (transferFromOwnerData.assetTypes[i] == 3) {\n                IERC1155(transferFromOwnerData.assets[i]).safeTransferFrom(\n                    owner_, to, transferFromOwnerData.assetIds[i], transferFromOwnerData.assetAmounts[i], ""\n                );\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers assets from the owner to the actionTarget contract via Permit2.\n     * @param permit Data specifying the terms of the transfer.\n     * @param signature The signature to verify.\n     * @param to_ The address to withdraw to.\n     */\n    function _transferFromOwnerWithPermit(\n        IPermit2.PermitBatchTransferFrom memory permit,\n        bytes memory signature,\n        address to_\n    ) internal {\n        uint256 tokenPermissionsLength = permit.permitted.length;\n        IPermit2.SignatureTransferDetails[] memory transferDetails =\n            new IPermit2.SignatureTransferDetails[](tokenPermissionsLength);\n\n        for (uint256 i; i < tokenPermissionsLength; ++i) {\n            transferDetails[i].to = to_;\n            transferDetails[i].requestedAmount = permit.permitted[i].amount;\n        }\n\n        PERMIT2.permitTransferFrom(permit, transferDetails, owner, signature);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        HELPER FUNCTIONS\n    /////////////////////////////////////////////////////////////// */\n\n    /* \n    @notice Returns the onERC721Received selector.\n    @dev Needed to receive ERC721 tokens.\n    */\n    function onERC721Received(address, address, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /*\n    @notice Returns the onERC1155Received selector.\n    @dev Needed to receive ERC1155 tokens.\n    */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /*\n    @notice Called when function selector doesn't match any other.\n    @dev No fallback allowed.\n    */\n    fallback() external {\n        revert AccountErrors.NoFallback();\n    }\n\n    /*\n    @notice Called on a plain ETH transfer.\n    */\n    receive() external payable { }\n}",
    "vulnerable_lines": [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53],
    "vulnerable_functions": ["_withdraw"]
  },
  
  "context_files": [],
  
  "call_flow": "User calls public withdraw function -> Internal call to `_withdraw(..., to)` -> Inside loop, when `assetAddresses[i] == address(0)` (for ETH) -> Execution of `payable(msg.sender).call{value: amount}(\"\")` -> ETH is sent to `msg.sender` instead of the `to` parameter.",
  "context_hint": "A logic error where the code for native ETH withdrawal uses `msg.sender` as the recipient of the funds, despite the function signature and NatSpec comment explicitly defining a separate `to` address parameter. The code for ERC20/ERC721/ERC1155 correctly uses the `to` parameter.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The vulnerability is a direct contradiction between the function's documentation (`@param to The address to withdraw to`) and its implementation (`payable(msg.sender).call{...}`). This is a high-impact logic bug for users expecting to be able to withdraw to an arbitrary address."
}

{
  "id": "gs_pashov_bunni_C01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "arbitrary_token_claim",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "claimRecurPool does not verify the provided incentiveToken is equal to rewardToken",
  "finding_description": "When the `claimRecurPool` function is called, it iterates through the claims but does not verify that the `incentiveToken` provided in the `RecurClaimParams` is equal to the `rewardToken` associated with the claimed `RecurPoolKey`. This allows an attacker to claim rewards denominated in one token but receive a different, possibly more valuable, token.",
  "attack_scenario": "1. Attacker creates a fake Recur Pool with an arbitrary/worthless reward token but provides a high `rewardRate`.\n2. When calling `claimRecurPool`, the attacker uses the ID of their fake pool but sets the `incentiveToken` parameter to the address of a valuable token (e.g., WETH, or a core protocol token) that is held by the `MasterBunni` contract (e.g., from a genuine pool).\n3. The reward amount is calculated based on the fake pool's high rate, and this high amount of the valuable token is transferred to the recipient, effectively stealing funds from the contract's overall balance.",
  "fix_description": "Validate that the provided `incentiveToken` (from `params[i].incentiveToken`) is equal to the `rewardToken` of each `RecurPoolKey` being processed within the loop.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [11],
    "vulnerable_functions": ["claimRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.claimRecurPool(fakePoolKey, recipient) -> MasterBunni calculates reward for fakePoolKey (which uses rewardToken A) -> MasterBunni transfers `totalClaimableAmount` of `incentiveToken B` (specified by attacker) to recipient. Token B is stolen.",
  "context_hint": "The claim function relies on a user-provided `incentiveToken` parameter for the final transfer, rather than enforcing that the `incentiveToken` matches the `rewardToken` determined by the `RecurPoolKey`. This decouples the reward calculation from the token being paid out, leading to critical asset theft.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A very high-impact logic error allowing asset drain via a token substitution attack. Crucial state integrity check is missing."
}

{
  "id": "gs_pashov_bunni_C02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "inconsistent_state_update",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "incentiveToken is not verified within incentivizeRecurPool",
  "finding_description": "The `incentivizeRecurPool` function allows a user to update the `state.rewardRate` for a pool using an arbitrary `incentiveToken` provided as an argument, without verifying that this token matches the pool's actual `rewardToken` (which is part of the `RecurPoolKey`). This allows a malicious actor to deposit a worthless token while increasing the reward rate for the pool's legitimate reward token.",
  "attack_scenario": "1. A legitimate pool exists where `rewardToken` is WETH.\n2. An attacker calls `incentivizeRecurPool` for this pool, providing a large `incentiveAmount` and setting `incentiveToken` to a worthless token (e.g., AttackerToken).\n3. The reward rate for the WETH pool is updated based on the large amount.\n4. The function executes a `safeTransferFrom` of the worthless AttackerToken, which successfully transfers the token to the contract.\n5. Legitimate users see a high reward rate for WETH, but when they try to claim, the contract quickly runs out of WETH (the actual reward token), or the pool accounting is permanently ruined because the reward token stored in the contract is useless (AttackerToken) but the promised reward is WETH.",
  "fix_description": "Validate that the `incentiveToken` parameter is equal to the `rewardToken` associated with the `RecurPoolKey` within the `incentivizeRecurPool` function.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [47],
    "vulnerable_functions": ["incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.incentivizeRecurPool(validPoolKey, AttackerToken) -> MasterBunni updates the rewardRate state for the pool's actual rewardToken (e.g., WETH) -> MasterBunni transfers AttackerToken into the contract (the WETH reward is now under-collateralized/unclaimable).",
  "context_hint": "The function calculates the reward rate update based on the pool's configuration (which implies a `rewardToken`), but accepts a separate, unvalidated `incentiveToken` parameter for the token transfer itself, allowing the attacker to increase the effective reward rate of a valuable token by depositing a worthless one.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Similar to C-01, this is a critical integrity check failure leading to corrupted reward state and potential denial of service or asset loss for LPs relying on the correct reward mechanism."
}

{
  "id": "gs_pashov_bunni_C03",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-03]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "reward_loss_logic",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "Previous rewardRate is removed when periodFinish has not yet been reached",
  "finding_description": "In `incentivizeRecurPool`, when adding a new incentive while the current reward period (`periodFinish`) is still active, the new reward rate (`newRewardRate`) is calculated and then assigned directly to `state.rewardRate` instead of being added to the existing `state.rewardRate`. This overwrites and effectively removes the previous incentive provider's reward rate, causing their provided reward amount to be lost/unclaimable.",
  "attack_scenario": "1. User A provides an incentive for 30 days, setting a high `state.rewardRate`.\n2. Before the 30 days are up, User B calls `incentivizeRecurPool` with a new, smaller incentive amount.\n3. The code calculates the `newRewardRate` based only on User B's incentive and the remaining duration.\n4. This calculated `newRewardRate` (B) is assigned to `state.rewardRate`, overwriting the previous, higher `state.rewardRate` (A).\n5. LPs who staked for User A's incentive will receive significantly fewer rewards than promised for the remainder of the period, as the reward rate has been artificially lowered by the overwrite. User A's funds are essentially locked or permanently lost due to the incorrect accounting.",
  "fix_description": "When the current period is still active (`block.timestamp < periodFinish`), the calculated `newRewardRate` (based on the new deposit) must be added to the existing `state.rewardRate`. The fix is changing `state.rewardRate = newRewardRate;` to `state.rewardRate += newRewardRate;` in the `else` block.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [28],
    "vulnerable_functions": ["incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "User A calls incentivizeRecurPool (Period Active) -> User B calls incentivizeRecurPool (Period Active) -> MasterBunni calculates B's `newRewardRate` -> MasterBunni sets `state.rewardRate = newRewardRate` (overwrites A's contribution) -> A's funds are effectively locked/lost.",
  "context_hint": "A fundamental accounting error in managing concurrent incentives. By assigning the newly calculated rate instead of adding it, the pool's reward state is reset, causing rewards promised by previous depositors to be canceled for the remainder of the period.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a direct economic exploit that steals or locks existing incentive providers' funds, causing material loss and breaking trust in the staking mechanism. Easily fixable by changing assignment to addition."
}

{
  "id": "gs_pashov_bunni_H01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[H-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "high",
  "vulnerability_type": "denial_of_unstake",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "joinRecurPool can incorrectly increment userPoolCounts",
  "finding_description": "The `joinRecurPool` function incorrectly increments `userPoolCounts[msgSender][key.stakeToken]` even when the user is only updating their staked balance (i.e., not the first time joining the pool). Since `userPoolCounts` is designed to track the number of distinct pools a user has joined for a specific stake token, its inflation will prevent users from successfully calling the unlock mechanism (which relies on this counter decreasing to zero for the final unlock), leading to a permanent denial of unstake for the affected tokens.",
  "attack_scenario": "1. User A joins a Recur Pool (Pool 1) with Stake Token X. `userPoolCounts[A][X]` becomes 1.\n2. User A later increases their balance of Stake Token X and calls `joinRecurPool` again for Pool 1 (to update their staked amount).\n3. The code incorrectly executes `++userPoolCounts[A][X]`, making the counter 2.\n4. When User A exits all pools, the unlock function will attempt to decrement this counter, but it will never reach zero, permanently locking User A's Stake Token X.",
  "fix_description": "Increment `userPoolCounts` only if the previous staked balance (`stakedBalance`) was zero, indicating the user is joining the pool for the first time. Add a check: `if (stakedBalance == 0) { ++userPoolCounts[msgSender][key.stakeToken]; }`.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [23],
    "vulnerable_functions": ["joinRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "User calls `joinRecurPool` second time (to update stake) -> `stakedBalance > 0` -> `++userPoolCounts` executes redundantly -> Counter becomes $> 1$ for a single pool -> Token unlock mechanism fails.",
  "context_hint": "A state accounting error tied to a core component (`userPoolCounts`) used for token locking/unlocking. Over-incrementing this counter prevents the user from ever fully unlocking their token, leading to permanent asset loss.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a severe vulnerability as it locks user funds. The fix requires checking the prior state (`stakedBalance == 0`) before incrementing the pool count."
}

{
  "id": "gs_pashov_bunni_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "transfer_logic_bypass",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "depositIncentive and incentivizeRecurPool do not verify if the incentiveToken exists",
  "finding_description": "Both `depositIncentive` (for RushPools) and `incentivizeRecurPool` (for RecurPools) use a version of Solady's `safeTransferFrom2` which does not check the code size of the `incentiveToken` address before performing the transfer call. In Solidity's assembly, if there is no return data (which happens when calling a non-contract address), the call is treated as successful. This allows an attacker to provide a non-contract address as the `incentiveToken` and proceed with updating the reward accounting state without actually transferring any tokens, or use a predictable address of a token that is yet to be created.",
  "attack_scenario": "1. An attacker determines the predictable future address of a legitimate Bunni LP token (Token X).\n2. The attacker calls `incentivizeRecurPool`, using the address of the uncreated Token X and providing a huge fake `incentiveAmount`.\n3. The `safeTransferFrom2` call to the uncreated address is treated as successful due to the lack of code size check, and no actual tokens are transferred to the protocol.\n4. The reward accounting state is updated based on the huge fake incentive, immediately disrupting the pool's reward rate and potentially leading to a permanent locking of real rewards deposited later.",
  "fix_description": "Upgrade the protocol to use the latest version of Solady's SafeTransferLib, which includes a code size check for contract addresses during transfers, or manually implement a code size check (`address(incentiveToken).code.length > 0`) before initiating the transfer.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["depositIncentive", "incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.depositIncentive(..., uncreatedTokenAddress) -> MasterBunni calls `uncreatedTokenAddress.safeTransferFrom2(...)` -> Solady's underlying assembly accepts the transfer as successful (due to no return data from non-contract) -> Reward state is corrupted without deposit.",
  "context_hint": "An issue stemming from reliance on a vulnerable/outdated external library implementation (`SafeTransferLib`). This allows attackers to manipulate reward accounting state using fake deposits to non-existent contract addresses, leading to reward corruption/disruption.",
  
  "is_vulnerable": true,
  
  "expert_notes": "While the impact can be high (reward corruption), the likelihood depends on the attacker's ability to predict addresses (Medium/Low), hence the Medium severity. The core issue is the missing code size check for the token address."
}

{
  "id": "gs_pashov_bunni_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "DOS Attack in joinRushPool",
  "finding_description": "The `joinRushPool` function allows users to stake tokens up to a maximum cap. However, the lack of time restrictions (such as a minimum stake duration or an unstaking delay) allows malicious actors to perform a sandwich attack, repeatedly front-running and back-running legitimate users' stake transactions to keep the pool permanently full.",
  "attack_scenario": "1. Attacker observes a pending transaction where a legitimate user attempts to call `joinRushPool`.\n2. **Front-run:** Attacker calls `joinRushPool` to fill the pool up to its stake cap.\n3. Victim's transaction fails because the pool capacity is zero.\n4. **Back-run:** Attacker immediately calls `exitRushPool` to withdraw their stake, emptying the pool for the next opportunity.\n5. The attacker can repeat this process indefinitely, preventing legitimate users from ever staking, costing only the gas fees for the sandwich transactions.",
  "fix_description": "It is recommended to implement an anti-sandwich measure, such as a minimum stake duration or an unstaking delay, to increase the cost and reduce the profitability of this DOS attack.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["joinRushPool", "exitRushPool"],
    "vulnerable_lines": [10]
  },
  
  "context_files": [],
  
  "call_flow": "Victim.joinRushPool (pending) -> Attacker.joinRushPool (fills cap) -> Victim TX reverts -> Attacker.exitRushPool (empties cap) -> Repeat.",
  "context_hint": "Economic Denial of Service vulnerability arising from the lack of temporal restrictions on staking and unstaking in a capped pool. The attacker uses cheap, reversible transactions to maintain a persistent block on legitimate users.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A standard mechanism for DOS in capped pools without time locks. While it doesn't lead to direct asset loss from the protocol, it severely harms user experience and can disrupt the protocol's liquidity acquisition strategy."
}


{
  "id": "gs_pashov_bunni_M04",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-04]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "incorrect_arithmetic_rounding",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Incorrect tick rounding in TWAP calculation",
  "finding_description": "In `BunniHookOracle._queryTwap()`, the arithmetic mean tick is calculated by dividing the cumulative tick delta (`tickCumulativesDelta`) by the window size. When `tickCumulativesDelta` is negative, Solidity's integer division rounds toward zero (upward). Correct TWAP tick calculation requires rounding toward negative infinity (downward) to maintain accuracy and consistency with price definitions, especially for negative ticks. The current implementation can result in the tick value being off by 1.",
  "attack_scenario": "The incorrect rounding can result in a mispriced oracle value (off by one tick) when the calculated average tick is negative and not an exact integer. This slight mispricing can be abused by arbitrageurs or lead to inaccurate price-dependent operations in the protocol, potentially costing small amounts of value in each transaction relying on the TWAP.",
  "fix_description": "Implement consistent rounding-down behavior for the tick calculation by adding a check: if `tickCumulativesDelta < 0` and the remainder of the division is non-zero, decrement the resulting tick by 1.",
  
  "primary_file": {
    "path": "contracts/BunniHookOracle.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {SSTORE2} from "solady/utils/SSTORE2.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport "../external/IBunniHook.sol";\nimport {TickMath} from "../lib/TickMath.sol";\nimport {IOracle} from "../interfaces/IOracle.sol";\n\n/// @title Oracle using BunniHook TWAP oracle as data source\n/// @author zefram.eth\n/// @notice The oracle contract that provides the current price to purchase\n/// the underlying token while exercising options. Uses BunniHook TWAP oracle\n/// as data source, and then applies a multiplier & lower bound.\ncontract BunniHookOracle is IOracle, Ownable {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SSTORE2 for *;\n    using TickMath for *;\n    using FixedPointMathLib for *;\n\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    error BunniHookOracle__InvalidPoolKey();\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event SetParams(uint16 multiplier, uint32 secs, uint32 ago, uint128 minPrice);\n    event SetPoolKey(PoolKey poolKey);\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @notice The denominator for converting the multiplier into a decimal number.\n    /// i.e. multiplier uses 4 decimals.\n    uint256 internal constant MULTIPLIER_DENOM = 10000;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n\n    /// -----------------------------------------------------------------------\n    /// Immutable parameters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The BunniHook contract\n    IBunniHook public immutable bunniHook;\n\n    /// @inheritdoc IOracle\n    address public immutable paymentToken;\n\n    /// @inheritdoc IOracle\n    address public immutable underlyingToken;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @notice The multiplier applied to the TWAP value. Encodes the discount of\n    /// the options token. Uses 4 decimals.\n    uint16 public multiplier;\n\n    /// @notice The size of the window to take the TWAP value over in seconds.\n    uint32 public secs;\n\n    /// @notice The number of seconds in the past to take the TWAP from. The window\n    /// would be (block.timestamp - secs - ago, block.timestamp - ago].\n    uint32 public ago;\n\n    /// @notice The minimum value returned by getPrice(). Maintains a floor for the\n    /// price to mitigate potential attacks on the TWAP oracle.\n    uint128 public minPrice;\n\n    /// @notice The SSTORE2 pointer to the PoolKey used to query the BunniHook TWAP oracle.\n    address public poolKeyPointer;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        IBunniHook bunniHook_,\n        PoolKey memory poolKey,\n        address paymentToken_,\n        address underlyingToken_,\n        address owner_,\n        uint16 multiplier_,\n        uint32 secs_,\n        uint32 ago_,\n        uint128 minPrice_\n    ) {\n        bunniHook = bunniHook_;\n        paymentToken = paymentToken_;\n        underlyingToken = underlyingToken_;\n\n        multiplier = multiplier_;\n        secs = secs_;\n        ago = ago_;\n        minPrice = minPrice_;\n\n        emit SetParams(multiplier_, secs_, ago_, minPrice_);\n\n        _initializeOwner(owner_);\n\n        if (\n            !(\n                (poolKey.currency0 == paymentToken_ && poolKey.currency1 == underlyingToken_)\n                    || (poolKey.currency0 == underlyingToken_ && poolKey.currency1 == paymentToken_)\n            ) || poolKey.hooks != address(bunniHook_)\n        ) {\n            revert BunniHookOracle__InvalidPoolKey();\n        }\n        poolKeyPointer = abi.encode(poolKey).write();\n        emit SetPoolKey(poolKey);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// IOracle\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IOracle\n    function getPrice() external view override returns (uint256 price) {\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint16 multiplier_ = multiplier;\n        uint32 secs_ = secs;\n        uint32 ago_ = ago;\n        uint256 minPrice_ = minPrice;\n\n        /// -----------------------------------------------------------------------\n        /// Computation\n        /// -----------------------------------------------------------------------\n\n        // query BunniHook to get TWAP value\n        {\n            // get average tick\n            PoolKey memory poolKey = getPoolKey();\n            int24 arithmeticMeanTick = _queryTwap(poolKey, secs_ + ago_, ago_);\n\n            // the unit of the average price is (currency1 / currency0)\n            // if paymentToken is not currency1 of the pool, negate the tick\n            // so that the unit of the average price is (paymentToken / underlyingToken)\n            arithmeticMeanTick = paymentToken == poolKey.currency1 ? arithmeticMeanTick : -arithmeticMeanTick;\n\n            // convert tick to sqrtPriceX96\n            uint256 sqrtPriceX96 = arithmeticMeanTick.getSqrtPriceAtTick();\n\n            // convert sqrtPriceX96 in Q96 (2**96) to price in WAD (1e18)\n            // mulDiv cannot overflow since log2(MAX_SQRT_PRICE * WAD) ~= 219.79 < 256\n            uint256 sqrtPriceWad = sqrtPriceX96.mulDiv(WAD, Q96);\n\n            // compute the price by squaring the sqrtPriceWad\n            // mulWad cannot overflow since log2((MAX_SQRT_PRICE * WAD / Q96)**2) ~= 247.94 < 256\n            price = sqrtPriceWad.mulWad(sqrtPriceWad);\n        }\n\n        // apply multiplier to price\n        price = price.mulDivUp(multiplier_, MULTIPLIER_DENOM);\n\n        // bound price above minPrice\n        price = FixedPointMathLib.max(price, minPrice_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @notice Returns the pool key used to query the BunniHook TWAP oracle.\n    function getPoolKey() public view returns (PoolKey memory) {\n        return abi.decode(poolKeyPointer.read(), (PoolKey));\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Updates the oracle parameters. Only callable by the owner.\n    /// @param multiplier_ The multiplier applied to the TWAP value. Encodes the discount of\n    /// the options token. Uses 4 decimals.\n    /// @param secs_ The size of the window to take the TWAP value over in seconds.\n    /// @param ago_ The number of seconds in the past to take the TWAP from. The window\n    /// would be (block.timestamp - secs - ago, block.timestamp - ago].\n    /// @param minPrice_ The minimum value returned by getPrice(). Maintains a floor for the\n    /// price to mitigate potential attacks on the TWAP oracle.\n    function setParams(uint16 multiplier_, uint32 secs_, uint32 ago_, uint128 minPrice_) external onlyOwner {\n        multiplier = multiplier_;\n        secs = secs_;\n        ago = ago_;\n        minPrice = minPrice_;\n        emit SetParams(multiplier_, secs_, ago_, minPrice_);\n    }\n\n    /// @notice Sets the pool key used to query the BunniHook TWAP oracle.\n    /// Only callable by the owner.\n    /// @param poolKey The new pool key\n    function setPoolKey(PoolKey calldata poolKey) external onlyOwner {\n        // validate pool key\n        if (\n            !(\n                (poolKey.currency0 == paymentToken && poolKey.currency1 == underlyingToken)\n                    || (poolKey.currency0 == underlyingToken && poolKey.currency1 == paymentToken)\n            ) || poolKey.hooks != address(bunniHook)\n        ) {\n            revert BunniHookOracle__InvalidPoolKey();\n        }\n\n        poolKeyPointer = abi.encode(poolKey).write();\n        emit SetPoolKey(poolKey);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the arithmetic mean tick of the TWAP window.\n    /// The TWAP window is defined by (block.timestamp - twapSecondsAgoStart, block.timestamp - twapSecondsAgoEnd].\n    /// The window size is (twapSecondsAgoStart - twapSecondsAgoEnd).\n    /// The unit of the average price is (currency1 / currency0).\n    function _queryTwap(PoolKey memory poolKey, uint32 twapSecondsAgoStart, uint32 twapSecondsAgoEnd)\n        internal\n        view\n        returns (int24 arithmeticMeanTick)\n    {\n        uint32 windowSize = twapSecondsAgoStart - twapSecondsAgoEnd;\n        IBunniHook hook = IBunniHook(address(poolKey.hooks));\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = twapSecondsAgoStart;\n        secondsAgos[1] = twapSecondsAgoEnd;\n        int56[] memory tickCumulatives = hook.observe(poolKey, secondsAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        return int24(tickCumulativesDelta / int56(uint56(windowSize)));\n    }\n}",
    "vulnerable_lines": [14],
    "vulnerable_functions": ["_queryTwap"]
  },
  
  "context_files": [],
  
  "call_flow": "Oracle calls `_queryTwap` -> `tickCumulativesDelta` is negative -> Solidity division rounds up (toward zero) -> Oracle returns an inaccurate tick value (off by 1).",
  "context_hint": "A subtle but common bug in Solidity when dealing with signed integer division. It leads to inaccurate TWAP calculation, which can be exploitable by sophisticated users for marginal gain. The issue is in not implementing the 'round towards negative infinity' standard for tick math.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Essential for accurate price oracles. While the impact of one tick difference is typically low, consistent price inaccuracy breaks guarantees and can be exploited. Severity is Medium for an oracle function."
}