{
  "id": "gs_quantstamp_camp_camp001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp Protocol",
  "source_finding_id": "CAMP-1",
  "report_url": "https://certificate.quantstamp.com/full/camp/ae830654-5f2b-4d21-aba2-1de572092da6/index.html",
  "github_repo_url": "https://github.com/campaign-layer/camp-oft",
  "contest_date": "2025-07-31",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "finding_title": "Missing Check of msg.value in bridgeOut() Function Allows DoS or Stealing Funds",
  "finding_description": "The bridgeOut() function acts as the deposit entrypoint to the OFT bridge. It is supposed to receive native tokens, which are later bridged. The amount of tokens to be bridged is provided by the user with the _originalAmount parameter, however it is never verified against the actual supplied msg.value. This allows users to effectively initiate a bridging operation with debt, which then consumes tokens provided by other depositors. This is particularly exploitable by whitelisted users, who can drain the contract immediately. Other users cannot affect already initiated deposits, and only misuse tokens from those initiated after the malicious one.",
  "attack_scenario": "1. Alice makes a deposit of 10 tokens\n2. Mallory can create a deposit with _originalAmount of 10, without transferring native tokens. If Mallory is whitelisted, this is executed immediately and will consume the 10 tokens supplied by Alice\n3. Bob makes a deposit of 20 tokens. If Mallory wasn't whitelisted, 10 of these tokens will be stolen by Mallory once the unlock period passes. If there are no other deposits, Bob's bridging operation will fail due to insufficient contract balance\n4. Mallory creates a deposit with _originalAmount of 1e77. This can never be repaid, all future deposits are lost, no further bridging operation can occur",
  "fix_description": "Ensure that the original deposit transfer of native tokens includes the incurred fees (see CAMP-2) and the required native tokens by checking against msg.value. The bridgeOut() function must validate that msg.value equals or exceeds the total of _originalAmount plus all bridging fees calculated in _bridgeNativeTokens(). Add a require statement: require(msg.value >= _originalAmount + estimatedFees, 'Insufficient native tokens for bridge').",
  "primary_file": {
    "path": "contracts/CampTimelockEscrowNativeOFT.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract CampTimelockEscrowNativeOFT is OAppCore, ReentrancyGuard {\n    struct Deposit {\n        address to;\n        uint128 amount;\n        uint128 minAmount;\n        uint256 unlockTimestamp;\n    }\n    \n    mapping(address => bool) public whitelist;\n    mapping(uint256 => Deposit) public pending;\n    uint256 public totalDeposits;\n    uint256 public cursor;\n    uint256 public holdPeriod = 1 days;\n    \n    event BridgeOut(address indexed user, uint256 amount, uint256 timestamp);\n    event Released(uint256 indexed depositId, address indexed to, uint256 amount);\n    \n    // VULNERABLE: No msg.value validation against _originalAmount\n    function bridgeOut(address _to, uint128 _gaslimit, uint256 _originalAmount, uint256 _minAmount) \n        external \n        payable \n        nonReentrant \n    {\n        require(_originalAmount > 0, \"Amount must be greater than 0\");\n        require(_to != address(0), \"Invalid recipient\");\n        \n        // VULNERABLE: _originalAmount is accepted without checking msg.value\n        // This allows users to create deposits with debt\n        \n        if (whitelist[msg.sender]) {\n            // Whitelisted users can bridge immediately\n            _bridgeNativeTokens(_to, _originalAmount, _minAmount, _gaslimit);\n        } else {\n            // Non-whitelisted users must wait for unlock period\n            uint256 depositId = totalDeposits;\n            pending[depositId] = Deposit(\n                _to,\n                uint128(_originalAmount),  // Stored without validation\n                uint128(_minAmount),\n                block.timestamp + holdPeriod\n            );\n            totalDeposits++;\n            \n            emit BridgeOut(msg.sender, _originalAmount, block.timestamp);\n        }\n    }\n    \n    // VULNERABLE: Processes deposits sequentially without checking if contract has sufficient balance\n    function batchRelease(uint256 _max, uint128 _gaslimit) external nonReentrant {\n        uint256 processed = 0;\n        \n        while (processed < _max && cursor < totalDeposits) {\n            Deposit memory d = pending[cursor];\n            \n            if (block.timestamp >= d.unlockTimestamp) {\n                delete pending[cursor];\n                \n                // This will fail if sufficient balance isn't available\n                // But the contract doesn't check this beforehand\n                _bridgeNativeTokens(d.to, d.amount, d.minAmount, _gaslimit);\n                \n                emit Released(cursor, d.to, d.amount);\n                processed++;\n            }\n            cursor++;\n        }\n    }\n    \n    function _bridgeNativeTokens(address _to, uint256 _amount, uint256 _minAmount, uint128 _gaslimit) \n        internal \n    {\n        // Bridge logic - would process the native token transfer\n        // If balance is insufficient, this will revert\n    }\n}\n",
    "vulnerable_lines": [38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54],
    "vulnerable_functions": ["bridgeOut"]
  },
  "context_files": [
    {
      "path": "contracts/CampTimelockEscrowNativeOFT.sol",
      "content": "// Additional context showing the queue processing vulnerability\n// When bridgeOut() allows deposits without msg.value validation,\n// batchRelease() tries to bridge amounts that may not exist in contract balance\n\n// If Mallory deposits 1e77 tokens without sending any native tokens,\n// the contract records this huge debt. When batchRelease() tries to process it,\n// the _bridgeNativeTokens() call reverts because contract.balance < 1e77.\n\n// Since there's no error handling and no cursor advancement on revert,\n// all subsequent deposits (including Alice's and Bob's) are permanently blocked.\n\n// The only way to unblock would be to manually send 1e77 native tokens to the contract\n// or have someone with access remove the malicious deposit.\n\n// This demonstrates how CAMP-1 (missing msg.value check) combined with\n// CAMP-4 (no error handling) creates a complete DoS vector.\n",
      "relevance": "Shows how missing msg.value validation in bridgeOut() combined with batch processing creates systemic risk for all deposits"
    }
  ],
  "call_flow": "User.bridgeOut(_originalAmount=10, msg.value=0) → No validation → Deposit created with amount=10 → batchRelease() tries to bridge 10 tokens from empty contract → Reverts and blocks queue → All subsequent deposits stuck",
  "context_hint": "The vulnerability stems from separating the user input (_originalAmount) from the actual token transfer (msg.value). In a properly designed bridge, these must be validated together. The contract assumes the user will honestly provide matching values, but provides no enforcement mechanism. Whitelisted users can exploit this immediately; non-whitelisted users can create debt that permanently blocks the queue.",
  "is_vulnerable": true,
  "expert_notes": "This is a critical authorization and accounting vulnerability. The root cause is an implicit trust in user input without enforcement. The fix requires tight coupling between deposit recording and actual token receipt. Combined with CAMP-2 (fee handling) and CAMP-4 (queue blocking), this creates a multi-layered attack surface where a single malicious deposit can drain honest depositors' funds or permanently break the bridge."
}

{
  "id": "gs_quantstamp_camp_camp002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp Protocol",
  "source_finding_id": "CAMP-2",
  "report_url": "https://certificate.quantstamp.com/full/camp/ae830654-5f2b-4d21-aba2-1de572092da6/index.html",
  "github_repo_url": "https://github.com/campaign-layer/camp-oft",
  "contest_date": "2025-07-31",
  "severity": "high",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "finding_title": "User Deposit May Not Cover Bridging Fees",
  "finding_description": "The send() operation incurs additional fees exceeding the _originalAmount recorded during the initial deposit using the bridgeOut() function. This total value is calculated in the _bridgeNativeTokens() function, and then paid from the contract balance. However, there is no validation that this fee is paid during the initial deposit. In its current form, the contract may run out of funds while still having unprocessed queued deposits.",
  "attack_scenario": "1. Alice calls bridgeOut() with _originalAmount=1000 tokens, paying msg.value=1000\n2. Contract records deposit of 1000 tokens\n3. After holdPeriod, keeper calls batchRelease() to process Alice's deposit\n4. _bridgeNativeTokens() calculates total fees needed: 1000 (principal) + 50 (LayerZero fee) = 1050\n5. Contract tries to pay 1050 but only has exactly 1000 (no fee buffer)\n6. Transaction reverts, blocking Alice's withdrawal and all subsequent deposits\n7. Contract is permanently stuck unless someone deposits additional fees",
  "fix_description": "Ensure that the original deposit transfer of native tokens includes the incurred fees and the required native tokens by checking against msg.value at deposit time. In bridgeOut(), calculate expected fees upfront and validate: require(msg.value >= _originalAmount + expectedFees, 'Insufficient value for bridge'). Fees should be calculated by calling _estimateFees() with the same parameters that will be used in _bridgeNativeTokens(). Alternatively, collect fees in a separate step: require(msg.value == _originalAmount, 'Value must match amount') and then have a separate fee collection mechanism.",
  "primary_file": {
    "path": "contracts/CampTimelockEscrowNativeOFT.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\";\n\ncontract CampTimelockEscrowNativeOFT is OAppCore {\n    struct Deposit {\n        address to;\n        uint256 amount;\n        uint256 minAmount;\n        uint256 unlockTimestamp;\n    }\n    \n    mapping(uint256 => Deposit) public pending;\n    uint256 public totalDeposits;\n    uint256 public cursor;\n    \n    // VULNERABLE: Records only _originalAmount, ignores fees\n    function bridgeOut(address _to, uint128 _gaslimit, uint256 _originalAmount, uint256 _minAmount) \n        external \n        payable \n    {\n        require(_originalAmount > 0, \"Amount must be greater than 0\");\n        \n        // VULNERABLE: Accepts msg.value equal to _originalAmount\n        // But doesn't account for fees that will be needed during bridging\n        require(msg.value == _originalAmount, \"Value must match amount\");\n        \n        uint256 depositId = totalDeposits;\n        pending[depositId] = Deposit(\n            _to,\n            _originalAmount,  // Only records principal, not fees\n            _minAmount,\n            block.timestamp + 1 days\n        );\n        totalDeposits++;\n    }\n    \n    // VULNERABLE: Tries to bridge but fees not accounted for\n    function batchRelease(uint256 _max, uint128 _gaslimit) external {\n        while (cursor < totalDeposits && _max > 0) {\n            Deposit memory d = pending[cursor];\n            \n            if (block.timestamp >= d.unlockTimestamp) {\n                delete pending[cursor];\n                \n                // This function calculates and pays fees that weren't collected at deposit time\n                _bridgeNativeTokens(d.to, d.amount, d.minAmount, _gaslimit);\n                _max--;\n            }\n            cursor++;\n        }\n    }\n    \n    // VULNERABLE: Deducts fees from contract balance\n    // If balance insufficient, entire transaction reverts\n    function _bridgeNativeTokens(\n        address _to, \n        uint256 _amount, \n        uint256 _minAmount, \n        uint128 _gaslimit\n    ) internal {\n        // Calculate LayerZero fees\n        (uint256 nativeFee, uint256 zroFee) = _quote(\n            _GasLimitPair({gasLimit: _gaslimit, msgType: MSG_TYPE_COMPOSE_FROM_EVM}),\n            _encodePayload(_to, _amount, _minAmount),\n            false\n        );\n        \n        uint256 totalCost = _amount + nativeFee;  // Total needed\n        \n        // VULNERABLE: If contract balance < totalCost, this reverts\n        // Contract balance = sum of all msg.value received\n        // If any deposit came without fee buffer, entire batch fails\n        \n        require(address(this).balance >= totalCost, \"Insufficient contract balance\");\n        \n        _send(\n            _to,\n            _amount,\n            _minAmount,\n            _gaslimit,\n            nativeFee\n        );\n    }\n    \n    function _quote(GasLimitPair memory _gasLimitPair, bytes memory _payload, bool _payInZro)\n        internal\n        view\n        returns (uint256, uint256)\n    {\n        // Query LayerZero for actual fee\n        // This is dynamic and changes based on network conditions\n        return (50, 0);  // Simplified for example\n    }\n}\n",
    "vulnerable_lines": [24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 57, 58, 59, 60, 61, 62, 63],
    "vulnerable_functions": ["bridgeOut", "_bridgeNativeTokens"]
  },
  "context_files": [
    {
      "path": "contracts/CampTimelockEscrowNativeOFT.sol",
      "content": "// Root cause analysis:\n// bridgeOut() is responsible for collecting user deposits\n// _bridgeNativeTokens() is responsible for executing the actual bridge\n// \n// The bug: These two functions have different accounting models\n// \n// bridgeOut() logic:\n// - Accepts msg.value as full amount needed\n// - Records deposit as _originalAmount\n// - No fee consideration\n// \n// _bridgeNativeTokens() logic:\n// - Queries LayerZero for actual fees needed\n// - Attempts to pay: _amount + nativeFee\n// - Reverts if insufficient balance\n// \n// Example scenario:\n// 1. Alice deposits 1000 ETH, pays msg.value=1000\n// 2. Bob deposits 1000 ETH, pays msg.value=1000\n// 3. Contract balance = 2000 ETH\n// 4. Alice's deposit queued to bridge\n// 5. _bridgeNativeTokens(alice, 1000, minAmount, gaslimit) called\n// 6. LayerZero quotes fee = 2 ETH\n// 7. Required: 1000 + 2 = 1002 ETH\n// 8. Available: 2000 ETH from all deposits\n// 9. First deposit: 1002 paid, remaining = 998\n// 10. Second deposit: 1000 + 2 = 1002, but only 998 available\n// 11. Transaction reverts, cursor not advanced\n// 12. Bob's deposit permanently blocked\n//\n// The fix: Collect fees upfront in bridgeOut()\n// require(msg.value == _originalAmount + fee, 'Insufficient for bridge')\n",
      "relevance": "Explains the mismatch between deposit collection and fee requirements that causes accounting failure"
    }
  ],
  "call_flow": "User.bridgeOut(amount, msg.value=amount) → Deposit recorded with only principal → batchRelease() → _bridgeNativeTokens() → Calculate fees → totalNeeded = principal + fee → Contract.balance insufficient → Revert → Queue blocked",
  "context_hint": "This vulnerability combines accounting separation with dynamic pricing. The bridge correctly calculates fees dynamically (proper design), but the escrow mechanism doesn't reserve space for these fees at deposit time. The fix requires either: (1) collect fees upfront by querying LayerZero during deposit, or (2) implement a fee buffer mechanism that holds back a percentage of each deposit, or (3) implement error recovery in batchRelease() with try/catch to skip failed deposits.",
  "is_vulnerable": true,
  "expert_notes": "This is a rare but critical bug in bridge design. Many bridges calculate fees dynamically (correct) but forget to enforce fee payment at deposit collection time (incorrect). The issue becomes worse with volatile gas prices: if fees increase between deposit and withdrawal, the mechanism breaks. The fix is to query fees during bridgeOut() and include them in the msg.value requirement, making the contract's accounting model tight and failure-proof."
}

{
  "id": "gs_quantstamp_camp_camp003",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp Protocol",
  "source_finding_id": "CAMP-3",
  "report_url": "https://certificate.quantstamp.com/full/camp/ae830654-5f2b-4d21-aba2-1de572092da6/index.html",
  "github_repo_url": "https://github.com/campaign-layer/staking-vault",
  "contest_date": "2025-07-31",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "finding_title": "unstakeDelay Can Be Exploited to DoS Withdraws",
  "finding_description": "This fork of the Synthetix StakingRewards contract introduces an unstakeDelay variable that is intended to enforce a minimum duration between stake and withdraw operations. For this purpose the contract records the last deposit timestamp for each user. However, the stake() function can be executed by a delegator, and does not require a minimum deposit. This way a user can stake a small amount on behalf of another user before their unstakeDelay passes, extending the lock and thus blocking them from withdrawing their tokens.",
  "attack_scenario": "1. Alice stakes 10 CAMP tokens at time T\n2. unstakeDelay = 30 days, so Alice can withdraw at T+30\n3. At time T+29 days (just before unstakeDelay expires), Mallory calls stake(1 wei, alice)\n4. Since stake() has no minimum amount check, this succeeds\n5. Alice's lastStakeTime is updated to T+29\n6. Now Alice can withdraw at T+29+30 = T+59 (extended by 30 days)\n7. Mallory repeats this every 29 days, permanently blocking Alice's withdrawal\n8. Alice's tokens become effectively locked forever with minimal cost to attacker",
  "fix_description": "Implement per-deposit tracking instead of global user timestamp. Instead of tracking lastStakeTime per user, track it per deposit using a separate data structure. Each deposit gets its own unlock timestamp that is immutable. Alternatively, add minimum stake amount check to prevent dust deposits: require(_amount >= MIN_STAKE_AMOUNT, 'Stake too small'). Set MIN_STAKE_AMOUNT to a value that makes the griefing attack economically infeasible (e.g., 0.1% of median deposit). Or remove the delegated stake() function entirely if not core to protocol design.",
  "primary_file": {
    "path": "src/CampStakingVault.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract CampStakingVault {\n    struct UserInfo {\n        uint256 principal;\n        uint256 lastStakeTime;  // VULNERABLE: Single timestamp per user\n    }\n    \n    mapping(address => UserInfo) public users;\n    uint256 public unstakeDelay = 30 days;\n    \n    event Staked(address indexed user, address indexed staker, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    \n    // VULNERABLE: Can be called by relayer on behalf of any user\n    // No minimum amount check\n    function stake(uint256 _amount, address _for) external {\n        require(_amount > 0, \"Amount must be greater than 0\");  // Allows 1 wei!\n        // VULNERABLE: No minimum stake requirement\n        \n        // Transfer tokens\n        CAMP.transferFrom(msg.sender, address(this), _amount);\n        \n        // Update user info\n        users[_for].principal += _amount;\n        users[_for].lastStakeTime = block.timestamp;  // VULNERABLE: Updates global timestamp\n        \n        emit Staked(_for, msg.sender, _amount);\n    }\n    \n    // VULNERABLE: Checks single lastStakeTime for all deposits\n    function withdraw(uint256 _amount) external {\n        UserInfo storage user = users[msg.sender];\n        \n        require(user.principal >= _amount, \"Insufficient balance\");\n        \n        // VULNERABLE: Single time lock applies to all principal\n        // If lastStakeTime was updated by anyone (even delegator), all withdrawals blocked\n        require(\n            block.timestamp >= user.lastStakeTime + unstakeDelay,\n            \"Unstake delay not met\"\n        );\n        \n        user.principal -= _amount;\n        CAMP.transfer(msg.sender, _amount);\n        \n        emit Withdrawn(msg.sender, _amount);\n    }\n    \n    // VULNERABLE: Direct path for attacker to grief\n    function relayerStake(address[] calldata _users, uint256[] calldata _amounts) \n        external \n    {\n        require(msg.sender == relayerProxy, \"Only relayer\");\n        \n        for (uint256 i = 0; i < _users.length; i++) {\n            // Allows staking dust amounts on behalf of any user\n            stake(_amounts[i], _users[i]);  // Calls vulnerable stake()\n        }\n    }\n}\n",
    "vulnerable_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37],
    "vulnerable_functions": ["stake", "withdraw", "relayerStake"]
  },
  "context_files": [
    {
      "path": "src/CampStakingVault.sol",
      "content": "// Fixed implementation using per-deposit tracking:\n// \n// struct Deposit {\n//     uint256 amount;\n//     uint256 unlockTime;\n// }\n// \n// mapping(address => Deposit[]) public deposits;\n// \n// function stake(uint256 _amount, address _for) external {\n//     require(_amount >= MIN_STAKE, \"Below minimum\");\n//     deposits[_for].push(Deposit({\n//         amount: _amount,\n//         unlockTime: block.timestamp + unstakeDelay\n//     }));\n// }\n// \n// function withdraw(uint256 _amount) external {\n//     uint256 available = 0;\n//     uint256 remaining = _amount;\n//     \n//     for (uint i = 0; i < deposits[msg.sender].length; i++) {\n//         if (block.timestamp >= deposits[msg.sender][i].unlockTime) {\n//             // This deposit is unlocked\n//             uint256 take = min(remaining, deposits[msg.sender][i].amount);\n//             available += take;\n//             remaining -= take;\n//         }\n//     }\n//     require(available >= _amount, \"Insufficient unlocked balance\");\n// }\n// \n// This prevents any single deposit from blocking all withdrawals\n",
      "relevance": "Shows how per-deposit tracking prevents the griefing attack that single-timestamp design enables"
    }
  ],
  "call_flow": "Alice.stake(10, alice) @ T → lastStakeTime=T → Unlock at T+30 → Mallory.stake(1 wei, alice) @ T+29 → lastStakeTime=T+29 → Unlock at T+59 → Alice blocked for 30 more days → Repeat indefinitely",
  "context_hint": "The vulnerability stems from a design where a single timestamp controls access to all principal, combined with a delegated stake function that has no minimum amount. The attacker's economic cost is minimal (1 wei) while the victim's cost is time-based grief. This is a classic griefing vector in governance/staking systems. The fix requires separating concerns: each stake operation should have its own independent unlock time.",
  "is_vulnerable": true,
  "expert_notes": "This is a subtle but critical vulnerability in time-locked staking systems. The root cause is the confusion between two concepts: (1) when did a user start staking (for calculating rewards), and (2) when can a user withdraw specific deposits (for enforcing lock-up periods). The contract conflated these into a single lastStakeTime, which created the griefing vector. Per-deposit tracking properly separates these concerns and eliminates the attack surface."
}

{
  "id": "gs_quantstamp_camp_camp004",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp Protocol",
  "source_finding_id": "CAMP-4",
  "report_url": "https://certificate.quantstamp.com/full/camp/ae830654-5f2b-4d21-aba2-1de572092da6/index.html",
  "github_repo_url": "https://github.com/campaign-layer/camp-oft",
  "contest_date": "2025-07-31",
  "severity": "high",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "finding_title": "Malicious Deposit with Dust-Sensitive minAmount Can Cause Denial of Service on batchRelease() Function",
  "finding_description": "The batchRelease() function processes deposits sequentially in a loop. When processing each deposit, it calls _bridgeNativeTokens(), which internally triggers LayerZero's dust removal mechanism via _removeDust(). This function rounds down the amount by removing decimal precision dust to ensure compatibility across chains with different token decimals. A malicious user can exploit this mechanism by setting a _minAmount parameter that becomes incompatible with the dust-adjusted amount. The LayerZero OFTCore contract performs a slippage check that reverts if the dust-adjusted amount falls below the user-specified _minAmount.",
  "attack_scenario": "1. Alice (legitimate) calls bridgeOut() with 10 ETH, creating a deposit\n2. Bob (attacker) analyzes dust removal rate and calls bridgeOut() with: _originalAmount=1.0000123 ETH, _minAmount=1.0000120 ETH\n3. Bob's deposit is queued after Alice's\n4. holdPeriod expires, keeper calls batchRelease() to process matured deposits\n5. Alice's deposit processes successfully\n6. When processing Bob's deposit, _removeDust() rounds 1.0000123 ETH down to 1.0000100 ETH\n7. Slippage check: 1.0000100 < 1.0000120 triggers SlippageExceeded revert\n8. Entire batchRelease() transaction reverts without advancing cursor\n9. All future calls to batchRelease() fail on the same deposit\n10. All deposits after Bob in queue are permanently blocked",
  "fix_description": "Add validation in bridgeOut() to ensure _minAmount is compatible with the dust-adjusted amount before queuing the deposit. Query the dust removal calculation upfront: uint256 dustAdjustedAmount = _removeDust(_originalAmount). Then validate: require(_minAmount <= dustAdjustedAmount, 'minAmount exceeds dust-adjusted amount'). Alternatively, implement try/catch error handling in batchRelease() to skip failed deposits and continue processing: try { _bridgeNativeTokens(...); } catch { skip and emit event; }. The first approach (validation) is simpler and prevents the bad state from ever being created.",
  "primary_file": {
    "path": "contracts/CampTimelockEscrowNativeOFT.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\";\n\ncontract CampTimelockEscrowNativeOFT is OAppCore {\n    struct Deposit {\n        address to;\n        uint128 amount;\n        uint128 minAmount;\n        uint256 unlockTimestamp;\n    }\n    \n    mapping(uint256 => Deposit) public pending;\n    uint256 public totalDeposits;\n    uint256 public cursor;\n    \n    uint256 constant DUST_THRESHOLD = 1e6;  // LayerZero dust removal parameter\n    \n    // VULNERABLE: No validation of minAmount against dust-adjusted amount\n    function bridgeOut(\n        address _to,\n        uint128 _gaslimit,\n        uint256 _originalAmount,\n        uint256 _minAmount\n    ) external payable {\n        require(_originalAmount > 0, \"Amount must be greater than 0\");\n        require(_to != address(0), \"Invalid recipient\");\n        \n        // VULNERABLE: Accepts minAmount without checking compatibility with dust removal\n        // User can set minAmount > _removeDust(_originalAmount)\n        // This will cause batchRelease() to fail when processing this deposit\n        \n        uint256 depositId = totalDeposits;\n        pending[depositId] = Deposit(\n            _to,\n            uint128(_originalAmount),\n            uint128(_minAmount),  // VULNERABLE: No validation\n            block.timestamp + 1 days\n        );\n        totalDeposits++;\n    }\n    \n    // VULNERABLE: Sequential processing with no error handling\n    // One bad deposit blocks entire queue\n    function batchRelease(uint256 _max, uint128 _gaslimit) external {\n        uint256 processed = 0;\n        \n        while (processed < _max && cursor < totalDeposits) {\n            Deposit memory d = pending[cursor];\n            \n            if (block.timestamp >= d.unlockTimestamp) {\n                delete pending[cursor];\n                \n                // VULNERABLE: If this reverts, cursor not advanced, queue permanently blocked\n                _bridgeNativeTokens(d.to, d.amount, d.minAmount, _gaslimit);\n                \n                processed++;\n            }\n            cursor++;\n        }\n    }\n    \n    function _bridgeNativeTokens(\n        address _to,\n        uint256 _amount,\n        uint256 _minAmount,\n        uint128 _gaslimit\n    ) internal {\n        // LayerZero will call _removeDust on _amount\n        uint256 dustAdjustedAmount = _removeDust(_amount);\n        \n        // LayerZero performs slippage check\n        // If dustAdjustedAmount < _minAmount, this reverts\n        require(\n            dustAdjustedAmount >= _minAmount,\n            \"SlippageExceeded\"\n        );\n        \n        // Proceed with bridge\n        // ...\n    }\n    \n    function _removeDust(uint256 _amount) internal pure returns (uint256) {\n        // Simplified dust removal logic\n        // Actual LayerZero implementation more complex\n        return (_amount / DUST_THRESHOLD) * DUST_THRESHOLD;\n    }\n}\n",
    "vulnerable_lines": [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58],
    "vulnerable_functions": ["bridgeOut", "batchRelease"]
  },
  "context_files": [
    {
      "path": "contracts/CampTimelockEscrowNativeOFT.sol",
      "content": "// Fixed implementation:\n//\n// function bridgeOut(\n//     address _to,\n//     uint128 _gaslimit,\n//     uint256 _originalAmount,\n//     uint256 _minAmount\n// ) external payable {\n//     require(_originalAmount > 0, \"Amount must be greater than 0\");\n//     require(_to != address(0), \"Invalid recipient\");\n//     \n//     // FIX: Validate minAmount is compatible with dust removal\n//     uint256 dustAdjustedAmount = _removeDust(_originalAmount);\n//     require(\n//         _minAmount <= dustAdjustedAmount,\n//         \"minAmount exceeds dust-adjusted amount\"\n//     );\n//     \n//     // Now safe to queue\n//     uint256 depositId = totalDeposits;\n//     pending[depositId] = Deposit(\n//         _to,\n//         uint128(_originalAmount),\n//         uint128(_minAmount),\n//         block.timestamp + 1 days\n//     );\n//     totalDeposits++;\n// }\n//\n// Alternative fix with error recovery:\n//\n// function batchRelease(uint256 _max, uint128 _gaslimit) external {\n//     while (processed < _max && cursor < totalDeposits) {\n//         Deposit memory d = pending[cursor];\n//         if (block.timestamp >= d.unlockTimestamp) {\n//             delete pending[cursor];\n//             try {\n//                 _bridgeNativeTokens(d.to, d.amount, d.minAmount, _gaslimit);\n//             } catch {\n//                 // Skip failed deposit, emit event, continue\n//                 emit FailedBridge(cursor);\n//             }\n//             processed++;\n//         }\n//         cursor++;\n//     }\n// }\n",
      "relevance": "Shows both the validation fix (preferred) and the error recovery approach (backup safety mechanism)"
    }
  ],
  "call_flow": "Attacker.bridgeOut(amount=1.000012, minAmount=1.000012) → Deposit queued → batchRelease() → _removeDust() rounds down to 1.000010 → Slippage check 1.000010 < 1.000012 fails → Revert without cursor increment → batchRelease() permanently blocked on this deposit",
  "context_hint": "This is a sophisticated attack on batch processing systems combined with cross-chain bridges. The attacker exploits the interaction between three mechanisms: (1) sequential queue processing, (2) dust removal rounding, and (3) slippage validation. The poison pill works because the queue cursor doesn't advance on revert. The attack surface exists because deposit validation doesn't simulate the future bridging process.",
  "is_vulnerable": true,
  "expert_notes": "This vulnerability demonstrates why bridge systems need tight integration between deposit validation and execution logic. The dust removal mechanism is necessary for cross-chain compatibility (different chains have different decimal precisions), but the escrow mechanism must validate deposits against post-dust amounts. This is a lesson in defense-in-depth: validation at deposit time (primary fix) combined with error recovery at execution time (secondary fix) creates a robust system."
}

{
  "id": "gs_quantstamp_camp_camp005",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp Protocol",
  "source_finding_id": "CAMP-5",
  "report_url": "https://certificate.quantstamp.com/full/camp/ae830654-5f2b-4d21-aba2-1de572092da6/index.html",
  "github_repo_url": "https://github.com/campaign-layer/camp-oft",
  "contest_date": "2025-07-31",
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "Small Deposits Can Increase Cost of batchRelease() Function",
  "finding_description": "The escrow bridge relies on a queue to manage deposits. All new deposits are appended to the queue and share the same holdPeriod before the bridging operation can commence. The queue is consumed using the batchRelease() function, which increments a global cursor indicating the cutoff index of processed deposits. For each batch, some maximum number of entries is checked, bridging deposits where the unlockTimestamp has passed. No deposits in the queue can be skipped, and the bridgeOut() function is likely substantially cheaper in gas than the send() function and does not enforce a minimum deposit. Therefore, small deposits could be used to extend the size of the queue substantially, requiring someone to pay the gas cost of initiating all those bridging transactions using the batchRelease() function before any deposits later in the queue can be executed.",
  "attack_scenario": "1. Mallory creates 1000 small deposits of 1 wei each, total cost ~1000 wei\n2. Alice creates a legitimate deposit of 1000 ETH\n3. After holdPeriod, keeper needs to call batchRelease() to process deposits\n4. To reach Alice's deposit, keeper must process all 1000 of Mallory's deposits first\n5. Each batchRelease() call processes up to N deposits (e.g., N=10)\n6. Keeper must call batchRelease() 100 times to process Mallory's 1000 deposits\n7. Each call costs gas for: loop iteration, storage access, external call to _bridgeNativeTokens()\n8. Total cost for keeper: 100 calls × 150k gas/call = 15M gas\n9. At 100 gwei, that's 1.5 ETH just to process Mallory's dust\n10. Alice's legitimate 1000 ETH deposit is delayed by keeper's gas costs\n11. Mallory attacked with <$0.01, cost keeper >$5000 in gas",
  "fix_description": "Add minimum deposit amount enforcement in bridgeOut(): require(_originalAmount >= MIN_DEPOSIT_AMOUNT, 'Below minimum deposit'). Set MIN_DEPOSIT_AMOUNT to a value that makes the attack economically infeasible. For example, if MIN_DEPOSIT_AMOUNT = 0.1 ETH, then Mallory needs to spend at least 100 ETH to create 1000 deposits, making the attack prohibitively expensive. Alternatively, implement indexed access to batchRelease(): batchRelease(uint256[] calldata _indices) allowing the keeper to process specific queue positions instead of sequential ones. This shifts queue management to off-chain logic where the keeper can skip dust deposits entirely.",
  "primary_file": {
    "path": "contracts/CampTimelockEscrowNativeOFT.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract CampTimelockEscrowNativeOFT {\n    struct Deposit {\n        address to;\n        uint256 amount;\n        uint256 unlockTimestamp;\n    }\n    \n    mapping(uint256 => Deposit) public pending;\n    uint256 public totalDeposits;\n    uint256 public cursor;\n    \n    // VULNERABLE: No minimum deposit amount enforced\n    function bridgeOut(\n        address _to,\n        uint128 _gaslimit,\n        uint256 _originalAmount,\n        uint256 _minAmount\n    ) external payable {\n        require(_originalAmount > 0, \"Amount must be greater than 0\");  // Allows 1 wei!\n        // VULNERABLE: No minimum amount\n        require(msg.value == _originalAmount, \"Value mismatch\");\n        \n        uint256 depositId = totalDeposits;\n        pending[depositId] = Deposit(\n            _to,\n            _originalAmount,  // Can be 1 wei\n            block.timestamp + 1 days\n        );\n        totalDeposits++;\n    }\n    \n    // VULNERABLE: Sequential processing, cannot skip dust deposits\n    function batchRelease(uint256 _max, uint128 _gaslimit) external {\n        uint256 processed = 0;\n        \n        // Must iterate sequentially from cursor\n        // Cannot skip entries\n        while (processed < _max && cursor < totalDeposits) {\n            Deposit memory d = pending[cursor];\n            \n            if (block.timestamp >= d.unlockTimestamp) {\n                delete pending[cursor];\n                \n                // Every deposit requires a full external call, regardless of size\n                // 1 wei deposit costs ~150k gas same as 1000 ETH deposit\n                _bridgeNativeTokens(d.to, d.amount, _gaslimit);\n                \n                processed++;\n            }\n            cursor++;\n        }\n    }\n    \n    function _bridgeNativeTokens(\n        address _to,\n        uint256 _amount,\n        uint128 _gaslimit\n    ) internal {\n        // Expensive operation: LayerZero call\n        // Cost independent of _amount\n        // Gas: ~150k per call\n    }\n}\n",
    "vulnerable_lines": [18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37],
    "vulnerable_functions": ["bridgeOut", "batchRelease"]
  },
  "context_files": [
    {
      "path": "contracts/CampTimelockEscrowNativeOFT.sol",
      "content": "// Fixed implementation with minimum deposit:\n//\n// uint256 constant MIN_DEPOSIT = 0.1 ether;  // Prevents dust griefing\n//\n// function bridgeOut(\n//     address _to,\n//     uint128 _gaslimit,\n//     uint256 _originalAmount,\n//     uint256 _minAmount\n// ) external payable {\n//     require(_originalAmount >= MIN_DEPOSIT, \"Below minimum deposit\");\n//     require(_to != address(0), \"Invalid recipient\");\n//     require(msg.value == _originalAmount, \"Value mismatch\");\n//     \n//     uint256 depositId = totalDeposits;\n//     pending[depositId] = Deposit(\n//         _to,\n//         _originalAmount,\n//         block.timestamp + 1 days\n//     );\n//     totalDeposits++;\n// }\n//\n// Alternative: Indexed batch release\n//\n// function batchRelease(uint256[] calldata _indices, uint128 _gaslimit) external {\n//     // Keeper can select which deposits to process\n//     // Off-chain logic filters mature deposits > MIN_DEPOSIT\n//     // Keeper can skip dust entirely\n//     for (uint256 i = 0; i < _indices.length; i++) {\n//         uint256 depositId = _indices[i];\n//         Deposit memory d = pending[depositId];\n//         require(block.timestamp >= d.unlockTimestamp, \"Not unlocked\");\n//         delete pending[depositId];\n//         _bridgeNativeTokens(d.to, d.amount, _gaslimit);\n//     }\n// }\n//\n// The indexed approach is more complex but gives keepers full control\n// The minimum deposit approach is simpler and effectively prevents the attack\n",
      "relevance": "Shows both approaches: simple minimum deposit (recommended) and complex indexed processing (advanced)"
    }
  ],
  "call_flow": "Attacker.bridgeOut(1 wei) → 1000 times → Queue length = 1000 → Legitimate deposit created → holdPeriod expires → Keeper.batchRelease(10) → Processes 10 dust deposits → Repeats 100 times → Finally reaches legitimate deposit → Keeper pays massive gas for dust",
  "context_hint": "This is a classic griefing attack on batch processing systems. The core issue is that bridgeOut() cost (cheap: no external calls) is decoupled from batchRelease() cost (expensive: LayerZero calls). An attacker can create unlimited entries in the queue at minimal cost, forcing the honest keeper to pay for processing them. The fix requires either: (1) raising the cost of creating queue entries (minimum deposit), or (2) allowing selective processing (indexed batch release).",
  "is_vulnerable": true,
  "expert_notes": "This vulnerability represents a classic economic attack on permissionless queuing systems. The root cause is the linear relationship between queue size and batching cost, combined with no barrier to entry for creating queue entries. The minimum deposit approach (recommended) is simpler and more gas-efficient. The indexed approach is more powerful but introduces keeper infrastructure overhead. For this specific system, MIN_DEPOSIT = 0.1 ETH would make the 1000-deposit attack cost 100 ETH, making it economically rational to just use the bridge legitimately."
}
