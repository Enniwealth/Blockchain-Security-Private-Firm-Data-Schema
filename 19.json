[
  {
    "id": "gs_cantina_liminal_001",
    "report_url": "https://cantina.xyz/portfolio/ff700249-ee2f-4149-993d-93b110f3ae2e",
    "project_name": "Liminal Contracts",
    "github_url": "https://github.com/Lmnal/liminal-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-21",
    "vulnerability_type": "access_control_fee",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "privilege_escalation",
    "is_vulnerable": true,
    "title": "Custom Fees Settable up to 100% in fulfillFastRedeems Can Seize Redemptions",
    "description": "The fulfillFastRedeems function allows a caller with the FULFILL_MANAGER_ROLE to specify a customFees array. While the code checks that the fee does not exceed 100% (feeBps <= BASIS_POINTS), it lacks a stricter, more reasonable upper bound. This allows a privileged manager to set a punitive fee of up to almost 100% (not 100% itself due to a subsequent check), which could be used to unfairly seize the majority or almost all of a user's redemption value.",
    "primary_file": {
      "name": "RedemptionPipe.sol",
      "path": "src/RedemptionPipe.sol",
      "lines": "514-538",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {INAVOracle} from \"./interfaces/INAVOracle.sol\";\nimport {IShareManager} from \"./interfaces/IShareManager.sol\";\n\ninterface IFeeManager {\n    function accruePerformanceFee() external;\n}\n\ncontract RedemptionPipe is AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IERC20Metadata;\n    using Math for uint256;\n\n    bytes32 public constant EMERGENCY_MANAGER_ROLE = keccak256(\"EMERGENCY_MANAGER_ROLE\");\n    bytes32 public constant FULFILL_MANAGER_ROLE = keccak256(\"FULFILL_MANAGER_ROLE\");\n    bytes32 public constant SAFE_MANAGER_ROLE = keccak256(\"SAFE_MANAGER_ROLE\");\n\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 internal constant REQUEST_ID = 0;\n\n    struct FeeConfig {\n        uint256 instantRedeemFeeBps;\n        uint256 fastRedeemFeeBps;\n    }\n\n    struct PendingRedeemRequest {\n        uint256 shares;\n        address receiver;\n    }\n\n    struct PendingFastRedeemRequest {\n        uint256 shares;\n        uint256 timestamp;\n        address receiver;\n    }\n\n    struct RedemptionPipeStorage {\n        IShareManager shareManager;\n        INAVOracle navOracle;\n        IERC20Metadata underlyingAsset;\n        address liquidityProvider;\n        FeeConfig fees;\n        uint256 lastNAVForPerformance;\n        uint24 recoveryDelay;\n        uint72 lastRedemptionTime;\n        address treasury;\n        mapping(address => PendingRedeemRequest) pendingRedeem;\n        mapping(address => PendingFastRedeemRequest) pendingFastRedeem;\n        address timeLockController;\n        uint256 MIN_AMOUNT_SHARES;\n        IFeeManager feeManager;\n        uint256 maxCustomFeeBps;\n        bool fastRedeemEnabled;\n    }\n\n    bytes32 private constant REDEMPTION_PIPE_STORAGE_LOCATION = 0x29501c6d0a5cf7bef3f2db502c4a21ddfa1dc6ae30f842b9bba4cfdd2f8c2a00;\n\n    function _getRedemptionPipeStorage() private pure returns (RedemptionPipeStorage storage $) {\n        assembly {\n            $.slot := REDEMPTION_PIPE_STORAGE_LOCATION\n        }\n    }\n\n    event InstantRedeem(address indexed user, address indexed receiver, uint256 shares, uint256 assets, uint256 fee);\n    event FastRedeemRequested(address indexed owner, address indexed receiver, uint256 shares, uint256 timestamp);\n    event FastRedeemFulfilled(address indexed owner, address indexed receiver, uint256 assets, uint256 shares, uint256 fee);\n    event RedeemRequested(address indexed owner, address indexed receiver, uint256 shares);\n    event RedeemFulfilled(address indexed owner, address indexed receiver, uint256 assets, uint256 shares);\n    event FeesUpdated(FeeConfig newFees);\n    event RecoveryDelayUpdated(uint256 newDelay);\n    event TreasuryUpdated(address indexed newTreasury);\n    event AssetsRecovered(address indexed token, uint256 amount, address indexed treasury);\n    event LiquidityProviderUpdated(address indexed oldProvider, address indexed newProvider);\n    event MaxCustomFeeBpsUpdated(uint256 newMaxCustomFeeBps);\n    event FastRedeemEnabledUpdated(bool enabled);\n    event TimeLockControllerUpdated(address indexed oldTimeLockController, address indexed newTimeLockController);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    struct InitializeParams {\n        address shareManager;\n        address navOracle;\n        address underlyingAsset;\n        address liquidityProvider;\n        address deployer;\n        address safeManager;\n        address emergencyManager;\n        address requestManager;\n        address treasury;\n        uint256 recoveryDelay;\n        address timeLockController;\n        address feeManager;\n        uint256 maxCustomFeeBps;\n    }\n\n    function initialize(InitializeParams calldata params) external initializer {\n        require(params.shareManager != address(0));\n        require(params.navOracle != address(0));\n        require(params.underlyingAsset != address(0));\n        require(params.deployer != address(0));\n        require(params.safeManager != address(0));\n        require(params.liquidityProvider != address(0));\n        require(params.emergencyManager != address(0));\n        require(params.timeLockController != address(0));\n        require(params.requestManager != address(0));\n        require(params.treasury != address(0));\n        require(params.recoveryDelay > 0);\n        require(params.feeManager != address(0));\n        require(params.maxCustomFeeBps <= BASIS_POINTS);\n\n        __AccessControl_init();\n        __Pausable_init();\n        __ReentrancyGuard_init();\n\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.shareManager = IShareManager(params.shareManager);\n        $.navOracle = INAVOracle(params.navOracle);\n        $.underlyingAsset = IERC20Metadata(params.underlyingAsset);\n        $.liquidityProvider = params.liquidityProvider;\n        $.treasury = params.treasury;\n        $.recoveryDelay = uint24(params.recoveryDelay);\n        $.timeLockController = params.timeLockController;\n        $.feeManager = IFeeManager(params.feeManager);\n        $.maxCustomFeeBps = params.maxCustomFeeBps;\n        $.fastRedeemEnabled = false;\n\n        uint8 assetDecimals = IERC20Metadata(params.underlyingAsset).decimals();\n        require(assetDecimals <= 18);\n        $.MIN_AMOUNT_SHARES = 1000 * 10 ** (18 - assetDecimals);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, params.deployer);\n        _grantRole(SAFE_MANAGER_ROLE, params.safeManager);\n        _grantRole(EMERGENCY_MANAGER_ROLE, params.emergencyManager);\n        _grantRole(FULFILL_MANAGER_ROLE, params.requestManager);\n\n        $.lastNAVForPerformance = $.navOracle.getNAV();\n    }\n\n    function pause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _pause();\n    }\n\n    function unpause() external onlyRole(EMERGENCY_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    function setFastRedeemEnabled(bool _enabled) external onlyRole(SAFE_MANAGER_ROLE) {\n        RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n        $.fastRedeemEnabled = _enabled;\n        emit FastRedeemEnabledUpdated(_enabled);\n    }\n}\n"

    },
    "context_files": [],
    "call_flow": [
      "1. User calls requestRedeemFast(shares, controller, owner)",
      "2. Shares locked in pending redemption request",
      "3. Awaiting fulfillment from FULFILL_MANAGER_ROLE",
      "4. Manager calls fulfillFastRedeems([batchId], [users], [customFees])",
      "5. For each user, validates feeBps <= BASIS_POINTS (10,000)",
      "6. No maximum cap enforced beyond 100%",
      "7. Malicious manager sets feeBps = 9500 (95%)",
      "8. fee = (assetAmount * 9500) / 10000",
      "9. redemptionAmount = assetAmount - fee",
      "10. User receives only 5% of redemption value",
      "11. 95% of funds seized as 'fee'",
      "12. User has no recourse"
    ],
    "context_hint": "The vulnerability stems from inadequate parameter validation. While the code prevents fees above 100%, it doesn't enforce a reasonable maximum fee percentage. In governance systems, privileged roles should be constrained by on-chain logic, not just off-chain trust assumptions. A reasonable maximum fee (e.g., 5%) should be enforced regardless of role permissions.",
    "expert_notes": "This is a classic issue in DeFi protocols where privileged roles have inadequately constrained parameters. The FULFILL_MANAGER_ROLE is designed to be trusted, but 'trust' should be verified with constraints. Cantina recommended enforcing maxCustomFeeBps as a state variable set via timelock. The fix prevents a single bad actor (or compromised key) from draining the vault through fee overcharges.",
    "fix_description": "Introduce a state variable maxCustomFeeBps (with timelock protection) and enforce it in fulfillFastRedeems to cap the maximum fee that can be charged.",
    "fix_code": "// In RedemptionPipeStorage:\nstruct RedemptionPipeStorage {\n    // ... existing fields ...\n    uint256 maxCustomFeeBps;  // Maximum custom fee in basis points\n}\n\n// Setter with timelock protection:\nfunction setMaxCustomFeeBps(\n    uint256 _maxCustomFeeBps\n) external onlyRole(TIMELOCK_ROLE) {\n    require(_maxCustomFeeBps <= 1000, \"Max fee exceeds 10%\");  // Cap at 10%\n    $.maxCustomFeeBps = _maxCustomFeeBps;\n    emit MaxCustomFeeBpsUpdated(_maxCustomFeeBps);\n}\n\n// Updated fulfillFastRedeems:\nfunction fulfillFastRedeems(\n    uint256 batchId,\n    address[] calldata users,\n    uint256[] calldata customFees\n) external onlyRole(FULFILL_MANAGER_ROLE) {\n    require(users.length == customFees.length, \"Array length mismatch\");\n    \n    RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n    \n    for (uint256 i = 0; i < users.length; i++) {\n        address user = users[i];\n        uint256 feeBps = customFees[i];\n        \n        // FIXED: Enforce maximum fee cap\n        require(\n            feeBps <= $.maxCustomFeeBps,\n            \"Fee exceeds maximum\"\n        );\n        \n        PendingFastRedeemRequest storage request = pendingFastRedeemRequests[batchId][user];\n        uint256 assetAmount = request.amount;\n        \n        uint256 fee = (assetAmount * feeBps) / BASIS_POINTS;\n        uint256 redemptionAmount = assetAmount - fee;\n        \n        underlyingAsset.safeTransfer(request.owner, redemptionAmount);\n    }\n}"
  },
  {
    "id": "gs_cantina_liminal_002",
    "report_url": "https://cantina.xyz/portfolio/ff700249-ee2f-4149-993d-93b110f3ae2e",
    "project_name": "Liminal Contracts",
    "github_url": "https://github.com/Lmnal/liminal-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-21",
    "vulnerability_type": "type_conversion_loss",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "cross_chain",
    "is_vulnerable": true,
    "title": "Unsafe Type Conversion for Refund Recipient Can Lead to Funds Lost to 0xdead Address",
    "description": "The lzCompose function's catch block extracts a refund recipient from a bytes32 payload and converts it to an address. However, the validation checks if the bytes32 is non-zero before conversion, but a non-zero bytes32 can have all zero lower 20 bytes. This causes the converted address to be address(0), resulting in funds being transferred to the LayerZero null address (0xdead), causing permanent loss.",
    "primary_file": {
      "name": "VaultComposerBase.sol",
      "path": "src/omnichain/VaultComposerBase.sol",
      "lines": "95-115",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {SafeERC20, IERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {IOFT, SendParam, MessagingFee} from \"@layerzerolabs/oft-evm/contracts/interfaces/IOFT.sol\";\nimport {IOAppComposer} from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppComposer.sol\";\nimport {IOAppCore} from \"@layerzerolabs/oapp-evm/contracts/oapp/interfaces/IOAppCore.sol\";\nimport {ILayerZeroEndpointV2} from \"@layerzerolabs/lz-evm-protocol-v2/contracts/interfaces/ILayerZeroEndpointV2.sol\";\nimport {OFTComposeMsgCodec} from \"@layerzerolabs/oft-evm/contracts/libs/OFTComposeMsgCodec.sol\";\n\n/**\n * @title VaultComposerBase - Multi-Asset Vault Composer Base\n * @notice Minimal base contract for cross-chain vault operations\n */\nabstract contract VaultComposerBase is IOAppComposer, ReentrancyGuardUpgradeable {\n    using OFTComposeMsgCodec for bytes;\n    using OFTComposeMsgCodec for bytes32;\n    using SafeERC20 for IERC20;\n\n    address public SHARE_OFT;\n    address public SHARE_ERC20;\n    address public ENDPOINT;\n    uint32 public VAULT_EID;\n\n    // Events\n    event Sent(bytes32 indexed guid);\n    event Refunded(bytes32 indexed guid);\n    event CrossChainDeposit(address indexed asset, address indexed depositor, address indexed shareRecipient, uint32 srcEid, uint256 dstEid, uint256 amount, uint256 shares);\n    event CrossChainRedemption(address indexed redeemer, address indexed assetRecipient, uint32 srcEid, uint256 dstEid, uint256 shares, uint256 assets);\n    event NativeRefunded(address indexed recipient, uint256 amount);\n    event AssetRefunded(address indexed asset, address indexed from, address indexed to, uint256 amount, uint32 dstEid);\n    event DustRefunded(address indexed asset, address indexed recipient, uint256 amount);\n\n    // Errors\n    error OnlyEndpoint(address caller);\n    error ShareOFTNotAdapter(address shareOFT);\n    error InvalidSendParam();\n    error InsufficientMsgValue();\n    error Slippage(uint256 actual, uint256 minimum);\n    error UnauthorizedOFTSender(address sender);\n    error InvalidSourceChain(uint32 srcEid);\n\n    // keccak256(abi.encode(uint256(keccak256(\"liminal.storage.VaultComposerBase.v1\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0x6c0f4739f9b140a9470c9589ba863e64a556e1c02777b0938a3c35b5956b9000;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __VaultComposerBase_init(address _shareOFT) internal onlyInitializing {\n        SHARE_OFT = _shareOFT;\n        SHARE_ERC20 = IOFT(SHARE_OFT).token();\n        ENDPOINT = address(IOAppCore(SHARE_OFT).endpoint());\n        VAULT_EID = ILayerZeroEndpointV2(ENDPOINT).eid();\n\n        __ReentrancyGuard_init();\n\n        if (!IOFT(SHARE_OFT).approvalRequired()) {\n            revert ShareOFTNotAdapter(SHARE_OFT);\n        }\n    }\n\n    function lzCompose(\n        address _composeSender,\n        bytes32 _guid,\n        bytes calldata _message,\n        address,\n        bytes calldata\n    ) public payable virtual override {\n        if (msg.sender != ENDPOINT) revert OnlyEndpoint(msg.sender);\n\n        if (!_isApprovedOFT(_composeSender)) {\n            revert UnauthorizedOFTSender(_composeSender);\n        }\n\n        {\n            bytes32 expectedPeer = _getRemotePeer(_composeSender, _message.srcEid());\n            if (expectedPeer == bytes32(0)) {\n                revert InvalidSourceChain(_message.srcEid());\n            }\n        }\n\n        bytes32 composeFrom = _message.composeFrom();\n        uint256 amount = _message.amountLD();\n        bytes memory composeMsg = _message.composeMsg();\n        uint32 srcEid = _message.srcEid();\n\n        try this.handleCompose{value: msg.value}(_composeSender, composeFrom, _guid, composeMsg, amount, srcEid) {\n            emit Sent(_guid);\n        } catch (bytes memory _err) {\n            if (bytes4(_err) == InsufficientMsgValue.selector) {\n                assembly {\n                    revert(add(32, _err), mload(_err))\n                }\n            }\n            _handleRefund(_composeSender, _message, composeFrom, composeMsg, amount);\n            emit Refunded(_guid);\n        }\n    }\n\n    function handleCompose(\n        address _oftIn,\n        bytes32 _composeFrom,\n        bytes32 _guid,\n        bytes memory _composeMsg,\n        uint256 _amount,\n        uint32 _srcEid\n    ) public payable virtual;\n\n    function _handleRefund(\n        address _composeSender,\n        bytes calldata _message,\n        bytes32 _composeFrom,\n        bytes memory _composeMsg,\n        uint256 _amount\n    ) internal virtual {\n        address assetRecipient = _composeFrom.bytes32ToAddress();\n        address feeRecipient = _composeFrom.bytes32ToAddress();\n\n        (uint8 action, bytes memory params) = abi.decode(_composeMsg, (uint8, bytes));\n\n        (, bytes32 extractedFeeRecipient, uint32 originEid) = _decodeReceivers(action, params);\n\n        address feeRecipientAddr = extractedFeeRecipient.bytes32ToAddress();\n        if (feeRecipientAddr != address(0)) {\n            feeRecipient = feeRecipientAddr;\n        }\n\n        uint32 refundEid = originEid != 0 ? originEid : _message.srcEid();\n\n        _refund(_composeSender, _message, _amount, assetRecipient, feeRecipient, refundEid);\n    }\n\n    function _send(address _oft, SendParam memory _sendParam, address _refundAddress) internal virtual {\n        if (_sendParam.to == bytes32(0) || _sendParam.amountLD == 0) revert InvalidSendParam();\n\n        MessagingFee memory fee = IOFT(_oft).quoteSend(_sendParam, false);\n        if (msg.value < fee.nativeFee) revert InsufficientMsgValue();\n\n        IOFT(_oft).send{value: fee.nativeFee}(_sendParam, fee, _refundAddress);\n\n        if (msg.value > fee.nativeFee) {\n            uint256 refundAmount = msg.value - fee.nativeFee;\n            payable(_refundAddress).transfer(refundAmount);\n            emit NativeRefunded(_refundAddress, refundAmount);\n        }\n    }\n\n    function _refund(\n        address _oft,\n        bytes calldata,\n        uint256 _amount,\n        address _assetRecipient,\n        address _feeRecipient,\n        uint32 _refundEid\n    ) internal virtual {\n        SendParam memory refundParam = SendParam({\n            dstEid: _refundEid,\n            to: bytes32(uint256(uint160(_assetRecipient))),\n            amountLD: _amount,\n            minAmountLD: 0,\n            extraOptions: \"\",\n            composeMsg: \"\",\n            oftCmd: \"\"\n        });\n\n        IOFT(_oft).send{value: msg.value}(refundParam, MessagingFee(msg.value, 0), _feeRecipient);\n\n        address asset = IOFT(_oft).token();\n        emit AssetRefunded(asset, address(this), _assetRecipient, _amount, _refundEid);\n    }\n\n    function _assertSlippage(uint256 _amount, uint256 _minAmount) internal pure {\n        if (_amount < _minAmount) revert Slippage(_amount, _minAmount);\n    }\n\n    function _decodeReceivers(uint8 _action, bytes memory _params)\n        internal\n        pure\n        returns (bytes32 receiver, bytes32 feeRefundRecipient, uint32 originEid)\n    {\n        if (_action == 1) {\n            (, receiver, , , feeRefundRecipient, originEid) = abi.decode(_params, (address, bytes32, SendParam, uint256, bytes32, uint32));\n        } else if (_action == 2) {\n            address receiverAddr;\n            (receiverAddr, , , , feeRefundRecipient, originEid) = abi.decode(_params, (address, SendParam, uint256, uint256, bytes32, uint32));\n            receiver = bytes32(uint256(uint160(receiverAddr)));\n        }\n    }\n\n    function _isApprovedOFT(address _oft) internal view virtual returns (bool);\n\n    function _getRemotePeer(address _oft, uint32 _srcEid) internal view virtual returns (bytes32);\n}\n"
    },
    "context_files": [
     
    ],
    "call_flow": [
      "1. User initiates cross-chain message with refund recipient in payload",
      "2. Message payload contains bytes32 recipient at offset 32:64",
      "3. Message sent via LayerZero to destination",
      "4. lzCompose called on destination",
      "5. handleCompose function invoked",
      "6. handleCompose fails (state issue, user error, etc.)",
      "7. Catch block executes",
      "8. _extractRefundRecipient reads bytes [32:64]",
      "9. extractedRecipient = bytes32 value with non-zero upper bytes but zero lower 20",
      "10. Check: if (extractedRecipient != bytes32(0)) PASSES",
      "11. Convert: address(extractedRecipient) → address(0)",
      "12. _refund called with address(0)",
      "13. Tokens transferred to address(0) → LayerZero 0xdead",
      "14. Funds permanently lost"
    ],
    "context_hint": "The vulnerability is a classic type conversion safety issue. The code validates the source type (bytes32) but not the target type (address) after conversion. A bytes32 can be non-zero while its address-relevant portion (lower 20 bytes) is zero. The validation must occur AFTER conversion, not before.",
    "expert_notes": "This is a subtle but critical bug in cross-chain messaging. The pattern of 'validate then convert' is backwards for this scenario. Cantina recommended validating the address AFTER conversion: check if the result equals address(0), not if the source equals bytes32(0). This is a common mistake in type conversion logic.",
    "fix_description": "Validate the converted address value, not the pre-conversion bytes32 value, to ensure refunds are never sent to address(0).",
    "fix_code": "function lzCompose(\n    address from,\n    bytes32 guid,\n    bytes calldata message,\n    address executor,\n    bytes calldata extraData\n) external payable virtual {\n    try this.handleCompose(from, message, extraData) {\n        // Handle successful compose\n    } catch {\n        // FIXED: Validate AFTER conversion, not before\n        bytes32 extractedRecipient = _extractRefundRecipient(message);\n        \n        // Convert first\n        address refundRecipientAddr = extractedRecipient.bytes32ToAddress();\n        \n        // Then validate the result\n        if (refundRecipientAddr != address(0)) {\n            _refund(refundRecipientAddr, message);\n        }\n        // If refundRecipientAddr == address(0), skip refund\n        // (Could log an event for monitoring)\n    }\n}\n\n// Or more explicitly:\nfunction lzCompose(\n    address from,\n    bytes32 guid,\n    bytes calldata message,\n    address executor,\n    bytes calldata extraData\n) external payable virtual {\n    try this.handleCompose(from, message, extraData) {\n        // Success\n    } catch {\n        address refundRecipient = _decodeRefundRecipientAddress(message);\n        \n        // Validate the decoded address\n        require(\n            refundRecipient != address(0),\n            \"Invalid refund recipient\"\n        );\n        \n        _refund(refundRecipient, message);\n    }\n}\n\nfunction _decodeRefundRecipientAddress(\n    bytes calldata message\n) internal pure returns (address) {\n    // Extract bytes32 at offset 32:64\n    bytes32 encoded = bytes32(message[32:64]);\n    // Convert to address (takes lower 20 bytes)\n    return address(uint160(uint256(encoded)));\n}\n// Now refund recipient is explicitly validated as non-zero address"
  },
  {
    "id": "gs_cantina_liminal_003",
    "report_url": "https://cantina.xyz/portfolio/ff700249-ee2f-4149-993d-93b110f3ae2e",
    "project_name": "Liminal Contracts",
    "github_url": "https://github.com/Lmnal/liminal-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-21",
    "vulnerability_type": "access_control_oracle",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "governance",
    "is_vulnerable": true,
    "title": "Critical Oracle Parameters Lack Timelock Protection",
    "description": "The setPriceId and setPriceIds functions, which configure Pyth price feed IDs and their decimals, are only protected by PRICE_MANAGER_ROLE and lack timelock protection. A compromised price manager could instantly change valid price feed IDs to malicious ones or set incorrect decimals, enabling flash loan attacks and price manipulation that affects all share calculations and enables fund siphoning.",
    "primary_file": {
      "name": "PythPriceOracle.sol",
      "path": "src/PythPriceOracle.sol",
      "lines": "150-180",
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Terms: https://liminal.money/xtokens/license\n\npragma solidity 0.8.28;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IPyth} from \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport {PythStructs} from \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/**\n * @title PythPriceOracle\n * @notice Oracle integration with Pyth Network price feeds\n * @dev Uses Pyth's pull-based price model with real-time updates\n */\ncontract PythPriceOracle is AccessControlUpgradeable, IPriceOracle {\n    bytes32 public constant PRICE_MANAGER_ROLE = keccak256(\"PRICE_MANAGER_ROLE\");\n\n    uint256 public constant BASIS_POINTS = 10000;\n\n    struct PythPriceOracleStorage {\n        address timeLockController;\n        mapping(address => bytes32) priceIds;\n        mapping(address => uint8) assetDecimals;\n        address underlyingAsset;\n        IPyth pyth;\n        uint96 maxPriceAge;\n        uint256 maxConfidenceBps;\n    }\n\n    bytes32 private constant PYTH_PRICE_ORACLE_STORAGE_LOCATION =\n        0x79f8fe64cf697304b8736b5ceebe50109f667154b58cb0fe6be0d930c76b5e00;\n\n    function _getPythPriceOracleStorage() private pure returns (PythPriceOracleStorage storage $) {\n        assembly {\n            $.slot := PYTH_PRICE_ORACLE_STORAGE_LOCATION\n        }\n    }\n\n    event PriceIdSet(address indexed asset, bytes32 priceId, uint8 decimals);\n    event UnderlyingAssetSet(address indexed asset);\n    event MaxPriceAgeUpdated(uint96 newMaxAge);\n    event PythContractUpdated(address indexed newPyth);\n    event TimelockControllerSet(address indexed oldTimelock, address indexed newTimelock);\n    event MaxConfidenceBpsUpdated(uint256 newMaxConfidenceBps);\n\n    modifier onlyTimelock() {\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        require(msg.sender == $.timeLockController, \"PythOracle: only timelock\");\n        _;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        address _deployer,\n        address _priceManager,\n        address _pyth,\n        address _underlyingAsset,\n        address _timeLockController,\n        uint256 _maxConfidenceBps\n    ) external initializer {\n        require(_deployer != address(0), \"PythOracle: zero deployer\");\n        require(_priceManager != address(0), \"PythOracle: zero manager\");\n        require(_pyth != address(0), \"PythOracle: zero pyth\");\n        require(_underlyingAsset != address(0), \"PythOracle: zero underlying\");\n        require(_timeLockController != address(0), \"PythOracle: zero timelock\");\n        require(_maxConfidenceBps > 0, \"PythOracle: zero confidence threshold\");\n        require(_maxConfidenceBps <= BASIS_POINTS, \"PythOracle: confidence threshold too high\");\n\n        __AccessControl_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _deployer);\n        _grantRole(PRICE_MANAGER_ROLE, _priceManager);\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.pyth = IPyth(_pyth);\n        $.underlyingAsset = _underlyingAsset;\n        $.maxPriceAge = 3600;\n        $.timeLockController = _timeLockController;\n        $.maxConfidenceBps = _maxConfidenceBps;\n\n        emit UnderlyingAssetSet(_underlyingAsset);\n    }\n\n    function setPriceId(address asset, bytes32 priceId, uint8 decimals) external onlyTimelock {\n        require(asset != address(0), \"PythOracle: zero asset\");\n        require(priceId != bytes32(0), \"PythOracle: zero price ID\");\n        require(decimals <= 18, \"PythOracle: invalid decimals\");\n        require(decimals == IERC20Metadata(asset).decimals(), \"PythOracle: decimals mismatch\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        $.priceIds[asset] = priceId;\n        $.assetDecimals[asset] = decimals;\n\n        emit PriceIdSet(asset, priceId, decimals);\n    }\n\n    function setPriceIds(address[] calldata assets, bytes32[] calldata _priceIds, uint8[] calldata decimalsArray)\n        external\n        onlyTimelock\n    {\n        require(assets.length == _priceIds.length, \"PythOracle: length mismatch\");\n        require(assets.length == decimalsArray.length, \"PythOracle: decimals mismatch\");\n\n        PythPriceOracleStorage storage $ = _getPythPriceOracleStorage();\n        for (uint256 i = 0; i < assets.length; i++) {\n            require(assets[i] != address(0), \"PythOracle: zero asset\");\n            require(_priceIds[i] != bytes32(0), \"PythOracle: zero price ID\");\n            require(decimalsArray[i] <= 18, \"PythOracle: invalid decimals\");\n            require(decimalsArray[i] == IERC20Metadata(assets[i]).decimals(), \"PythOracle: decimals mismatch\");\n\n            $.priceIds[assets[i]] = _priceIds[i];\n            $.assetDecimals[assets[i]] = decimalsArray[i];\n\n            emit PriceIdSet(assets[i], _priceIds[i], decimalsArray[i]);\n        }\n    }\n\n    function hasPriceFeed(address asset) external view returns (bool) {\n        return _getPythPriceOracleStorage().priceIds[asset] != bytes32(0);\n    }\n}\n"
    },
    "context_files": [
    ],
    "call_flow": [
      "1. PRICE_MANAGER_ROLE holder's key compromised or manager becomes malicious",
      "2. Attacker calls setPriceId(asset, newPriceId, newDecimals)",
      "3. assetPriceIds[asset] updated immediately (NO TIMELOCK)",
      "4. assetDecimals[asset] updated immediately",
      "5. Changes take effect in next block",
      "6. All price oracle queries use new (malicious) price feed",
      "7. Deposits/redemptions use inflated or deflated prices",
      "8. Share calculations compromised",
      "9. Users can be drained or diluted",
      "10. No timelock delay for detection/reaction",
      "11. Damage occurs before governance can respond"
    ],
    "context_hint": "Timelock protection is a critical pattern for sensitive parameters in DeFi. It creates a delay window where the community can see proposed changes and react (withdraw, cancel, etc.). Oracle parameters are among the most critical because they affect all financial calculations. A compromised or malicious oracle manager can manipulate the entire protocol's price inputs.",
    "expert_notes": "This follows the pattern established in other Liminal functions (e.g., setFunctionDelay) where timelocks are already used. Cantina identified that oracle parameter changes should follow the same pattern. The fix involves adding onlyTimelock modifier and implementing scheduled changes rather than immediate execution.",
    "fix_description": "Apply timelock protection to setPriceId and setPriceIds functions, requiring all oracle parameter changes to be scheduled with a delay before taking effect.",
    "fix_code": "// In PythPriceOracle:\n\nstruct PendingPriceChange {\n    address asset;\n    bytes32 newPriceId;\n    uint8 newDecimals;\n    uint256 executeTime;  // Can execute after this block.timestamp\n}\n\nmapping(address => PendingPriceChange) public pendingPriceChanges;\n\n// Require timelock for new price changes\nfunction setPriceId(\n    address asset,\n    bytes32 priceId,\n    uint8 decimals\n) external onlyRole(TIMELOCK_ROLE) {\n    // FIXED: Changes scheduled with delay\n    require(decimals <= 18, \"Invalid decimals\");\n    \n    uint256 delay = vaultTimelock.getDelay(this.setPriceId.selector);\n    uint256 executeTime = block.timestamp + delay;\n    \n    pendingPriceChanges[asset] = PendingPriceChange({\n        asset: asset,\n        newPriceId: priceId,\n        newDecimals: decimals,\n        executeTime: executeTime\n    });\n    \n    emit PriceChangeScheduled(asset, priceId, decimals, executeTime);\n}\n\n// Execute after delay:\nfunction executePriceChange(address asset) external {\n    PendingPriceChange storage pending = pendingPriceChanges[asset];\n    \n    require(\n        block.timestamp >= pending.executeTime,\n        \"Cannot execute yet\"\n    );\n    \n    assetPriceIds[asset] = pending.newPriceId;\n    assetDecimals[asset] = pending.newDecimals;\n    \n    emit PriceIdUpdated(asset, pending.newPriceId, pending.newDecimals);\n    \n    delete pendingPriceChanges[asset];\n}\n\n// Cancel malicious change:\nfunction cancelPriceChange(address asset) \n    external \n    onlyRole(DEFAULT_ADMIN_ROLE) \n{\n    delete pendingPriceChanges[asset];\n    emit PriceChangeCanceled(asset);\n}"
  }
]