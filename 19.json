[
  {
    "id": "gs_cantina_liminal_001",
    "report_url": "https://cantina.xyz/portfolio/ff700249-ee2f-4149-993d-93b110f3ae2e",
    "project_name": "Liminal Contracts",
    "github_url": "https://github.com/Lmnal/liminal-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-21",
    "vulnerability_type": "access_control_fee",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "privilege_escalation",
    "is_vulnerable": true,
    "title": "Custom Fees Settable up to 100% in fulfillFastRedeems Can Seize Redemptions",
    "description": "The fulfillFastRedeems function allows a caller with FULFILL_MANAGER_ROLE to set a customFees array with no practical upper limit. While the code checks that feeBps <= BASIS_POINTS (10,000), it lacks a reasonable maximum fee cap. This allows a privileged manager to set a punitive fee up to nearly 100%, which could seize the majority or almost all of a user's redemption value through fee overcharges.",
    "primary_file": {
      "name": "RedemptionPipe.sol",
      "path": "src/RedemptionPipe.sol",
      "lines": "220-250",
      "content": "function fulfillFastRedeems(\n    uint256 batchId,\n    address[] calldata users,\n    uint256[] calldata customFees\n) external onlyRole(FULFILL_MANAGER_ROLE) {\n    require(users.length == customFees.length, \"Array length mismatch\");\n    \n    for (uint256 i = 0; i < users.length; i++) {\n        address user = users[i];\n        uint256 feeBps = customFees[i];\n        \n        // BUG: Only checks against BASIS_POINTS (10,000 = 100%)\n        // No reasonable maximum is enforced\n        require(feeBps <= BASIS_POINTS, \"Fee exceeds 100%\");\n        \n        // With this check alone, feeBps can be 9,999 (99.99%)\n        // A user requesting redemption of 1000 USDC could receive:\n        // 1000 * (10,000 - 9,999) / 10,000 = 1000 * 1 / 10,000 = 0.1 USDC\n        // The remaining 999.9 USDC (99.99%) becomes the fee\n        \n        PendingFastRedeemRequest storage request = pendingFastRedeemRequests[batchId][user];\n        uint256 assetAmount = request.amount;\n        \n        // Calculate fee\n        uint256 fee = (assetAmount * feeBps) / BASIS_POINTS;\n        uint256 redemptionAmount = assetAmount - fee;\n        \n        // Transfer redemption amount\n        underlyingAsset.safeTransfer(request.owner, redemptionAmount);\n        \n        // Fee is retained by protocol\n        // But no cap on feeBps means a malicious manager can steal nearly all funds\n    }\n}\n\n// ATTACK SCENARIO:\n// 1. User requests fast redemption: 1000 USDC\n// 2. Redemption is queued, waiting for fulfillment\n// 3. Malicious FULFILL_MANAGER_ROLE calls fulfillFastRedeems\n// 4. Sets customFees[user] = 9,500 (95%)\n// 5. User receives: 1000 * (10,000 - 9,500) / 10,000 = 50 USDC\n// 6. 950 USDC seized as fee\n// 7. User loses 95% of their redemption value"
    },
    "context_files": [
      {
        "name": "Fee Percentage Calculation",
        "path": "src/RedemptionPipe.sol",
        "relevance": "Shows how fees are applied to redemption amounts",
        "content": "// Fee calculation pattern in fulfillFastRedeems:\n\n// Input: assetAmount = 1000 USDC, feeBps = 5000 (50%)\n// fee = (1000 * 5000) / 10000 = 500 USDC\n// redemptionAmount = 1000 - 500 = 500 USDC\n// User receives: 500 USDC\n// Protocol keeps: 500 USDC (as fee)\n\n// With no upper cap:\n// feeBps = 9999 (99.99%)\n// fee = (1000 * 9999) / 10000 = 999.9 USDC\n// redemptionAmount = 1000 - 999.9 = 0.1 USDC\n// User receives: 0.1 USDC\n// Protocol keeps: 999.9 USDC\n\n// This is essentially fund theft masked as a fee\n\n// BASIS_POINTS constant:\nconst uint256 BASIS_POINTS = 10_000;  // Represents 100%\n\n// Current validation:\nrequire(feeBps <= BASIS_POINTS, \"Fee exceeds 100%\");\n// Allows any value from 0 to 10,000 (0% to 100%)\n// No reasonable maximum like 500 (5%), 1000 (10%), etc."
      },
      {
        "name": "Expected vs Actual Fee Behavior",
        "path": "reference/liminal_fee_scenario.md",
        "relevance": "Documents fee scenarios and their impact",
        "content": "FEE SCENARIOS IN FULFILL_FAST_REDEEMS:\n\nScenario 1: Reasonable Fee (Expected)\n- User requests redemption: 1000 USDC\n- Set fee: 100 bps (1%)\n- User receives: 1000 - 10 = 990 USDC\n- Protocol receives: 10 USDC (reasonable fee)\n\nScenario 2: Excessive Fee (Current Vulnerability)\n- User requests redemption: 1000 USDC\n- Malicious manager sets fee: 5000 bps (50%)\n- User receives: 1000 - 500 = 500 USDC\n- Protocol receives: 500 USDC (50% seizure)\n\nScenario 3: Near-Total Seizure (Current Vulnerability)\n- User requests redemption: 1000 USDC\n- Malicious manager sets fee: 9500 bps (95%)\n- User receives: 1000 - 950 = 50 USDC\n- Protocol receives: 950 USDC (95% seizure)\n\nScenario 4: Maximum Allowed Seizure (Current Vulnerability)\n- User requests redemption: 1000 USDC\n- Malicious manager sets fee: 9999 bps (99.99%)\n- User receives: 1000 - 999.9 = 0.1 USDC\n- Protocol receives: 999.9 USDC (99.99% seizure)\n\nCOMPARISON WITH NORMAL PROTOCOLS:\n- Typical redemption fee: 0.1% - 1%\n- Uniswap V3: 0% - 1% LP fee\n- Aave variable: 0% (no withdrawal fee)\n- Curve: 0.04% standard fee\n\nLiminal's current setup allows:\n- 100x to 10,000x higher fees than industry standard\n- Essentially unlimited fee extraction\n\nIMPACT AMPLIFICATION:\n- With 1000 daily redemptions of 10k USDC each\n- At 50% fee: 5M USDC stolen per day\n- At 95% fee: 9.5M USDC stolen per day\n- Over a month: 300M USDC (50%) or 285M USDC (95%)\n\nMITIGATION:\nEnforce maxCustomFeeBps (e.g., 500 bps = 5% maximum)\nrequire(feeBps <= maxCustomFeeBps, \"Fee exceeds maximum\");"
      }
    ],
    "call_flow": [
      "1. User calls requestRedeemFast(shares, controller, owner)",
      "2. Shares locked in pending redemption request",
      "3. Awaiting fulfillment from FULFILL_MANAGER_ROLE",
      "4. Manager calls fulfillFastRedeems([batchId], [users], [customFees])",
      "5. For each user, validates feeBps <= BASIS_POINTS (10,000)",
      "6. No maximum cap enforced beyond 100%",
      "7. Malicious manager sets feeBps = 9500 (95%)",
      "8. fee = (assetAmount * 9500) / 10000",
      "9. redemptionAmount = assetAmount - fee",
      "10. User receives only 5% of redemption value",
      "11. 95% of funds seized as 'fee'",
      "12. User has no recourse"
    ],
    "context_hint": "The vulnerability stems from inadequate parameter validation. While the code prevents fees above 100%, it doesn't enforce a reasonable maximum fee percentage. In governance systems, privileged roles should be constrained by on-chain logic, not just off-chain trust assumptions. A reasonable maximum fee (e.g., 5%) should be enforced regardless of role permissions.",
    "expert_notes": "This is a classic issue in DeFi protocols where privileged roles have inadequately constrained parameters. The FULFILL_MANAGER_ROLE is designed to be trusted, but 'trust' should be verified with constraints. Cantina recommended enforcing maxCustomFeeBps as a state variable set via timelock. The fix prevents a single bad actor (or compromised key) from draining the vault through fee overcharges.",
    "fix_description": "Introduce a state variable maxCustomFeeBps (with timelock protection) and enforce it in fulfillFastRedeems to cap the maximum fee that can be charged.",
    "fix_code": "// In RedemptionPipeStorage:\nstruct RedemptionPipeStorage {\n    // ... existing fields ...\n    uint256 maxCustomFeeBps;  // Maximum custom fee in basis points\n}\n\n// Setter with timelock protection:\nfunction setMaxCustomFeeBps(\n    uint256 _maxCustomFeeBps\n) external onlyRole(TIMELOCK_ROLE) {\n    require(_maxCustomFeeBps <= 1000, \"Max fee exceeds 10%\");  // Cap at 10%\n    $.maxCustomFeeBps = _maxCustomFeeBps;\n    emit MaxCustomFeeBpsUpdated(_maxCustomFeeBps);\n}\n\n// Updated fulfillFastRedeems:\nfunction fulfillFastRedeems(\n    uint256 batchId,\n    address[] calldata users,\n    uint256[] calldata customFees\n) external onlyRole(FULFILL_MANAGER_ROLE) {\n    require(users.length == customFees.length, \"Array length mismatch\");\n    \n    RedemptionPipeStorage storage $ = _getRedemptionPipeStorage();\n    \n    for (uint256 i = 0; i < users.length; i++) {\n        address user = users[i];\n        uint256 feeBps = customFees[i];\n        \n        // FIXED: Enforce maximum fee cap\n        require(\n            feeBps <= $.maxCustomFeeBps,\n            \"Fee exceeds maximum\"\n        );\n        \n        PendingFastRedeemRequest storage request = pendingFastRedeemRequests[batchId][user];\n        uint256 assetAmount = request.amount;\n        \n        uint256 fee = (assetAmount * feeBps) / BASIS_POINTS;\n        uint256 redemptionAmount = assetAmount - fee;\n        \n        underlyingAsset.safeTransfer(request.owner, redemptionAmount);\n    }\n}"
  },
  {
    "id": "gs_cantina_liminal_002",
    "report_url": "https://cantina.xyz/portfolio/ff700249-ee2f-4149-993d-93b110f3ae2e",
    "project_name": "Liminal Contracts",
    "github_url": "https://github.com/Lmnal/liminal-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-21",
    "vulnerability_type": "type_conversion_loss",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "cross_chain",
    "is_vulnerable": true,
    "title": "Unsafe Type Conversion for Refund Recipient Can Lead to Funds Lost to 0xdead Address",
    "description": "The lzCompose function's catch block extracts a refund recipient from a bytes32 payload and converts it to an address. However, the validation checks if the bytes32 is non-zero before conversion, but a non-zero bytes32 can have all zero lower 20 bytes. This causes the converted address to be address(0), resulting in funds being transferred to the LayerZero null address (0xdead), causing permanent loss.",
    "primary_file": {
      "name": "VaultComposerBase.sol",
      "path": "src/omnichain/VaultComposerBase.sol",
      "lines": "95-115",
      "content": "function lzCompose(\n    address from,\n    bytes32 guid,\n    bytes calldata message,\n    address executor,\n    bytes calldata extraData\n) external payable virtual {\n    try this.handleCompose(from, message, extraData) {\n        // Handle successful compose\n    } catch {\n        // BUG: Unsafe type conversion for refund recipient\n        bytes32 extractedRecipient = _extractRefundRecipient(message);\n        \n        // DANGEROUS: Checks if bytes32 is non-zero\n        // But bytes32(0x00000000...1234) is non-zero\n        // While lower 20 bytes (address part) are all zeros\n        if (extractedRecipient != bytes32(0)) {\n            // BUG: Direct conversion without checking lower 20 bytes\n            address refundRecipient = extractedRecipient.bytes32ToAddress();\n            // refundRecipient could be address(0) despite bytes32(0) check passing\n            \n            _refund(refundRecipient, message);\n            // Refund goes to address(0), which is 0xdead in LayerZero\n            // PERMANENT LOSS OF FUNDS\n        }\n    }\n}\n\n// Helper function (simplified):\nfunction _extractRefundRecipient(\n    bytes calldata message\n) internal pure returns (bytes32) {\n    // Extracts recipient from payload (e.g., offset 32-63)\n    return bytes32(message[32:64]);\n}\n\n// VULNERABILITY SCENARIO:\n// Malformed or intentional payload:\n// bytes32 value = 0x0000000000000000000000000000000000000000000000001234567890ABCDEF\n//                (high 12 bytes non-zero, but lower 20 bytes all zero)\n//\n// Check: if (extractedRecipient != bytes32(0)) {\n//     Result: TRUE (0x...1234... != 0x...0000)\n// \n// Conversion: address(extractedRecipient)\n//     Takes lower 20 bytes: 0x0000000000000000000000000000000000000000\n//     Result: address(0)\n//\n// Transfer occurs: safeTransfer(address(0), assets)\n//     LayerZero treats address(0) as 0xdead (dead letter address)\n//     FUNDS ARE PERMANENTLY LOST"
    },
    "context_files": [
      {
        "name": "Type Conversion Logic",
        "path": "src/omnichain/VaultComposerBase.sol",
        "relevance": "Shows the vulnerable conversion pattern",
        "content": "// Current vulnerable pattern:\n\n// bytes32 → address conversion in Solidity:\nfunction bytes32ToAddress(bytes32 b) internal pure returns (address) {\n    return address(uint160(uint256(b)));\n    // Takes LOWER 20 bytes (160 bits) of the bytes32\n    // Ignores UPPER 12 bytes\n}\n\n// Example:\nbytes32 value1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n// Lower 20 bytes: 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF (all ones)\n// address(value1) → 0xFFfFfFffFFfffFFfFFfFFFFFFFFFFFFFFFFFffFf (checksum address)\n\nbytes32 value2 = 0x1234567890AB00000000000000000000000000000000000000000000000000;\n// Lower 20 bytes: 0x00000000000000000000000000000000000000000\n// address(value2) → 0x0000000000000000000000000000000000000000 (address(0))\n\n// The zero-check before conversion is USELESS:\nrequire(extractedRecipient != bytes32(0), \"Invalid recipient\");\n// Passes for value2, even though address(value2) == address(0)\n\n// LayerZero endpoint mapping:\n// address(0) → 0xdead (special dead letter address for refunds)\n// This is where stuck/failed refunds go\n// PERMANENT LOSS"
      },
      {
        "name": "Attack Scenario",
        "path": "reference/liminal_refund_loss.md",
        "relevance": "Documents how funds are lost",
        "content": "SCENARIO: Funds Lost Due to Type Conversion\n\nSetup:\n- User initiates cross-chain deposit from Chain A to Chain B\n- Deposit amount: 1000 USDC\n- Refund recipient: encoded in message payload at bytes [32:64]\n\nAttack/Failure:\n\nOption 1: Intentional Malicious Payload\n1. Attacker crafts message with:\n   - bytes32(0x1234567890ABCDEF000000000000000000000000000000000000000000000000)\n   - Upper bytes non-zero (passes bytes32(0) check)\n   - Lower 20 bytes all zero\n\n2. Message sent to destination Chain B\n\n3. lzCompose triggered, handleCompose called\n\n4. handleCompose fails for some reason (state mismatch, etc.)\n\n5. Catch block executes:\n   - extractedRecipient = 0x1234567890ABCDEF000000000000000000000000000000000000000000000000\n   - Check: if (extractedRecipient != bytes32(0)) → TRUE\n   - Convert: address(extractedRecipient)\n   - Result: address(0x0000000000000000000000000000000000000000)\n\n6. _refund called with address(0)\n\n7. Refund transfer:\n   - USDC.transfer(address(0), 1000 USDC)\n   - LayerZero endpoint treats address(0) as 0xdead\n   - Tokens transferred to dead letter address\n\n8. RESULT: 1000 USDC PERMANENTLY LOST\n\nOption 2: Malformed Payload From Legitimate User\n1. User constructs message with typo in refund address\n2. Accidentally sets bytes [32:64] to non-zero but lower 20 bytes = 0x0\n3. Message sent\n4. Fails at destination\n5. Refund goes to address(0) → dead address\n6. Legitimate user loses funds due to encoding error\n\nIMPACT AMPLIFICATION:\n- Every cross-chain deposit has a refund recipient\n- If ANY message fails due to state mismatch, LZ problems, etc.\n- And refund recipient happens to encode to address(0)\n- Funds are permanently lost\n- No recovery mechanism\n\nIMPACT SCALE:\n- With 100k daily cross-chain transactions\n- 1% rate of failures: 1000 failures/day\n- 0.1% of failures have zero-address encoding: 1 per day\n- 1000 USDC per transaction: 1000 USDC lost/day\n- Per month: 30,000 USDC lost\n- Per year: 365,000 USDC lost\n- This is just the probability without active attacks"
      }
    ],
    "call_flow": [
      "1. User initiates cross-chain message with refund recipient in payload",
      "2. Message payload contains bytes32 recipient at offset 32:64",
      "3. Message sent via LayerZero to destination",
      "4. lzCompose called on destination",
      "5. handleCompose function invoked",
      "6. handleCompose fails (state issue, user error, etc.)",
      "7. Catch block executes",
      "8. _extractRefundRecipient reads bytes [32:64]",
      "9. extractedRecipient = bytes32 value with non-zero upper bytes but zero lower 20",
      "10. Check: if (extractedRecipient != bytes32(0)) PASSES",
      "11. Convert: address(extractedRecipient) → address(0)",
      "12. _refund called with address(0)",
      "13. Tokens transferred to address(0) → LayerZero 0xdead",
      "14. Funds permanently lost"
    ],
    "context_hint": "The vulnerability is a classic type conversion safety issue. The code validates the source type (bytes32) but not the target type (address) after conversion. A bytes32 can be non-zero while its address-relevant portion (lower 20 bytes) is zero. The validation must occur AFTER conversion, not before.",
    "expert_notes": "This is a subtle but critical bug in cross-chain messaging. The pattern of 'validate then convert' is backwards for this scenario. Cantina recommended validating the address AFTER conversion: check if the result equals address(0), not if the source equals bytes32(0). This is a common mistake in type conversion logic.",
    "fix_description": "Validate the converted address value, not the pre-conversion bytes32 value, to ensure refunds are never sent to address(0).",
    "fix_code": "function lzCompose(\n    address from,\n    bytes32 guid,\n    bytes calldata message,\n    address executor,\n    bytes calldata extraData\n) external payable virtual {\n    try this.handleCompose(from, message, extraData) {\n        // Handle successful compose\n    } catch {\n        // FIXED: Validate AFTER conversion, not before\n        bytes32 extractedRecipient = _extractRefundRecipient(message);\n        \n        // Convert first\n        address refundRecipientAddr = extractedRecipient.bytes32ToAddress();\n        \n        // Then validate the result\n        if (refundRecipientAddr != address(0)) {\n            _refund(refundRecipientAddr, message);\n        }\n        // If refundRecipientAddr == address(0), skip refund\n        // (Could log an event for monitoring)\n    }\n}\n\n// Or more explicitly:\nfunction lzCompose(\n    address from,\n    bytes32 guid,\n    bytes calldata message,\n    address executor,\n    bytes calldata extraData\n) external payable virtual {\n    try this.handleCompose(from, message, extraData) {\n        // Success\n    } catch {\n        address refundRecipient = _decodeRefundRecipientAddress(message);\n        \n        // Validate the decoded address\n        require(\n            refundRecipient != address(0),\n            \"Invalid refund recipient\"\n        );\n        \n        _refund(refundRecipient, message);\n    }\n}\n\nfunction _decodeRefundRecipientAddress(\n    bytes calldata message\n) internal pure returns (address) {\n    // Extract bytes32 at offset 32:64\n    bytes32 encoded = bytes32(message[32:64]);\n    // Convert to address (takes lower 20 bytes)\n    return address(uint160(uint256(encoded)));\n}\n// Now refund recipient is explicitly validated as non-zero address"
  },
  {
    "id": "gs_cantina_liminal_003",
    "report_url": "https://cantina.xyz/portfolio/ff700249-ee2f-4149-993d-93b110f3ae2e",
    "project_name": "Liminal Contracts",
    "github_url": "https://github.com/Lmnal/liminal-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-21",
    "vulnerability_type": "access_control_oracle",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "governance",
    "is_vulnerable": true,
    "title": "Critical Oracle Parameters Lack Timelock Protection",
    "description": "The setPriceId and setPriceIds functions, which configure Pyth price feed IDs and their decimals, are only protected by PRICE_MANAGER_ROLE and lack timelock protection. A compromised price manager could instantly change valid price feed IDs to malicious ones or set incorrect decimals, enabling flash loan attacks and price manipulation that affects all share calculations and enables fund siphoning.",
    "primary_file": {
      "name": "PythPriceOracle.sol",
      "path": "src/PythPriceOracle.sol",
      "lines": "150-180",
      "content": "function setPriceId(\n    address asset,\n    bytes32 priceId,\n    uint8 decimals\n) external onlyRole(PRICE_MANAGER_ROLE) {\n    // BUG: No timelock protection\n    // Changes take effect IMMEDIATELY\n    // Compromised or malicious manager can instantly change price feeds\n    \n    require(decimals <= 18, \"Invalid decimals\");\n    \n    assetPriceIds[asset] = priceId;\n    assetDecimals[asset] = decimals;\n    \n    emit PriceIdUpdated(asset, priceId, decimals);\n}\n\nfunction setPriceIds(\n    address[] calldata assets,\n    bytes32[] calldata priceIds,\n    uint8[] calldata decimals\n) external onlyRole(PRICE_MANAGER_ROLE) {\n    // Same vulnerability in batch version\n    // Multiple price feeds can be changed instantly\n    require(assets.length == priceIds.length, \"Length mismatch\");\n    \n    for (uint256 i = 0; i < assets.length; i++) {\n        require(decimals[i] <= 18, \"Invalid decimals\");\n        assetPriceIds[assets[i]] = priceIds[i];\n        assetDecimals[assets[i]] = decimals[i];\n    }\n}\n\n// ATTACK SCENARIO:\n// Step 1: Normal operation\n// - USDC price feed: 0x1234...abcd (valid Pyth feed)\n// - Decimals: 8\n// \n// Step 2: Manager compromise\n// - Attacker gains control of PRICE_MANAGER_ROLE key\n// - Or manager is coerced/compromised\n// \n// Step 3: Instant attack\n// - Calls setPriceId(USDC, 0x9999...ffff, 18)\n// - 0x9999...ffff is attacker-controlled or returns inflated price\n// - Changes take effect immediately (NO TIMELOCK)\n// \n// Step 4: Exploitation\n// - All price conversions now use 0x9999...ffff\n// - Users deposit at inflated prices\n// - Share calculations use wrong decimals\n// - Fund siphoning via arbitrage\n// \n// Step 5: No recovery window\n// - No timelock delay for users to react\n// - No alert mechanism\n// - Damage done before governance can respond"
    },
    "context_files": [
      {
        "name": "Oracle Price Feed Integration",
        "path": "src/PythPriceOracle.sol",
        "relevance": "Shows how price feeds are used in calculations",
        "content": "// Price oracle is used throughout the system:\n\nfunction getPrice(address asset) external view returns (uint256) {\n    // Uses assetPriceIds[asset] to fetch from Pyth\n    bytes32 priceId = assetPriceIds[asset];\n    \n    // If priceId has been maliciously changed, wrong price returned\n    PythStructs.Price memory price = pyth.getPriceNoOlderThan(\n        DEFAULT_PRICE_MAX_AGE,\n        priceId  // BUG: Attacker-controlled if manager compromised\n    );\n    \n    // Price normalization uses assetDecimals[asset]\n    // Wrong decimals = wrong scaling = wrong share value\n    uint256 normalizedPrice = normalizePrice(\n        price.price,\n        assetDecimals[asset]  // BUG: Can be set to wrong value\n    );\n    \n    return normalizedPrice;\n}\n\n// This affects:\nfunction depositPipe.deposit(\n    uint256 assets,\n    address receiver\n) external returns (uint256) {\n    // Gets underlyingValue using compromised price\n    uint256 underlyingValue = priceOracle.convertAmount(\n        depositAsset,\n        REFERENCE_ASSET,\n        assets\n    );\n    // With inflated price, underlyingValue is too high\n    // User mints excessive shares\n    \n    uint256 sharesToMint = _convertToShares(underlyingValue);\n    // sharesToMint = (underlyingValue * totalSupply) / totalAssets\n    // If underlyingValue inflated by 10x, shares inflated by 10x\n    \n    shareManager.mintShares(receiver, sharesToMint);\n    return sharesToMint;\n}\n\nfunction redemptionPipe.redeem(\n    uint256 shares,\n    address receiver\n) external returns (uint256) {\n    // Gets assetValue using compromised price\n    uint256 assetValue = navOracle.convertToAssets(shares);\n    // With inflated price, assetValue is too high\n    // User redeems excessive assets\n    \n    underlyingAsset.transfer(receiver, assetValue);\n    return assetValue;\n}\n\n// Impact:\n// - Deposits use inflated prices → users mint excess shares at low cost\n// - Redemptions use inflated prices → users withdraw excess assets\n// - Share price becomes detached from reality\n// - Honest users are diluted\n// - Fund drain occurs"
      },
      {
        "name": "Exploitation Steps",
        "path": "reference/liminal_oracle_attack.md",
        "relevance": "Documents the full attack flow",
        "content": "ATTACK: Oracle Manipulation via Compromised PRICE_MANAGER_ROLE\n\nSetup:\n- Liminal vault with 100,000,000 USDC TVL\n- USDC price feed: 0x12ab..cdef (valid Pyth)\n- Decimals: 8\n- Share price: 1 share = 1 USDC\n\nStep 1: Manager Compromise\n- Attacker gains PRICE_MANAGER_ROLE (stolen key, insider, etc.)\n- No timelock, so immediate action possible\n\nStep 2: Oracle Manipulation (INSTANT)\n- Calls setPriceId(USDC, 0x9999...ffff, 8)\n- 0x9999...ffff is either:\n  - Attacker-controlled price feed returning 100 USDC per wei\n  - Or address of a contract with malicious price logic\n- Price feed changed instantly (NO DELAY)\n\nStep 3: Exploitation (Same Transaction or Next Block)\n\nOption A: Deposit Inflation\n1. Attacker deposits 1 USDC\n2. Price is now 100 USDC per wei\n3. 1 wei valued at 100 USDC\n4. Shares minted: (100e6 * 100M) / 100M = 100 shares\n5. Attacker gets 100 shares for 1 wei\n6. Honest users' shares diluted\n\nOption B: Redemption Drain\n1. Attacker has 1 share\n2. Calls redeem(1 share, attacker)\n3. Share value calculated using inflated price\n4. 1 share = 100 USDC (due to inflated price)\n5. Attacker receives 100 USDC for 1 wei share\n6. Vault loses 100 USDC\n\nOption C: NAV Manipulation\n1. All price conversions use inflated oracle\n2. NAV calculations inflate\n3. New deposits valued at inflated prices\n4. Massive share dilution for new depositors\n\nStep 4: Defense Mechanisms Fail\n- No timelock = users can't react\n- No event monitoring = silent attack\n- Price manager is trusted = no override mechanism\n- Once changed, price feeds stay changed\n\nRecovery:\n- Requires another privileged call to fix\n- Or governance intervention\n- But damage is already done\n- Lost value: depends on duration, up to entire TVL\n\nImpact with 100M TVL:\n- Attacker could drain millions in single transaction\n- Or setup long-term extraction via deposits/redeems\n- No window for users to withdraw\n- Governance takes time to respond\n\nTimelock Solution:\n- setPriceId calls scheduled for 7-day delay\n- Users have time to withdraw\n- Governance can cancel malicious changes\n- Attacker window: much larger and detectable"
      }
    ],
    "call_flow": [
      "1. PRICE_MANAGER_ROLE holder's key compromised or manager becomes malicious",
      "2. Attacker calls setPriceId(asset, newPriceId, newDecimals)",
      "3. assetPriceIds[asset] updated immediately (NO TIMELOCK)",
      "4. assetDecimals[asset] updated immediately",
      "5. Changes take effect in next block",
      "6. All price oracle queries use new (malicious) price feed",
      "7. Deposits/redemptions use inflated or deflated prices",
      "8. Share calculations compromised",
      "9. Users can be drained or diluted",
      "10. No timelock delay for detection/reaction",
      "11. Damage occurs before governance can respond"
    ],
    "context_hint": "Timelock protection is a critical pattern for sensitive parameters in DeFi. It creates a delay window where the community can see proposed changes and react (withdraw, cancel, etc.). Oracle parameters are among the most critical because they affect all financial calculations. A compromised or malicious oracle manager can manipulate the entire protocol's price inputs.",
    "expert_notes": "This follows the pattern established in other Liminal functions (e.g., setFunctionDelay) where timelocks are already used. Cantina identified that oracle parameter changes should follow the same pattern. The fix involves adding onlyTimelock modifier and implementing scheduled changes rather than immediate execution.",
    "fix_description": "Apply timelock protection to setPriceId and setPriceIds functions, requiring all oracle parameter changes to be scheduled with a delay before taking effect.",
    "fix_code": "// In PythPriceOracle:\n\nstruct PendingPriceChange {\n    address asset;\n    bytes32 newPriceId;\n    uint8 newDecimals;\n    uint256 executeTime;  // Can execute after this block.timestamp\n}\n\nmapping(address => PendingPriceChange) public pendingPriceChanges;\n\n// Require timelock for new price changes\nfunction setPriceId(\n    address asset,\n    bytes32 priceId,\n    uint8 decimals\n) external onlyRole(TIMELOCK_ROLE) {\n    // FIXED: Changes scheduled with delay\n    require(decimals <= 18, \"Invalid decimals\");\n    \n    uint256 delay = vaultTimelock.getDelay(this.setPriceId.selector);\n    uint256 executeTime = block.timestamp + delay;\n    \n    pendingPriceChanges[asset] = PendingPriceChange({\n        asset: asset,\n        newPriceId: priceId,\n        newDecimals: decimals,\n        executeTime: executeTime\n    });\n    \n    emit PriceChangeScheduled(asset, priceId, decimals, executeTime);\n}\n\n// Execute after delay:\nfunction executePriceChange(address asset) external {\n    PendingPriceChange storage pending = pendingPriceChanges[asset];\n    \n    require(\n        block.timestamp >= pending.executeTime,\n        \"Cannot execute yet\"\n    );\n    \n    assetPriceIds[asset] = pending.newPriceId;\n    assetDecimals[asset] = pending.newDecimals;\n    \n    emit PriceIdUpdated(asset, pending.newPriceId, pending.newDecimals);\n    \n    delete pendingPriceChanges[asset];\n}\n\n// Cancel malicious change:\nfunction cancelPriceChange(address asset) \n    external \n    onlyRole(DEFAULT_ADMIN_ROLE) \n{\n    delete pendingPriceChanges[asset];\n    emit PriceChangeCanceled(asset);\n}"
  }
]