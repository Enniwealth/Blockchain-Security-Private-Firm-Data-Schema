//Marked
[{
  "id": "gs_spearbit_kinetiq_001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "spearbit",
  "source_report": "Kinetiq: Launch/Markets",
  "source_finding_id": "1.1",
  "report_url": "https://cantina.xyz/portfolio/1b09ea97-eaab-48f7-be91-5cf2fa323947",
  "github_repo_url": "https://github.com/kinetiq-research/launch",
  "contest_date": "2025-11-23",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  "finding_title": "Operator Bond Cannot Be Recovered and Will Be Locked in ExManager",
  "finding_description": "ExManager requires operators to deposit HYPE tokens equal to opBond as a 'skin-in-the-game' mechanism to ensure operator accountability. When an operator calls ExManager.bond(), the contract deposits the HYPE bond and mints the corresponding amount of exLST tokens. However, these exLST tokens are minted to the ExManager contract itself, not to the operator, ensuring the operator cannot withdraw or use the bonded funds. Once the contract is unwound and ExManager is no longer operational, the operator has no mechanism to redeem or claim back their HYPE bond. The exLST tokens minted to ExManager remain locked inside HIP3StakingManager, making the operator bond permanently inaccessible. This results in the bonded assets being irrecoverably locked, which contradicts the intended lifecycle of the operator bond and creates a significant economic burden for operators.",
  "attack_scenario": "1. Operator deposits 50,000 HYPE as opBond by calling ExManager.bond()\n2. Contract receives 50,000 HYPE from operator\n3. 50,000 exLST tokens are minted and sent to ExManager contract (not operator)\n4. Protocol runs normally through FUNDING and LIVE phases\n5. Protocol reaches WOUND_DOWN phase as scheduled\n6. ExManager is unwound and no longer operational\n7. Operator attempts to recover their 50,000 HYPE bond\n8. No recovery mechanism exists in the unwound state\n9. exLST tokens remain locked in HIP3StakingManager contract\n10. Operator loses 50,000 HYPE permanently\n11. In permissionless deployment with 10% bond on 500K HYPE = 50K HYPE loss per operator",
  "fix_description": "Implement a redemption mechanism allowing operators to burn exLST tokens and claim back their HYPE bond after unwinding. This can be achieved by: (1) Adding a function like claimBond() or recoverOperatorBond() that allows the operator to burn their corresponding exLST tokens from ExManager and receive back the underlying HYPE. (2) Tracking the original bonded amount per operator to determine how much exLST to burn. (3) Executing the redemption by removing exLST from circulation and returning the proportional HYPE share. Example implementation: function recoverOperatorBond() external onlyOperator { require(exPhase == EXPhase.WOUND_DOWN, \"Contract not unwound\"); uint256 exLstBalance = _exLST.balanceOf(address(this)); require(exLstBalance > 0, \"No bond to recover\"); _exLST.burn(exLstBalance); (bool success,) = operator.call{value: address(this).balance}(\"\"); require(success, \"Recovery failed\"); }",
  "primary_file": {
    "path": "src/EXManager.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./HIP3StakingManager.sol\";\nimport \"./interfaces/IExLST.sol\";\n\ncontract EXManager {\n    enum EXPhase { FUNDING, LIVE, WOUND_DOWN }\n    \n    address public operator;\n    uint256 public opBond;  // Required bond amount\n    EXPhase public exPhase;\n    \n    IExLST public exLST;  // exLST token\n    HIP3StakingManager public stakingManager;\n    IERC20 public hype;  // HYPE token\n    \n    mapping(address => uint256) public operatorBonds;  // Track bonded amounts\n    \n    event Bonded(address indexed operator, uint256 shares);\n    event Unwound(EXPhase newPhase);\n    \n    modifier onlyOperator() {\n        require(msg.sender == operator, \"Not operator\");\n        _;\n    }\n    \n    constructor(\n        address _operator,\n        uint256 _opBond,\n        address _exLST,\n        address _stakingManager,\n        address _hype\n    ) {\n        operator = _operator;\n        opBond = _opBond;\n        exLST = IExLST(_exLST);\n        stakingManager = HIP3StakingManager(payable(_stakingManager));\n        hype = IERC20(_hype);\n    }\n    \n    // VULNERABLE: Bonds HYPE but mints exLST to ExManager, not operator\n    function bond() external onlyOperator {\n        require(exPhase == EXPhase.FUNDING, \"Not in FUNDING phase\");\n        \n        // Receive HYPE from operator\n        require(hype.transferFrom(msg.sender, address(this), opBond), \"Transfer failed\");\n        \n        // Deposit HYPE into StakingManager\n        hype.approve(address(stakingManager), opBond);\n        stakingManager.stake{value: opBond}();\n        \n        // Mint exLST to ExManager (not operator!)\n        uint256 shares = calculateSharesForBond(opBond);\n        exLST.mint(address(this), shares);  // VULNERABLE: Mints to ExManager\n        \n        // Track the bond\n        operatorBonds[msg.sender] = shares;\n        \n        emit Bonded(msg.sender, shares);\n    }\n    \n    // VULNERABLE: No recovery mechanism when unwound\n    function unwind() external onlyOperator {\n        require(exPhase == EXPhase.LIVE, \"Not in LIVE phase\");\n        \n        // Transition to WOUND_DOWN\n        exPhase = EXPhase.WOUND_DOWN;\n        \n        // Withdraw from StakingManager and process withdrawals\n        // ...\n        \n        // VULNERABLE: exLST tokens remain locked in StakingManager\n        // No mechanism to claim them back\n        // exLST balance in ExManager is never redeemed\n        \n        emit Unwound(exPhase);\n    }\n    \n    // MISSING: No recoverOperatorBond() function\n    // Operator cannot access their exLST tokens after unwinding\n    // The bonded HYPE is permanently locked\n    \n    function calculateSharesForBond(uint256 hypeAmount) internal view returns (uint256) {\n        // Simplified calculation\n        // In reality, this would calculate shares based on current exchange rate\n        uint256 totalSupply = exLST.totalSupply();\n        uint256 reserves = stakingManager.totalReserves();\n        \n        if (reserves == 0) return hypeAmount;  // 1:1 at start\n        return (hypeAmount * totalSupply) / reserves;\n    }\n}\n",
    "vulnerable_lines": [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87],
    "vulnerable_functions": ["bond", "unwind"]
  },
  "context_files": [
    {
      "path": "src/HIP3StakingManager.sol",
      "content": "// HIP3StakingManager receives HYPE deposits via stake() and manages them\n// When ExManager calls stake(), the HYPE is deposited and tracked in StakingManager\n// The corresponding exLST tokens are minted by ExManager\n\n// VULNERABLE: No mechanism to redeem exLST from ExManager after unwinding\n// When ExManager.unwind() is called, the exLST tokens remain stuck\n// because HIP3StakingManager never calls a burn/redemption function on ExManager's exLST balance\n\ncontract HIP3StakingManager {\n    mapping(address => uint256) public deposits;  // HYPE deposits\n    uint256 public totalReserves;  // Total HYPE locked\n    \n    function stake() external payable returns (uint256 kHYPEAmount) {\n        // Receive HYPE\n        deposits[msg.sender] += msg.value;\n        totalReserves += msg.value;\n        \n        // Return kHYPE amount\n        kHYPEAmount = msg.value;  // Simplified\n        return kHYPEAmount;\n    }\n    \n    // No function to redeem exLST for underlying HYPE\n    // ExManager's bond remains locked\n}\n",
      "relevance": "Shows that StakingManager has no redemption path for ExManager's exLST tokens after unwinding"
    },
    {
      "path": "src/interfaces/IExLST.sol",
      "content": "interface IExLST is IERC20 {\n    function mint(address to, uint256 amount) external;\n    function burn(uint256 amount) external;\n    function burnFrom(address account, uint256 amount) external;\n}\n",
      "relevance": "Shows exLST has burn functionality but ExManager never calls it to recover the bond"
    }
  ],
  "call_flow": "Operator.bond() → ExManager receives HYPE → stakes with StakingManager → exLST minted to ExManager → operator.unwind() → protocol wound down → no mechanism to burn exLST and recover HYPE → bonds locked forever",
  "context_hint": "This vulnerability stems from a mismatch between the bond mechanism design and the unwinding lifecycle. The protocol correctly prevents the operator from accessing the bond during normal operations by minting exLST to the ExManager contract instead of the operator. However, it fails to provide a redemption path when the contract unwinds and ExManager is no longer needed. The fix requires adding a recovery function that only works in WOUND_DOWN phase.",
  "is_vulnerable": true,
  "expert_notes": "This is a critical economic vulnerability in a protocol where operators must post significant bonds. In the permissioned version, the bond is 'relatively small', but the permissionless version allows 10% of 500K HYPE = 50K HYPE bonds per operator. With multiple operators and multiple market instances, the total locked value could be substantial. The fix is straightforward: add a function that allows the operator to burn their exLST shares from ExManager after unwinding and claim the underlying HYPE."
},

{
  "id": "gs_spearbit_kinetiq_002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "spearbit",
  "source_report": "Kinetiq: Launch/Markets",
  "source_finding_id": "2.1",
  "report_url": "https://cantina.xyz/portfolio/1b09ea97-eaab-48f7-be91-5cf2fa323947",
  "github_repo_url": "https://github.com/kinetiq-research/launch",
  "contest_date": "2025-11-23",
  "severity": "medium",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  "finding_title": "Withdrawal Delay Can Be Bypassed When L1 Operations Processed More Than Once Per 24 Hours",
  "finding_description": "HyperCore enforces a 24-hour cooldown after staking before withdrawals from the same validator can be processed. The StakingManager processes L1 operations (withdrawals first, then deposits) via processL1Operations(), but there is no on-chain enforcement that this function is called at most once per 24 hours. If processL1Operations() is called more frequently than every 24 hours, a timing bypass can occur. When a withdrawal is queued, the original timestamp is recorded. If the L1 operation fails and is retried days later, the original queue timestamp is never updated. This allows users to confirm withdrawals before the full 7-day delay has passed from the actual L1 processing completion, bypassing the intended withdrawal delay mechanism.",
  "attack_scenario": "1. User queues a withdrawal at T=0 seconds (block.timestamp = 0)\n2. Operator calls processL1Operations() at T=0 to send withdrawal to L1\n3. L1 withdrawal fails because a deposit was made within last 24 hours on the validator\n4. Operator retries withdrawal via queueL1Operation() at T=6 days (block.timestamp = 518400)\n5. This time withdrawal succeeds on L1 (24+ hours have passed since deposit)\n6. User calls confirmWithdrawal() at T=7 days (block.timestamp = 604800)\n7. confirmWithdrawal() checks: block.timestamp < request.timestamp + withdrawalDelay\n8. Actual check: 604800 < 0 + 604800 = false (check passes, withdrawal allowed)\n9. But actual L1 processing occurred at T=6 days, only 1 day ago\n10. User can withdraw before full 7-day delay since actual L1 processing\n11. Funds may not be fully available/settled on L1 yet\n12. User receives HYPE that isn't fully settled",
  "fix_description": "Add on-chain cooldown enforcement for processL1Operations() to ensure it is called at most once per 24 hours. Implementation options: (1) Track lastProcessTime timestamp and require: require(block.timestamp >= lastProcessTime + 24 hours, \"Must wait 24 hours\"). (2) Alternatively, update the withdrawal request timestamp when L1 operations are retried: request.timestamp = max(request.timestamp, lastRetryTime). This ensures the withdrawal delay is calculated from the actual L1 operation time, not the original queue time. Preferred solution (option 1): function processL1Operations() external onlyOperator { require(block.timestamp >= lastL1ProcessTime + 24 hours, \"Process cooldown not met\"); lastL1ProcessTime = block.timestamp; // Process withdrawals and deposits // ... }",
  "primary_file": {
    "path": "src/EXManager.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nstruct WithdrawalRequest {\n    address recipient;\n    uint256 shares;\n    uint256 timestamp;  // Original queue time\n    uint256 amount;     // HYPE amount\n}\n\ncontract EXManager {\n    mapping(uint256 => WithdrawalRequest) public withdrawals;\n    uint256 public withdrawalDelay = 7 days;\n    \n    // VULNERABLE: No cooldown enforcement on L1 operation processing\n    // Operator can call this multiple times per 24 hours\n    function processL1Operations() external onlyOperator {\n        // Send pending withdrawals to L1\n        // Some may fail (e.g., recent deposit constraint)\n        _processWithdrawals();\n        \n        // Send pending deposits to L1\n        _processDeposits();\n    }\n    \n    function queueWithdrawal(uint256 shares) external {\n        withdrawals[nextId] = WithdrawalRequest({\n            recipient: msg.sender,\n            shares: shares,\n            timestamp: block.timestamp,  // Record queue time\n            amount: 0\n        });\n        nextId++;\n    }\n    \n    // VULNERABLE: Uses original timestamp, doesn't account for L1 operation delay\n    function confirmWithdrawal(uint256 requestId) external {\n        WithdrawalRequest storage req = withdrawals[requestId];\n        \n        // Check withdrawal delay from ORIGINAL QUEUE TIME\n        // VULNERABLE: If L1 operation was delayed and retried,\n        // actual L1 processing may be much later than queue time\n        require(\n            block.timestamp >= req.timestamp + withdrawalDelay,\n            \"Withdrawal delay not met\"\n        );\n        \n        // Process withdrawal\n        _completeWithdrawal(requestId);\n    }\n    \n    // VULNERABLE SCENARIO:\n    // T=0:   User calls queueWithdrawal(), req.timestamp = 0\n    // T=0:   Operator calls processL1Operations()\n    //        L1 withdrawal fails (recent deposit constraint)\n    // T=6d:  Operator retries with queueL1Operation()\n    //        L1 withdrawal succeeds\n    // T=7d:  User calls confirmWithdrawal()\n    //        Check: 7d >= 0 + 7d = true (passes)\n    //        But actual L1 processing was at T=6d, only 1 day ago!\n    \n    function _processWithdrawals() private {\n        // Process queued withdrawals\n        // May fail on L1 if constraints not met\n    }\n    \n    function _processDeposits() private {\n        // Process queued deposits\n    }\n    \n    function _completeWithdrawal(uint256 requestId) private {\n        // Complete the withdrawal\n    }\n}\n",
    "vulnerable_lines": [27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
    "vulnerable_functions": ["processL1Operations", "confirmWithdrawal"]
  },
  "context_files": [
    {
      "path": "src/interfaces/IStakingManager.sol",
      "content": "// HyperCore constraints on withdrawal timing\n// - 24-hour cooldown after staking/depositing before withdrawals can be processed\n// - 7-day settlement period for withdrawn funds to be available on L1\n\ninterface IStakingManager {\n    // Process L1 operations (withdrawals and deposits)\n    // Current implementation has NO COOLDOWN ENFORCEMENT\n    // Can be called multiple times per day\n    function processL1Operations() external;\n    \n    // Retry failed L1 operation\n    // Allows retrying failed withdrawals when constraints are met\n    function queueL1Operation(uint256 validatorId, uint256 amount) external;\n}\n",
      "relevance": "Shows that L1 operations can be retried multiple times without timing constraints"
    }
  ],
  "call_flow": "User.queueWithdrawal(T=0) → Operator.processL1Operations(T=0, fails) → Operator.queueL1Operation(T=6days, succeeds) → User.confirmWithdrawal(T=7days) → check passes with original T=0 → withdrawal allowed before 7 days from actual L1 processing",
  "context_hint": "This vulnerability exploits the gap between the intended 7-day settlement delay and the actual timing of L1 operations. HyperCore enforces the 24-hour constraint at the L1 level, but the L2 contract has no mechanism to track or enforce this constraint on-chain. The withdrawal delay check uses the original queue timestamp, which doesn't account for retries that may happen days later. The fix requires either enforcing a cooldown on processL1Operations() or updating withdrawal timestamps when operations are retried.",
  "is_vulnerable": true,
  "expert_notes": "The likelihood is rated as Low because operators are trusted and expected to follow operational discipline. However, the scenario becomes more likely if: (1) L1 congestion causes frequent operation failures, (2) Multiple operators process operations independently, (3) Automated systems retry without proper delays. The impact is High because users can confirm withdrawals before funds are fully settled on L1, potentially receiving unsettled assets. The fix is straightforward: add a cooldown check to processL1Operations() or update withdrawal timestamps on retries."
}]
