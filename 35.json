[
  {
    "id": "gs_trailofbits_radius_TOB-RADIUS-1",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "trailofbits",
    "source_report": "Radius Technology EVMAuth Security Assessment",
    "source_finding_id": "TOB-RADIUS-1",
    "report_url": "https://github.com/trailofbits/publications/blob/master/reviews/EVMAuth.pdf",
    "github_repo_url": "https://github.com/evmauth/evmauth-core",
    "contest_date": "2025-08-04",
    "severity": "high",
    "vulnerability_type": "denial_of_service",
    "difficulty_tier": 1,
    "context_level": "single_file",
    "finding_title": "Incorrect account assignment in token burning logic",
    "finding_description": "The token burning logic incorrectly assigns the wrong account address when burning tokens. When tokens are being burned, the code incorrectly assigns address _account = to instead of using the from address, causing the contract to attempt burning tokens from the zero address. The _update function is responsible for handling token minting, burning, and transferring operations. When burning tokens, the logic should burn tokens from the from address (the token holder), but the current implementation incorrectly sets _account = to, which is address(0) (the zero address). This means that the contract attempts to burn tokens from the zero address instead of the actual token holder, which will fail since the zero address has no tokens to burn.",
    "attack_scenario": "Alice has authentication tokens that grant access to a premium service. The service relies on an admin to manually burn tokens when Alice ends her subscription. When the admin attempts to burn Alice’s authentication tokens to revoke access, the burn transaction keeps reverting. This means Alice’s authentication tokens remain in their account even after the admin’s burn operation, allowing her to continue accessing premium services she should no longer have access to.",
    "fix_description": "Short term, correct the account assignment in the burning logic in the _update function to use 'from' instead of 'to'. Long term, implement comprehensive unit tests that cover all token operations (mint, burn, transfer) with various edge cases, including burning tokens from different accounts and with different token IDs.",
    "primary_file": {
      "path": "src/base/EVMAuthExpiringERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract EVMAuthExpiringERC1155 is ERC1155 {\n    struct Group {\n        uint256 balance;\n        uint256 expiresAt;\n    }\n\n    mapping(address => mapping(uint256 => Group[])) private _group;\n\n    event ExpiredTokensBurned(address indexed account, uint256 indexed id, uint256 amount);\n\n    constructor() ERC1155(\"\") {}\n\n    function _update(address from, address to, uint256 _id, uint256 _amount) internal virtual override {\n        // ... other logic\n\n        // Burning\n        if (to == address(0)) {\n            // VULNERABILITY: Incorrectly assigns 'to' (address(0)) instead of 'from' (the holder)\n            address _account = to; \n            _burnGroupBalances(_account, _id, _amount);\n            _pruneGroups(_account, _id);\n        }\n\n        super._update(from, to, _id, _amount);\n    }\n\n    function _pruneGroups(address account, uint256 id) internal {\n        // ... implementation from TOB-RADIUS-2\n    }\n\n    function _burnGroupBalances(address account, uint256 id, uint256 amount) internal {\n        // ... implementation from TOB-RADIUS-4\n    }\n\n    function _transferGroups(address from, address to, uint256 id, uint256 amount) internal {\n        // ... implementation from TOB-RADIUS-3\n    }\n\n    function _upsertGroup(address account, uint256 id, uint256 amount, uint256 expiresAt) internal {\n        // ... implementation from TOB-RADIUS-5\n    }\n}\n",
      "vulnerable_lines": [
        20,
        21,
        22
      ],
      "vulnerable_functions": ["_update"]
    },
    "context_files": [],
    "call_flow": "Admin.burn(holder, id, amount) -> ERC1155._burn() -> EVMAuthExpiringERC1155._update(holder, address(0), id, amount) -> Incorrect logic sets _account = address(0) -> _burnGroupBalances(address(0), id, amount) -> Transaction reverts as address(0) has no tokens.",
    "context_hint": "The core issue is a simple variable assignment error in the burn path of the `_update` function. The logic mistakenly uses the `to` address (which is `address(0)` for burns) instead of the `from` address (the actual token holder). This causes all burn operations to fail, effectively preventing token revocation.",
    "is_vulnerable": true,
    "expert_notes": "This is a critical but straightforward bug that should have been caught by basic unit testing of the burn functionality. It highlights a gap in test coverage for core ERC1155 operations. The fix is a one-line change, but the impact is high as it breaks a fundamental lifecycle feature of the token."
  },
  {
    "id": "gs_trailofbits_radius_TOB-RADIUS-2",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "trailofbits",
    "source_report": "Radius Technology EVMAuth Security Assessment",
    "source_finding_id": "TOB-RADIUS-2",
    "report_url": "https://github.com/trailofbits/publications/blob/master/reviews/EVMAuth.pdf",
    "github_repo_url": "https://github.com/evmauth/evmauth-core",
    "contest_date": "2025-08-04",
    "severity": "high",
    "vulnerability_type": "data_validation",
    "difficulty_tier": 1,
    "context_level": "single_file",
    "finding_title": "Expired token groups not synchronized with ERC1155 balance tracking",
    "finding_description": "The _pruneGroups function removes expired token groups from the custom group tracking system but fails to update the underlying ERC1155 balance tracking. This creates a data inconsistency where expired tokens can still be transferred despite being removed from the expiration tracking system. The contract maintains two separate balance tracking systems: the standard ERC1155 _balances mapping and a custom _group array system for expiration management. When tokens expire, the _pruneGroups function correctly removes expired groups from the _group array and emits an ExpiredTokensBurned event, but it does not call the parent contract's burn function to update the ERC1155 balance tracking. This means that the underlying ERC1155 balance remains unchanged, allowing expired tokens to be transferred to other addresses.",
    "attack_scenario": "Alice has 100 authentication tokens with a 60-second expiration time. After the tokens expire, any operation triggers _pruneGroups, which correctly removes the expired token groups from the custom array. However, the underlying ERC1155 balance tracking still shows 100 tokens. Alice can then transfer 50 of these ‘expired’ tokens to Bob. After the transfer, both Alice and Bob have 50 tokens in their ERC1155 balance, but the group tracking system (which determines validity) shows 0 tokens for both accounts.",
    "fix_description": "Modify the _pruneGroups function to call the parent contract’s burn function (_burn) when expired tokens are detected. This ensures that both the custom group array and the canonical ERC1155 balance are synchronized. The amount to burn should be the 'expiredAmount' calculated in the function.",
    "primary_file": {
      "path": "src/base/EVMAuthExpiringERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract EVMAuthExpiringERC1155 is ERC1155 {\n    struct Group {\n        uint256 balance;\n        uint256 expiresAt;\n    }\n\n    mapping(address => mapping(uint256 => Group[])) private _group;\n\n    event ExpiredTokensBurned(address indexed account, uint256 indexed id, uint256 amount);\n\n    constructor() ERC1155(\"\") {}\n\n    function _pruneGroups(address account, uint256 id) internal {\n        Group[] storage groups = _group[account][id];\n        uint256 _now = block.timestamp;\n        uint256 index = 0;\n        uint256 expiredAmount = 0;\n\n        for (uint256 i = 0; i < groups.length; i++) {\n            bool isValid = groups[i].balance > 0 && groups[i].expiresAt > _now;\n            if (isValid) {\n                if (i != index) {\n                    groups[index] = groups[i];\n                }\n                index++;\n            } else {\n                expiredAmount += groups[i].balance;\n            }\n        }\n\n        while (groups.length > index) {\n            groups.pop();\n        }\n\n        if (expiredAmount > 0) {\n            emit ExpiredTokensBurned(account, id, expiredAmount);\n            // VULNERABILITY: The ERC1155 balance is not updated here.\n            // A call to _burn(account, id, expiredAmount) is missing.\n        }\n    }\n    // ... other functions\n}\n",
      "vulnerable_lines": [
        40,
        41,
        42,
        43
      ],
      "vulnerable_functions": ["_pruneGroups"]
    },
    "context_files": [],
    "call_flow": "Any operation on an account with expired tokens -> _pruneGroups() is called -> Expired groups are removed from the '_group' array -> ExpiredTokensBurned event is emitted -> Function returns without calling _burn() -> ERC1155 balance remains unchanged -> User can transfer expired tokens.",
    "context_hint": "The contract uses a dual-accounting system: the standard ERC1155 `_balances` and a custom `_group` array for expirations. The `_pruneGroups` function cleans up the custom array but forgets to update the canonical ERC1155 balance. This desynchronization means tokens that the system considers 'expired' and 'burned' (an event is even emitted) are actually still owned by the user according to the ERC1155 standard, making them transferable.",
    "is_vulnerable": true,
    "expert_notes": "This bug highlights the danger of dual-accounting systems. When custom logic is built on top of a standard like ERC1155, it's critical that all state transitions are synchronized with the standard's state. Forgetting to call the underlying `_burn` function while removing tokens from the custom tracking system is a classic integration bug. The presence of the `ExpiredTokensBurned` event makes the bug even more subtle, as it gives the appearance of a successful burn."
  },
  {
    "id": "gs_trailofbits_radius_TOB-RADIUS-3",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "trailofbits",
    "source_report": "Radius Technology EVMAuth Security Assessment",
    "source_finding_id": "TOB-RADIUS-3",
    "report_url": "https://github.com/trailofbits/publications/blob/master/reviews/EVMAuth.pdf",
    "github_repo_url": "https://github.com/evmauth/evmauth-core",
    "contest_date": "2025-08-04",
    "severity": "high",
    "vulnerability_type": "data_validation",
    "difficulty_tier": 1,
    "context_level": "single_file",
    "finding_title": "Missing debt validation in group transfer function",
    "finding_description": "The _transferGroups function fails to complete group transfers when expired tokens are present, creating an inconsistency between the ERC1155 balance tracking and the group array tracking. The function iterates through the sender’s token groups in FIFO order to transfer the requested amount. However, it skips over expired token groups without accounting for them in the transfer calculation. When the loop completes, there is no verification that the 'debt' variable has reached zero, meaning that the transfer may be incomplete. This creates a mismatch where the ERC1155 balance tracking correctly reflects the transfer, but the group arrays contain inconsistent data.",
    "attack_scenario": "Alice has five authentication tokens, including two expired tokens and three valid tokens. Alice attempts to transfer four tokens to Bob. The ERC1155 `_update` function correctly transfers 4 tokens, updating the main balances. However, the subsequent call to `_transferGroups` iterates Alice's groups, skips the two expired ones, and only finds three valid tokens to transfer. It transfers the three valid groups to Bob, `debt` remains at 1, and the function exits. The result is that Bob's ERC1155 balance is 4, but his group balance is only 3, while Alice's ERC1155 balance is 1, and her group balance is 0. The state is now inconsistent.",
    "fix_description": "Add a check at the end of the _transferGroups function to verify that the 'debt' variable equals zero. If it does not, the function should revert the transaction to prevent partial transfers and state inconsistencies. For example: `require(debt == 0, \"Incomplete transfer due to expired tokens\");`",
    "primary_file": {
      "path": "src/base/EVMAuthExpiringERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract EVMAuthExpiringERC1155 is ERC1155 {\n    struct Group {\n        uint256 balance;\n        uint256 expiresAt;\n    }\n\n    mapping(address => mapping(uint256 => Group[])) private _group;\n\n    constructor() ERC1155(\"\") {}\n\n    function _transferGroups(address from, address to, uint256 id, uint256 amount) internal {\n        if (from == to || amount == 0) return;\n        Group[] storage groups = _group[from][id];\n        uint256 _now = block.timestamp;\n        uint256 debt = amount;\n\n        for (uint256 i = 0; i < groups.length && debt > 0; i++) {\n            if (groups[i].expiresAt <= _now || groups[i].balance == 0) {\n                continue;\n            }\n            if (groups[i].balance > debt) {\n                _upsertGroup(to, id, debt, groups[i].expiresAt);\n                groups[i].balance -= debt;\n                debt = 0;\n            } else {\n                _upsertGroup(to, id, groups[i].balance, groups[i].expiresAt);\n                debt -= groups[i].balance;\n                groups[i].balance = 0;\n            }\n        }\n\n        // VULNERABILITY: No check to ensure debt is 0. If there were expired tokens, \n        // the loop might finish with debt > 0, leading to a partial group transfer.\n\n        _pruneGroups(from, id);\n    }\n\n    function _pruneGroups(address account, uint256 id) internal { /* ... */ }\n    function _upsertGroup(address account, uint256 id, uint256 amount, uint256 expiresAt) internal { /* ... */ }\n}\n",
      "vulnerable_lines": [
        37,
        38,
        39
      ],
      "vulnerable_functions": ["_transferGroups"]
    },
    "context_files": [],
    "call_flow": "User calls safeTransferFrom() -> _update() calls _transferGroups() -> _transferGroups() skips expired tokens -> Loop finishes with 'debt' > 0 -> Function exits without error -> State becomes inconsistent.",
    "context_hint": "The `_transferGroups` function attempts to fulfill a transfer amount by iterating through a user's token groups. However, it skips any expired groups it finds. If there are expired groups mixed in, the function might not find enough *valid* tokens to fulfill the total transfer amount (`debt`). The function ends without ever checking if `debt` is zero. This leads to a partial transfer in the custom group system while the main ERC1155 transfer succeeds completely, causing state inconsistency.",
    "is_vulnerable": true,
    "expert_notes": "This flaw is common in systems that try to reconcile a canonical balance with a set of sub-balances (like time-locked tokens). The core mistake is assuming the sub-balances will always sum up to the canonical balance. When some sub-balances can become invalid (expire), the transfer logic must either fail completely or have a mechanism to handle the shortfall. Silently failing to transfer the full amount guarantees state divergence."
  },
  {
    "id": "gs_trailofbits_radius_TOB-RADIUS-4",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "trailofbits",
    "source_report": "Radius Technology EVMAuth Security Assessment",
    "source_finding_id": "TOB-RADIUS-4",
    "report_url": "https://github.com/trailofbits/publications/blob/master/reviews/EVMAuth.pdf",
    "github_repo_url": "https://github.com/evmauth/evmauth-core",
    "contest_date": "2025-08-04",
    "severity": "high",
    "vulnerability_type": "data_validation",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Missing debt validation in group burn function",
    "finding_description": "The _burnGroupBalances function fails to validate that the burn operation completes successfully when expired tokens are present, potentially creating inconsistencies between ERC1155 balance tracking and group array tracking. The function skips over expired token groups during burning but does not verify that the burn was completed successfully. The function iterates through the account’s token groups in FIFO order to burn the requested amount. However, it skips over expired token groups without accounting for them in the burn calculation. When the loop completes, there is no verification that the 'debt' variable has reached zero, meaning that the burn may be incomplete.",
    "attack_scenario": "Alice has five authentication tokens across two groups: Group A (3 tokens, expired) and Group B (2 tokens, valid). The token burner attempts to burn four of Alice’s tokens. The ERC1155 `_update` correctly processes a burn of 4 tokens, leaving Alice with an ERC1155 balance of 1. However, the subsequent call to `_burnGroupBalances` skips expired Group A and only finds the 2 valid tokens in Group B. It burns those 2 tokens, `debt` remains at 2, and the function exits without an error. The state is now inconsistent: Alice's ERC1155 balance is 1, but her group balance is 0.",
    "fix_description": "Add a check at the end of the _burnGroupBalances function to verify that the 'debt' variable equals zero. If it does not, the function should revert the transaction to ensure the burn operation is fully completed and prevent state inconsistencies. For example: `require(debt == 0, \"Incomplete burn due to expired tokens\");`",
    "primary_file": {
      "path": "src/base/EVMAuthExpiringERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract EVMAuthExpiringERC1155 is ERC1155 {\n    struct Group {\n        uint256 balance;\n        uint256 expiresAt;\n    }\n\n    mapping(address => mapping(uint256 => Group[])) private _group;\n\n    constructor() ERC1155(\"\") {}\n\n    function _burnGroupBalances(address account, uint256 id, uint256 amount) internal {\n        Group[] storage groups = _group[account][id];\n        uint256 _now = block.timestamp;\n        uint256 debt = amount;\n        uint256 i = 0;\n\n        while (i < groups.length && debt > 0) {\n            if (groups[i].expiresAt <= _now) {\n                i++;\n                continue;\n            }\n            if (groups[i].balance > debt) {\n                groups[i].balance -= debt;\n                debt = 0;\n            } else {\n                debt -= groups[i].balance;\n                groups[i].balance = 0;\n            }\n            i++;\n        }\n\n        // VULNERABILITY: No check to ensure debt is 0. If there were expired tokens,\n        // the loop might finish with debt > 0, leading to a partial group burn.\n    }\n    // ... other functions\n}\n",
      "vulnerable_lines": [
        35,
        36
      ],
      "vulnerable_functions": ["_burnGroupBalances"]
    },
    "context_files": [],
    "call_flow": "User calls burn() -> _update() calls _burnGroupBalances() -> _burnGroupBalances() skips expired tokens -> Loop finishes with 'debt' > 0 -> Function exits without error -> State becomes inconsistent.",
    "context_hint": "This is the same logical flaw as in the transfer function (TOB-RADIUS-3), but applied to burning. The `_burnGroupBalances` function iterates through token groups to fulfill a burn amount (`debt`), but it skips expired groups. If it encounters expired groups, it may not burn the full requested amount. It exits without verifying that `debt` has been reduced to zero, leading to a partial burn in the group system while the main ERC1155 burn succeeds, desynchronizing the two accounting systems.",
    "is_vulnerable": true,
    "expert_notes": "This finding, combined with TOB-RADIUS-3, points to a systemic issue in how the contract handles its dual-accounting system in the presence of invalid (expired) sub-balances. The failure to validate the outcome of an operation (i.e., checking if `debt == 0`) is a recurring pattern that should be addressed throughout the contract."
  },
  {
    "id": "gs_trailofbits_radius_TOB-RADIUS-5",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "trailofbits",
    "source_report": "Radius Technology EVMAuth Security Assessment",
    "source_finding_id": "TOB-RADIUS-5",
    "report_url": "https://github.com/trailofbits/publications/blob/master/reviews/EVMAuth.pdf",
    "github_repo_url": "https://github.com/evmauth/evmauth-core",
    "contest_date": "2025-08-04",
    "severity": "medium",
    "vulnerability_type": "denial_of_service",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Unbounded group array growth causes gas limit exceeded",
    "finding_description": "The contract’s group array management system can cause gas limit issues when users have many token purchases with different expiration times. Each token purchase creates a new Group in the _group[account][tokenId] array, and functions that iterate through this array can exceed the block gas limit when the array becomes too large. The contract maintains a _group array for each account and token ID to track token batches with different expiration times. When users make frequent token purchases, this creates a large array that must be iterated through during operations like balanceOf, _transferGroups, and _validGroups. Additionally, the _upsertGroup function performs expensive array insertion operations that shift elements to maintain expiration order. As the array grows, these operations consume increasing amounts of gas, eventually exceeding the block gas limit and making the contract unusable for affected users.",
    "attack_scenario": "Bob intentionally transfers small amounts of tokens with different expiration times to Alice’s address 2,000 times. This creates 2,000 groups in her `_group[alice][tokenId]` array. When Alice attempts to transfer her tokens, the `_transferGroups` function must iterate through all 2,000 groups. The gas cost of this iteration, combined with the expensive array shifting in `_upsertGroup` for the recipient, exceeds the block gas limit. The transaction fails, preventing Alice from transferring, burning, or even checking her token balance. This effectively locks Alice’s tokens.",
    "fix_description": "Short term, implement a maximum group array size limit to prevent unbounded growth and add pagination or batching mechanisms for operations that iterate through large group arrays. Long term, redesign the token expiration management system to use more gas-efficient data structures that avoid linear iteration, such as a mapping or a linked list, or by bucketing tokens into time slots (e.g., daily or weekly buckets) to reduce the number of distinct groups.",
    "primary_file": {
      "path": "src/base/EVMAuthExpiringERC1155.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\n\ncontract EVMAuthExpiringERC1155 is ERC1155 {\n    struct Group {\n        uint256 balance;\n        uint256 expiresAt;\n    }\n\n    mapping(address => mapping(uint256 => Group[])) private _group;\n\n    constructor() ERC1155(\"\") {}\n\n    function _upsertGroup(address account, uint256 id, uint256 amount, uint256 expiresAt) internal {\n        Group[] storage groups = _group[account][id];\n        uint256 insertIndex = groups.length;\n\n        // VULNERABILITY: O(n) loop to find insertion point\n        for (uint256 i = 0; i < groups.length; i++) {\n            if (groups[i].expiresAt > expiresAt) {\n                insertIndex = i;\n                break;\n            } else if (groups[i].expiresAt == expiresAt) {\n                groups[i].balance += amount;\n                return;\n            }\n        }\n\n        if (insertIndex == groups.length) {\n            groups.push(Group({balance: amount, expiresAt: expiresAt}));\n            return;\n        }\n\n        // VULNERABILITY: O(n) operation to shift array elements\n        groups.push(Group({balance: 0, expiresAt: 0}));\n        for (uint256 i = groups.length - 1; i > insertIndex; i--) {\n            groups[i] = groups[i - 1];\n        }\n        groups[insertIndex] = Group({balance: amount, expiresAt: expiresAt});\n    }\n\n    // Other functions like _transferGroups and balanceOf also loop through this unbounded array,\n    // contributing to the DoS vector.\n}\n",
      "vulnerable_lines": [
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38
      ],
      "vulnerable_functions": ["_upsertGroup", "_transferGroups", "balanceOf"]
    },
    "context_files": [],
    "call_flow": "Attacker spams victim with many small transfers with unique expiration dates -> Victim's '_group' array grows very large -> Victim attempts a transfer -> _transferGroups() iterates through the large array -> Transaction runs out of gas and reverts.",
    "context_hint": "The contract uses a dynamically-sized, sorted array (`_group`) to manage token expirations. Every new token purchase with a unique expiration time adds an element. The `_upsertGroup` function maintains sorted order by shifting array elements, which is an O(n) operation. Functions like `_transferGroups` and `balanceOf` also iterate this array. As the array grows, the gas cost of these operations increases linearly. An attacker can trivially spam an account with many small token purchases, causing the gas cost to exceed the block gas limit, effectively locking the victim's funds.",
    "is_vulnerable": true,
    "expert_notes": "This is a classic unbounded loop/array DoS vector. Using a dynamic array for tracking a potentially large number of items that requires iteration in a single transaction is an anti-pattern on the EVM. The problem is exacerbated by the sorted insertion logic, which adds another O(n) operation. More suitable data structures for this problem include time-based buckets (e.g., grouping all tokens that expire in the same day/hour) or using a linked list, although the latter also has gas complexities. A hard cap on the number of groups per user is the most direct mitigation."
  }
]
