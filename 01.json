[{
  "id": "gs_quantstamp_startale_sta001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Startale Stablecoin Vaults",
  "source_finding_id": "STA-1",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  "severity": "high",
  "vulnerability_type": "economic_attack",
  "difficulty_tier": 4,
  "context_level": "cross_contract",
  "finding_title": "Leveraged TVL Manipulation via Sandwich Attack on distribute()",
  "finding_description": "The RewardRedistributor's distribute() function reads the sUSDSC vault's totalAssets() at execution time to calculate yield splits. An attacker can build a leveraged position in the sUSDSC vault using a lending pool (e.g., Aave-style), sandwich the distribute() transaction, and capture disproportionate yield while stealing from EarnVault users. The attack uses borrowed USDSC as collateral in recursive loops to artificially inflate sUSDSC's TVL, manipulating the yield distribution formula.",
  "attack_scenario": "1. Attacker detects operator's distribute() transaction in mempool\n2. Attacker frontruns with leverage loop (5 iterations): Deposit 1M USDSC → get 1M sUSDSC → borrow 900k USDSC. Deposit 900k → get 900k sUSDSC → borrow 810k. Continue until 4.095M total deposited using 3.685M borrowed + 1M original capital\n3. This inflates sUSDSC vault from 10M to 14.095M USDSC\n4. Operator's distribute() executes with manipulated TVL: Normal split would be toEarn=316,667 USDSC, toOn=633,333 USDSC. Manipulated split: toEarn=248,752 USDSC (lost 67,915), toOn=701,248 USDSC (gained 67,915). Attacker's 4.095M shares (29% of vault) capture 203,693 USDSC of inflated yield\n5. Attacker backruns: Redeem 4.095M shares for 4,298,693 USDSC, repay 3.685M loan (interest ~1.4 USDSC for 2 minutes), net profit 203,191 USDSC per attack\n6. Attack repeatable 6 times daily = 1.2M USDSC profit/day = 445M USDSC profit/year (44,493% APY)",
  "fix_description": "Implement snapshot-based TVL mechanism to prevent same-block manipulation. In RewardRedistributor.sol: (1) Add storage: uint256 public lastSUSDSCTVL; uint256 public lastSnapshotBlock; (2) Add function snapshotTVL() external onlyRole(OPERATOR_ROLE) { lastSUSDSCTVL = susdscVault.totalAssets(); lastSnapshotBlock = block.number; } (3) In distribute() require(lastSnapshotBlock == block.number - 1, 'Must snapshot in previous block') and use lastSUSDSCTVL instead of susdscVault.totalAssets() (4) Operator workflow: Call snapshotTVL() in block N, then call distribute() in block N+1. This forces attacker to hold leveraged position for minimum 1 full block (~12 seconds), making attack 100x more expensive (5) For defense-in-depth, add 1-hour withdrawal cooldown to sUSDSC vault and minimum time post-deposit during which funds cannot be withdrawn",
  "primary_file": {
    "path": "src/distributor/RewardRedistributor.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ninterface IMYieldToOne is IERC20 {\n    function claimYield() external returns (uint256);\n    function yieldRecipient() external view returns (address);\n}\n\ninterface IEarnVault {\n    function onYield(uint256 amount) external;\n}\n\ninterface IERC4626 {\n    function totalAssets() external view returns (uint256);\n    function onYield(uint256 amount) external;\n}\n\ncontract RewardRedistributor is AccessControl, ReentrancyGuard, Pausable {\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    \n    address private USDSC_ADDRESS;\n    address private treasury;\n    IEarnVault private earnVault;\n    IERC4626 private susdscVault;\n    \n    uint256 private constant RAY = 1e27;\n    uint256 private constant MAX_FEE_BPS = 10000;\n    uint256 private feeBps = 500;\n    \n    uint256 private carryEarn;\n    uint256 private carryOn;\n    \n    event Distributed(uint256 indexed blockNumber, uint256 grossYield, uint256 toEarn, uint256 toOn, uint256 toStartale);\n    \n    constructor(\n        address usdscAddress,\n        address treasuryAddr,\n        IEarnVault earnV,\n        IERC4626 sVault,\n        address admin,\n        address keeper\n    ) {\n        require(usdscAddress != address(0), \"Zero USDSC address\");\n        require(treasuryAddr != address(0), \"Zero treasury\");\n        require(address(earnV) != address(0), \"Zero earnVault\");\n        require(address(sVault) != address(0), \"Zero sUSDSCVault\");\n        require(admin != address(0), \"Zero admin\");\n        require(keeper != address(0), \"Zero keeper\");\n        \n        USDSC_ADDRESS = usdscAddress;\n        treasury = treasuryAddr;\n        earnVault = earnV;\n        susdscVault = sVault;\n        \n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(OPERATOR_ROLE, keeper);\n    }\n    \n    function distribute() external whenNotPaused onlyRole(OPERATOR_ROLE) nonReentrant {\n        uint256 balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this));\n        uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield();\n        uint256 gross = balanceBefore + minted;\n        \n        if (gross == 0) return;\n        \n        uint256 feeToStartale;\n        uint256 toEarn;\n        uint256 toOn;\n        uint256 toStartaleExtra;\n        uint256 sBase;\n        uint256 T_earn;\n        uint256 T_yield;\n        \n        (feeToStartale, toEarn, toOn, toStartaleExtra, sBase, T_earn, T_yield) = _calculateSplit(gross, true, false);\n        \n        if (feeToStartale > 0) {\n            IERC20(USDSC_ADDRESS).transfer(treasury, feeToStartale);\n        }\n        \n        if (toEarn > 0) {\n            IERC20(USDSC_ADDRESS).approve(address(earnVault), toEarn);\n            earnVault.onYield(toEarn);\n        }\n        \n        if (toOn > 0) {\n            IERC20(USDSC_ADDRESS).transfer(address(susdscVault), toOn);\n            susdscVault.onYield(toOn);\n        }\n        \n        if (toStartaleExtra > 0) {\n            IERC20(USDSC_ADDRESS).transfer(treasury, toStartaleExtra);\n        }\n        \n        emit Distributed(block.number, gross, toEarn, toOn, feeToStartale + toStartaleExtra);\n    }\n    \n    function _calculateSplit(\n        uint256 gross,\n        bool useCarries,\n        bool preview\n    ) internal returns (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra, uint256 sBase, uint256 T_earn, uint256 T_yield) {\n        feeToStartale = (gross * feeBps) / MAX_FEE_BPS;\n        uint256 net = gross - feeToStartale;\n        \n        T_earn = 2000000 * 1e18;\n        T_yield = susdscVault.totalAssets();\n        \n        uint256 SNow = IERC20(USDSC_ADDRESS).totalSupply();\n        sBase = SNow > gross ? SNow - gross : 0;\n        \n        uint256 S_base = sBase > 0 ? sBase : SNow;\n        \n        if (useCarries) {\n            uint256 numEarn = net * T_earn + carryEarn;\n            toEarn = numEarn / S_base;\n            carryEarn = numEarn % S_base;\n            \n            uint256 numOn = net * T_yield + carryOn;\n            toOn = numOn / S_base;\n            carryOn = numOn % S_base;\n        } else {\n            toEarn = (net * T_earn) / S_base;\n            toOn = (net * T_yield) / S_base;\n        }\n        \n        toStartaleExtra = net - (toEarn + toOn);\n        \n        return (feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield);\n    }\n    \n    function setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_treasury != address(0), \"Zero address\");\n        treasury = _treasury;\n    }\n    \n    function setFee(uint256 _feeBps) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_feeBps <= MAX_FEE_BPS, \"Fee too high\");\n        feeBps = _feeBps;\n    }\n}\n",
    "vulnerable_lines": [108, 109, 110, 113, 120, 143, 144, 145, 147, 148, 149, 155, 156, 157, 158, 159, 160, 161, 162],
    "vulnerable_functions": ["distribute", "_calculateSplit"]
  },
  "context_files": [
    {
      "path": "src/vaults/4626/SUSDSCVaultUpgradable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC4626/ERC4626.sol\";\n\ncontract SUSDSCVaultUpgradeable is ERC4626 {\n    constructor(IERC20 asset) ERC4626(asset) ERC20(\"sUSDSC\", \"sUSDSC\") {}\n    \n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n    \n    function onYield(uint256 amount) external {\n    }\n}\n",
      "relevance": "The sUSDSC vault's totalAssets() is read at execution time in distribute(), allowing same-block manipulation. No time-delayed snapshot is used."
    }
  ],
  "call_flow": "Attacker.detectMempool() → Attacker.frontRun() → Attacker.borrowAndDeposit() → inflate sUSDSC.totalAssets() → Operator.distribute() → RewardDistributor.distribute() reads spot TVL → manipulated yield split → Attacker.backRun() → Attacker.repayAndProfit()",
  "context_hint": "ERC4626 share accounting is fair - attacker gets correct shares at deposit and correct assets at redemption. The vulnerability exists because distribute() uses spot totalAssets() instead of a time-delayed snapshot. This is a sophisticated economic attack that requires understanding both lending pool mechanics and yield distribution formulas. The attacker can execute this profitably multiple times daily with modest capital due to Aave-style 90% LTV.",
  "is_vulnerable": true,
  "expert_notes": "This vulnerability is similar to the Curve donation attack but exploits the yield distribution mechanism rather than share accounting. The key insight is that RewardRedistributor trusts the sUSDSC vault's spot totalAssets() without considering that TVL can be manipulated within the same transaction via flashloans or multi-step leveraging. The fix requires understanding both ERC4626 mechanics and MEV attack vectors."
},

{
  "id": "gs_quantstamp_startale_sta002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Startale Stablecoin Vaults",
  "source_finding_id": "STA-2",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  "severity": "high",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  "finding_title": "Missing Boost Rewards Settlement During Deposit",
  "finding_description": "The deposit() and depositWithPermit() functions in EarnVaultUpgradeable call _settleRewards() for USDSC rewards but fail to call _settleBoost() before increasing the user's principal. This allows users to double-dip on boost rewards by depositing a second time without settling accrued boost index, causing the subsequent distributions to apply stale index deltas to increased principal amounts.",
  "attack_scenario": "1. User deposits 100k USDSC, receives 100k vault shares, userBoostIndex set to current globalBoostIndex (e.g., 1e18)\n2. Time passes, globalBoostIndex increases to 1.2e18 due to distributions\n3. User calls deposit(100k USDSC) again\n4. Vault calls _settleRewards() for USDSC yield (accrued correctly)\n5. Vault FAILS to call _settleBoost() - userBoostIndex still 1e18\n6. User's principal increased from 100k to 200k shares\n7. Next boost distribution: newYield = 200k * (1.2e18 - 1e18) / 1e18 = 200k * 0.2 = 40k boost tokens\n8. Should have been: settled 100k * 0.2 = 20k, then new principal has 0 accrual = 20k total\n9. User receives 40k instead of 20k, gaining 20k unearned boost rewards\n10. Repeated deposits compound the over-allocation until vault reserves are depleted",
  "fix_description": "Add _settleBoost() call before principal modification in both deposit functions. The correct pattern (shown in withdraw) is: (1) Call _settleRewards() for USDSC (2) Call _settleBoost() for external tokens (3) Then modify principal (4) Then emit events. Code fix: Add 'earnVault._settleBoost(msg.sender);' after line 36 in deposit() and line 64 in depositWithPermit() before principal is increased. This ensures boost index deltas are captured with old principal before new shares are minted.",
  "primary_file": {
    "path": "src/vaults/earn/EarnVaultUpgradeable.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\ninterface IBoostRewardsLib {\n    function settleBoostReward(address user) external;\n}\n\ncontract EarnVaultUpgradeable is ERC20Upgradeable, ReentrancyGuardUpgradeable {\n    address private underlyingAsset;\n    IBoostRewardsLib private boostLib;\n    \n    mapping(address => uint256) public userPrincipal;\n    \n    function deposit(uint256 assets, address receiver) public nonReentrant returns (uint256) {\n        require(assets > 0, \"Zero assets\");\n        require(receiver != address(0), \"Zero receiver\");\n        \n        _settleRewards(receiver);\n        // VULNERABLE: Missing _settleBoost() call here\n        // userBoostIndex is not updated before principal increase\n        \n        uint256 shares = convertToShares(assets);\n        userPrincipal[receiver] += assets;\n        _mint(receiver, shares);\n        \n        IERC20(underlyingAsset).transferFrom(msg.sender, address(this), assets);\n        \n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n    \n    function depositWithPermit(\n        uint256 assets,\n        address receiver,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public returns (uint256) {\n        require(assets > 0, \"Zero assets\");\n        require(receiver != address(0), \"Zero receiver\");\n        \n        IERC20Permit(underlyingAsset).permit(\n            msg.sender,\n            address(this),\n            assets,\n            deadline,\n            v,\n            r,\n            s\n        );\n        \n        _settleRewards(receiver);\n        // VULNERABLE: Missing _settleBoost() call here\n        // Same issue as deposit() - boost index not updated\n        \n        uint256 shares = convertToShares(assets);\n        userPrincipal[receiver] += assets;\n        _mint(receiver, shares);\n        \n        IERC20(underlyingAsset).transferFrom(msg.sender, address(this), assets);\n        \n        emit Deposit(msg.sender, receiver, assets, shares);\n        return shares;\n    }\n    \n    function withdraw(uint256 assets, address receiver, address owner) public nonReentrant returns (uint256) {\n        require(assets > 0, \"Zero assets\");\n        \n        _settleRewards(owner);\n        _settleBoost(owner);  // CORRECT: Settlement happens before state change\n        \n        uint256 shares = convertToShares(assets);\n        userPrincipal[owner] -= assets;\n        _burn(owner, shares);\n        \n        IERC20(underlyingAsset).transfer(receiver, assets);\n        \n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n        return shares;\n    }\n    \n    function _settleRewards(address user) internal {\n        // Update USDSC reward index\n    }\n    \n    function _settleBoost(address user) internal {\n        boostLib.settleBoostReward(user);\n    }\n    \n    function convertToShares(uint256 assets) public view returns (uint256) {\n        return assets;\n    }\n}\n",
    "vulnerable_lines": [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 62, 63, 64, 65, 66, 67, 68, 69],
    "vulnerable_functions": ["deposit", "depositWithPermit"]
  },
  "context_files": [
    {
      "path": "src/vaults/earn/BoostRewardsLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract BoostRewardsLib {\n    uint256 private constant RAY = 1e27;\n    \n    mapping(address => uint256) public userBoostIndex;\n    uint256 public globalBoostIndex;\n    \n    function settleBoostReward(address user) external {\n        uint256 delta = globalBoostIndex - userBoostIndex[user];\n        if (delta > 0) {\n            userBoostIndex[user] = globalBoostIndex;\n        }\n    }\n    \n    function distributeBoostReward(uint256 amount) external {\n        globalBoostIndex += (amount * RAY) / totalPrincipal();\n    }\n    \n    function totalPrincipal() public view returns (uint256) {\n        return 0;\n    }\n}\n",
      "relevance": "Contains boost index accounting. Settlement captures the delta between user's last recorded index and global index. If settlement doesn't occur before principal increases, the delta applies to a larger base."
    }
  ],
  "call_flow": "User.deposit() → EarnVault.deposit() → _settleRewards() (✓) but NOT _settleBoost() (✗) → Principal increased → Next distribution → BoostRewardsLib.distributeBoostReward() → Over-allocation occurs",
  "context_hint": "Index-based reward accounting requires settlement at all state-change points. The EarnVault correctly settles USDSC rewards but misses boost settlement. The withdraw() function shows the correct pattern - it calls both _settleRewards() and _settleBoost() before modifying principal. This is likely a refactoring oversight where boost reward support was added to an existing pattern without updating all deposit paths.",
  "is_vulnerable": true,
  "expert_notes": "Index-based reward systems (similar to Aave's index updates) must be settled before any operation that changes a user's balance. This is a subtle but critical invariant. The fact that withdraw() correctly calls _settleBoost() while deposit() doesn't suggests this was introduced during a code merge or refactoring. Good security practice would be to enforce this invariant with comments or asserts in critical functions."
},

{
  "id": "gs_quantstamp_startale_sta003",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Startale Stablecoin Vaults",
  "source_finding_id": "STA-3",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  "severity": "medium",
  "vulnerability_type": "rounding_error",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "finding_title": "Incorrect S_base Calculation with Donations",
  "finding_description": "The _calculateSplit() function includes accidental token transfers (donations) in the gross amount used to compute S_base (supply basis). When the contract holds a balance before distribute() is called, this balance is included in the gross calculation, causing S_base to be understated and yield to be misdistributed between vaults and treasury.",
  "attack_scenario": "1. Someone accidentally sends 1M USDSC directly to RewardRedistributor contract (common user error)\n2. Operator calls distribute(), which claims 5M USDSC yield from M0\n3. balanceBefore = 1M (the donation), minted = 5M, gross = 6M\n4. _calculateSplit() receives gross = 6M\n5. S_base calculation: SNow = 1,050,000,000 (1.05B USDSC total supply), sBase = 1.05B - 6M = 1.044B\n6. Yield split using S_base = 1.044B instead of correct 1.05B\n7. Distribution: toEarn = (5M * 2M) / 1.044B = 9.54M (should be 9.52M)\n8. Distribution: toOn = (5M * 1.05B) / 1.044B = 5.02B (should be 5B)\n9. toStartaleExtra gets 0 instead of 19.2k\n10. Vault profit: 19.2k USDSC lost per donation\n11. With $1M donation: ~190 USDSC impact. With multiple donations accumulating: 157k+ USDSC lost per distribution cycle",
  "fix_description": "Use minted yield only in S_base calculation, not balanceBefore. Change line 110 from 'uint256 gross = balanceBefore + minted;' to 'uint256 yieldAmount = minted;' and in _calculateSplit, calculate S_base as 'sBase = SNow - yieldAmount' instead of 'SNow - gross'. Also add recoverDonations() function: function recoverDonations() external onlyRole(ADMIN_ROLE) { uint256 balance = IERC20(USDSC_ADDRESS).balanceOf(address(this)); if (balance > 0) IERC20(USDSC_ADDRESS).transfer(treasury, balance); } This allows manual recovery of unexpected transfers without affecting distribution formulas.",
  "primary_file": {
    "path": "src/distributor/RewardRedistributor.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ninterface IMYieldToOne is IERC20 {\n    function claimYield() external returns (uint256);\n}\n\ncontract RewardRedistributor is AccessControl, ReentrancyGuard, Pausable {\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    \n    address private USDSC_ADDRESS;\n    address private treasury;\n    \n    uint256 private constant MAX_FEE_BPS = 10000;\n    uint256 private feeBps = 500;\n    \n    function distribute() external onlyRole(OPERATOR_ROLE) nonReentrant {\n        uint256 balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this));\n        uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield();\n        uint256 gross = balanceBefore + minted;  // VULNERABLE: includes donations\n        \n        (uint256 fee, uint256 toEarn, uint256 toOn, uint256 extra) = _calculateSplit(gross);\n        \n        IERC20(USDSC_ADDRESS).transfer(treasury, fee + extra);\n    }\n    \n    function _calculateSplit(uint256 gross) internal view returns (uint256 fee, uint256 toEarn, uint256 toOn, uint256 extra) {\n        fee = (gross * feeBps) / MAX_FEE_BPS;\n        uint256 net = gross - fee;\n        \n        uint256 SNow = IERC20(USDSC_ADDRESS).totalSupply();\n        uint256 sBase = SNow > gross ? SNow - gross : 0;  // VULNERABLE: Understates S_base when donations present\n        \n        uint256 S_base = sBase > 0 ? sBase : SNow;\n        \n        toEarn = (net * 2000000e18) / S_base;\n        toOn = (net * (SNow - 2000000e18)) / S_base;\n        extra = net - (toEarn + toOn);\n    }\n}\n",
    "vulnerable_lines": [106, 107, 108, 109, 110, 145, 146, 147, 148],
    "vulnerable_functions": ["distribute", "_calculateSplit"]
  },
  "context_files": [],
  "call_flow": "Accidental.transfer(USDSC, RewardRedist) → balanceBefore += donation → Operator.distribute() → _calculateSplit(gross=minted+donation) → S_base understated → yield split incorrect → treasury loses yield",
  "context_hint": "This is a classic accounting bug in yield distribution systems. The contract conflates 'accidental contract balance' with 'yield to distribute'. The fix requires separating the concept of 'minted yield' from 'total contract balance'. This pattern appears in many protocols that didn't anticipate users sending tokens directly to the contract.",
  "is_vulnerable": true,
  "expert_notes": "While donations are rare, this is a real risk in protocols that interface with multiple entities. The impact scales linearly with donation size and is avoidable with proper accounting separation. Similar issues have appeared in Curve gauges and Compound treasury management where accidental transfers disrupted expected mathematics."
}
]