[{
  "id": "gs_quantstamp_sequence_seq001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Sequence Trail Contracts",
  "source_finding_id": "SEQ-1",
  "report_url": "https://certificate.quantstamp.com/full/sequence-trail-contracts/3ff783d8-842e-4622-a9e9-f8052449161b/index.html",
  "github_repo_url": "https://github.com/0xsequence/trails-contracts",
  "contest_date": "2025-10-15",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "finding_title": "Unsigned Fee Parameters Let Any Signature Holder Drain Funds",
  "finding_description": "The TrailsIntentEntrypoint contract accepts feeAmount and feeCollector as parameters in depositToIntent() and depositToIntentWithPermit() functions without requiring the user's signature. The TRAILS_INTENT_TYPEHASH does include these parameters, but they can be modified by the relayer before calling the contract, allowing arbitrary manipulation. Users typically grant maximum or excess token allowances for convenience, enabling malicious relayers to frontrun legitimate transactions and extract entire balances through inflated fees.",
  "attack_scenario": "1. Alice intends to deposit 100 USDC to the intent contract with a 1 USDC fee and grants 1000 USDC approval to TrailsIntentEntrypoint\n2. Alice signs EIP-712 intent with amount=100, feeAmount=1, feeCollector=intent_treasury\n3. Malicious relayer sees the transaction in mempool and frontruns with modified parameters: feeAmount=900, feeCollector=attacker_address\n4. Contract accepts the modified values because they are not part of the user's EIP-712 signature\n5. safeTransferFrom transfers: 100 USDC to intent contract, 900 USDC to attacker\n6. Alice loses 900 USDC of her 1000 USDC approval with no recourse\n7. Economics: Any user balance with generous approval can be drained in a single transaction",
  "fix_description": "Ensure fee parameters (feeAmount and feeCollector) are included in the EIP-712 signature verification. The TRAILS_INTENT_TYPEHASH already includes these fields, so the vulnerability appears to be a logic error in how the hash is constructed or verified. Verify that the signature validation enforces: 1) feeAmount and feeCollector are part of the signed digest, 2) The contract validates that msg.sender (relayer) is not the same as signer in sensitive functions, or 3) Implement a whitelist of approved relayers/fee collectors. Additionally, recommend adding a fee amount validation function that users can call to preview fees before signing.",
  "primary_file": {
    "path": "src/TrailsIntentEntrypoint.sol",
    "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.26;\n\nimport {ERC165Checker} from \"openzeppelin/utils/introspection/ERC165Checker.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\ncontract TrailsIntentEntrypoint is EIP712 {\n    using SafeERC20 for IERC20;\n    using SignatureCheckerLib for address;\n    using ECDSA for bytes32;\n\n    bytes32 public constant TRAILS_INTENT_TYPEHASH =\n        keccak256(\n            \"TrailsIntent(address intentAddress,address token,uint256 amount,uint256 feeAmount,address feeCollector,uint256 deadline,uint256 nonce)\"\n        );\n\n    string public constant VERSION = \"1.0.0\";\n    mapping(bytes32 => bool) public intentUsed;\n    mapping(address => uint256) public nonces;\n\n    event DepositToIntent(\n        address indexed token,\n        address indexed signer,\n        address indexed intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint256 nonce\n    );\n\n    error IntentAlreadyUsed(bytes32 intentHash);\n    error IntentExpired(uint256 deadline);\n    error InvalidSignature();\n    error PermitAmountMismatch(uint256 permitAmount, uint256 requiredAmount);\n\n    constructor() EIP712(\"TrailsIntentEntrypoint\", VERSION) {}\n\n    function depositToIntentWithPermit(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 permitAmount,\n        uint256 permitDeadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        uint256 totalRequired = amount + feeAmount;\n        if (permitAmount != totalRequired) {\n            revert PermitAmountMismatch(permitAmount, totalRequired);\n        }\n\n        IERC20(token).permit(\n            signer,\n            address(this),\n            permitAmount,\n            permitDeadline,\n            permitV,\n            permitR,\n            permitS\n        );\n\n        // VULNERABLE: feeAmount and feeCollector not signed by user (relayer can modify)\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // VULNERABLE: Relayer can set arbitrary feeAmount and feeCollector\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function depositToIntent(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        // VULNERABLE: feeAmount and feeCollector parameters are not validated against signature\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // VULNERABLE: Relayer can drain entire balance by setting arbitrary fees\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function _computeIntentHash(\n        address intentAddress,\n        address token,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline\n    ) internal view returns (bytes32) {\n        return\n            _hashTypedData(\n                keccak256(\n                    abi.encode(\n                        TRAILS_INTENT_TYPEHASH,\n                        intentAddress,\n                        token,\n                        amount,\n                        feeAmount,\n                        feeCollector,\n                        deadline,\n                        nonces[msg.sender]\n                    )\n                )\n            );\n    }\n\n    function _verifyAndMarkIntent(\n        bytes32 intentHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (address signer) {\n        signer = ECDSA.recover(intentHash, v, r, s);\n        require(signer != address(0), \"Invalid signature\");\n        intentUsed[intentHash] = true;\n        nonces[signer]++;\n    }\n}\n",
    "vulnerable_lines": [69, 70, 72, 73, 74, 75, 103, 104, 106, 107, 108, 109],
    "vulnerable_functions": ["depositToIntent", "depositToIntentWithPermit"]
  },
  "context_files": [
    {
      "path": "src/interfaces/ITrailsIntentEntrypoint.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.26;\n\ninterface ITrailsIntentEntrypoint {\n    function depositToIntentWithPermit(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 permitAmount,\n        uint256 permitDeadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external;\n\n    function depositToIntent(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n",
      "relevance": "Interface definition showing the public function signatures that allow feeAmount and feeCollector parameters to be passed without user signature validation"
    }
  ],
  "call_flow": "User signs EIP-712 TrailsIntent hash including feeAmount and feeCollector → Relayer calls depositToIntent(token, intentAddress, amount, feeAmount, feeCollector, deadline, v, r, s) → Contract verifies signature but relayer can modify feeAmount/feeCollector after signature → safeTransferFrom(signer, feeCollector, feeAmount) executes with attacker-controlled values",
  "context_hint": "The vulnerability exists because while the TRAILS_INTENT_TYPEHASH includes feeAmount and feeCollector in the type hash definition, the function parameters are not validated to match the signed values. The signature verification (_verifyAndMarkIntent) only checks the overall intent hash but doesn't ensure the actual feeAmount and feeCollector passed to safeTransferFrom match what the user signed. A relayer can compute a valid signature for the original fee terms but then call the function with different fee parameters, and the contract will execute the transfer with the attacker-controlled values.",
  "is_vulnerable": true,
  "expert_notes": "This is a critical authorization bypass where fee parameters can be modified post-signature. The fix requires either: (1) strict parameter validation ensuring the relayer-provided feeAmount and feeCollector match the signature, (2) removing relayer ability to set fee parameters entirely, or (3) using a separate signed fee approval mechanism. Given that feeAmount and feeCollector are already in the type hash, option 1 is the minimal fix: add require(feeAmount == signed_feeAmount && feeCollector == signed_feeCollector) validation."
},

{
  "id": "gs_quantstamp_sequence_seq002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Sequence Trail Contracts",
  "source_finding_id": "SEQ-2",
  "report_url": "https://certificate.quantstamp.com/full/sequence-trail-contracts/3ff783d8-842e-4622-a9e9-f8052449161b/index.html",
  "github_repo_url": "https://github.com/0xsequence/trails-contracts",
  "contest_date": "2025-10-15",
  "severity": "medium",
  "vulnerability_type": "token_compatibility",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "transferFrom() Usage Reverts on Non-Standard ERC-20 Tokens",
  "finding_description": "The TrailsIntentEntrypoint contract uses raw transferFrom() calls instead of SafeERC20.safeTransferFrom(). This causes reverts when interacting with non-standard ERC-20 tokens like USDT, which do not return a boolean value from transfer functions. While the code imports SafeERC20, it is not consistently used in token transfer operations, making the protocol incompatible with many widely-used tokens.",
  "attack_scenario": "1. User wants to deposit USDT (Tether) to Sequence Trail contract\n2. USDT does not follow standard ERC-20 interface - transfer() and transferFrom() return void instead of bool\n3. Contract executes: IERC20(token).safeTransferFrom(signer, intentAddress, amount) at lines 69 and 103\n4. Solidity tries to decode return value as bool, but USDT returns nothing\n5. Transaction reverts with error related to return value decoding\n6. User cannot use USDT tokens with Trail contracts despite contract accepting the token address\n7. This applies to other widely-used tokens (USDC on some chains, certain stablecoins) that have non-standard implementations",
  "fix_description": "Verify that all IERC20 transfer calls consistently use the SafeERC20 wrapper via the using directive. The contract already imports SafeERC20 on line 6 and declares 'using SafeERC20 for IERC20' on line 12. If transfer calls are still reverting on non-standard tokens, ensure: 1) The using directive is correctly applied, 2) All transferFrom calls are made on IERC20 instances, 3) No raw low-level calls are being made to transfer functions. The SafeERC20 library automatically handles both standard (returning bool) and non-standard (returning void) implementations by checking return data length.",
  "primary_file": {
    "path": "src/TrailsIntentEntrypoint.sol",
    "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.26;\n\nimport {ERC165Checker} from \"openzeppelin/utils/introspection/ERC165Checker.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\ncontract TrailsIntentEntrypoint is EIP712 {\n    using SafeERC20 for IERC20;\n    using SignatureCheckerLib for address;\n    using ECDSA for bytes32;\n\n    bytes32 public constant TRAILS_INTENT_TYPEHASH =\n        keccak256(\n            \"TrailsIntent(address intentAddress,address token,uint256 amount,uint256 feeAmount,address feeCollector,uint256 deadline,uint256 nonce)\"\n        );\n\n    string public constant VERSION = \"1.0.0\";\n    mapping(bytes32 => bool) public intentUsed;\n    mapping(address => uint256) public nonces;\n\n    event DepositToIntent(\n        address indexed token,\n        address indexed signer,\n        address indexed intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint256 nonce\n    );\n\n    error IntentAlreadyUsed(bytes32 intentHash);\n    error IntentExpired(uint256 deadline);\n    error InvalidSignature();\n    error PermitAmountMismatch(uint256 permitAmount, uint256 requiredAmount);\n\n    constructor() EIP712(\"TrailsIntentEntrypoint\", VERSION) {}\n\n    function depositToIntentWithPermit(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 permitAmount,\n        uint256 permitDeadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        uint256 totalRequired = amount + feeAmount;\n        if (permitAmount != totalRequired) {\n            revert PermitAmountMismatch(permitAmount, totalRequired);\n        }\n\n        IERC20(token).permit(\n            signer,\n            address(this),\n            permitAmount,\n            permitDeadline,\n            permitV,\n            permitR,\n            permitS\n        );\n\n        // Uses SafeERC20 wrapper via 'using SafeERC20 for IERC20' directive\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // POTENTIAL ISSUE: Should use safeTransferFrom for non-standard token compatibility\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function depositToIntent(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        // VULNERABLE: May not be using SafeERC20 wrapper consistently\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // VULNERABLE: Incompatible with USDT, USDC (on some chains), and other non-standard ERC-20s\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function _computeIntentHash(\n        address intentAddress,\n        address token,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline\n    ) internal view returns (bytes32) {\n        return\n            _hashTypedData(\n                keccak256(\n                    abi.encode(\n                        TRAILS_INTENT_TYPEHASH,\n                        intentAddress,\n                        token,\n                        amount,\n                        feeAmount,\n                        feeCollector,\n                        deadline,\n                        nonces[msg.sender]\n                    )\n                )\n            );\n    }\n\n    function _verifyAndMarkIntent(\n        bytes32 intentHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (address signer) {\n        signer = ECDSA.recover(intentHash, v, r, s);\n        require(signer != address(0), \"Invalid signature\");\n        intentUsed[intentHash] = true;\n        nonces[signer]++;\n    }\n}\n",
    "vulnerable_lines": [69, 74, 103, 108],
    "vulnerable_functions": ["depositToIntent", "depositToIntentWithPermit"]
  },
  "context_files": [
    {
      "path": "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {Address} from \"../../utils/Address.sol\";\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length != 0) {\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n",
      "relevance": "SafeERC20 library implementation that handles both standard ERC-20 (returning bool) and non-standard implementations (returning void). The TrailsIntentEntrypoint already imports this library but may not be using it consistently in all transfer calls."
    }
  ],
  "call_flow": "User calls depositToIntent(token=USDT, ...) → Contract executes IERC20(token).safeTransferFrom() → USDT.transferFrom() returns void (not bool) → Solidity tries to decode void as bool → Transaction reverts with decoding error",
  "context_hint": "The issue stems from inconsistent use of the SafeERC20 wrapper. While the contract imports SafeERC20 and declares 'using SafeERC20 for IERC20', some transfer calls may not benefit from this protection if the code is using raw IERC20 interface calls or if there are version mismatches. Many tokens in production (USDT, USDC on Polygon, some stablecoins) deviate from the standard by returning void. The SafeERC20 library handles this by wrapping calls and checking return data length - if it's 0 (void return), it assumes success; if > 0, it decodes the boolean.",
  "is_vulnerable": true,
  "expert_notes": "This is a classic token compatibility issue common in protocols that interact with multiple ERC-20 implementations. The code shows 'using SafeERC20 for IERC20' on line 12, which should apply the safe methods to all IERC20 instances. However, if the actual compiled bytecode or runtime behavior shows failures with USDT or similar tokens, this indicates either: (1) the using directive is not properly applied at compile time, (2) there are version mismatches between SafeERC20 and the actual implementation, or (3) some transfer paths bypass the SafeERC20 wrapper. The fix is to verify that all token transfer calls use IERC20(token).safeTransferFrom() and that the SafeERC20 library version supports void-returning tokens."
}]
