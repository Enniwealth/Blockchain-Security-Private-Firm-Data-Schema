[
  {
    "id": "gs_cantina_infrared_001",
    "report_url": "https://cantina.xyz/portfolio/dea3d8ab-95f0-48e1-9897-aec798bc94f1",
    "project_name": "Infrared: Operations & Future Vaults",
    "github_url": "https://github.com/infrared-dao/infrared-contracts",
    "language": "solidity",
    "chain": "berachain",
    "contest_date": "2025-10-15",
    "vulnerability_type": "reward_loss",
    "severity": "high",
    "difficulty_tier": 2,
    "context": "state_management",
    "is_vulnerable": true,
    "title": "Unaccrued Rewards Lost When Updating Reward Duration",
    "description": "The _setRewardsDuration function updates the reward duration and starts a new reward period, but it does not accrue pending rewards before updating lastUpdateTime. This causes any unaccrued yield accumulated since the last update to be permanently lost. The rewardPerTokenStored value is not updated to reflect the accrued rewards, so users cannot claim the pending rewards—they are simply discarded.",
    "primary_file": {
      "name": "MultiRewards.sol",
      "path": "src/core/MultiRewards.sol",
      "lines": "400-434",
      "content": "function _setRewardsDuration(\n    address _rewardsToken,\n    uint256 _rewardsDuration\n) internal {\n    require(\n        block.timestamp > rewardData[_rewardsToken].periodFinish,\n        \"Reward period still active\"\n    );\n    \n    // BUG: Does not call updateReward(address(0)) first\n    // Any unaccrued yield is lost\n    \n    rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n    \n    // Starting new period without accruing previous rewards\n    // This resets lastUpdateTime, wiping out pending accrual\n    rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n    rewardData[_rewardsToken].periodFinish = block.timestamp + _rewardsDuration;\n}\n\n// ATTACK SCENARIO:\n// Reward token: INFRA\n// Initial setup: rewards accrue per second\n// lastUpdateTime: block 1000\n// rewardPerTokenStored: 100e18\n// Current block: 2000\n// Accrued rewards: (2000 - 1000) * rewardRate = pending yield\n//\n// Governor calls _setRewardsDuration(newDuration)\n// BUG: updateReward NOT called\n// lastUpdateTime set to block 2000\n// BUT rewardPerTokenStored NOT updated\n// Pending yield from blocks 1000-2000 is LOST\n// Users cannot claim it because rewardPerTokenStored wasn't increased\n//\n// Impact:\n// Deposited amount: 100 INFRA\n// Expected earned: 50 INFRA (blocks 1000-2000)\n// Actual earned: 0 INFRA (rewards lost)"
    },
    "context_files": [
      {
        "name": "Reward Accrual Pattern",
        "path": "src/core/MultiRewards.sol",
        "relevance": "Shows how updateReward accrues pending rewards",
        "content": "// In MultiRewards.sol, rewards are accrued via updateReward:\n\nmodifier updateReward(address account) {\n    for (uint256 i = 0; i < rewardTokens.length; i++) {\n        address token = rewardTokens[i];\n        \n        // Step 1: Update global reward per token\n        uint256 lastApplicableTime = lastTimeRewardApplicable(token);\n        uint256 rewardPerTokenNow = rewardPerToken(token, lastApplicableTime);\n        rewardPerTokenStored[token] = rewardPerTokenNow;\n        lastUpdateTime[token] = lastApplicableTime;\n        \n        // Step 2: Update user's accrued rewards\n        if (account != address(0)) {\n            rewards[account][token] = earned(account, token);\n            userRewardPerTokenPaid[account][token] = rewardPerTokenNow;\n        }\n    }\n    _;\n}\n\n// Key insight:\n// rewardPerTokenStored is the global accumulator of rewards per token\n// It increases whenever updateReward is called\n// lastUpdateTime marks when this was last updated\n//\n// If lastUpdateTime is updated WITHOUT first updating rewardPerTokenStored,\n// the pending accrual is lost forever\n\n// VULNERABLE FLOW in _setRewardsDuration:\n// 1. Time has passed: block 1000 → block 2000\n// 2. lastUpdateTime[token] = 1000 (hasn't been updated)\n// 3. rewardPerTokenStored[token] = old value (from block 1000)\n// 4. Pending accrual = (2000 - 1000) * rewardRate\n//    This should be added to rewardPerTokenStored\n//\n// But _setRewardsDuration does:\n// 1. rewardData[_rewardsToken].lastUpdateTime = block.timestamp (2000)\n// 2. rewardData[_rewardsToken].rewardsDuration = newValue\n// 3. rewardData[_rewardsToken].periodFinish = 2000 + newDuration\n// 4. BUG: rewardPerTokenStored NOT updated\n//\n// Users' earned rewards are calculated as:\n// earned = (rewardPerToken - userRewardPerTokenPaid) * balance\n// If rewardPerToken is not updated, earned stays the same\n// Pending rewards from blocks 1000-2000 are LOST"
      },
      {
        "name": "User Reward Calculation",
        "path": "src/core/MultiRewards.sol",
        "relevance": "Shows how user earned rewards are computed",
        "content": "function earned(\n    address account,\n    address _rewardsToken\n) public view returns (uint256) {\n    return (\n        balanceOf(account) *\n        (rewardPerToken(_rewardsToken) - userRewardPerTokenPaid[account][_rewardsToken]) /\n        1e18\n    ) + rewards[account][_rewardsToken];\n}\n\nfunction rewardPerToken(\n    address _rewardsToken\n) public view returns (uint256) {\n    // This is DYNAMIC - calls lastTimeRewardApplicable\n    // It returns the up-to-date rewardPerToken including pending accrual\n    \n    if (totalSupply() == 0) {\n        return rewardPerTokenStored[_rewardsToken];\n    }\n    \n    uint256 applicableTime = lastTimeRewardApplicable(_rewardsToken);\n    uint256 timeDelta = applicableTime - lastUpdateTime[_rewardsToken];\n    uint256 rewardRate = rewardData[_rewardsToken].rewardRate;\n    \n    return rewardPerTokenStored[_rewardsToken] + \n           (timeDelta * rewardRate * 1e18 / totalSupply());\n}\n\n// How _setRewardsDuration breaks this:\n// \n// Scenario:\n// - lastUpdateTime: 1000\n// - rewardPerTokenStored: 100e18\n// - rewardRate: 1e18 per block\n// - totalSupply: 1000e18\n// - Current block: 2000\n// \n// Before _setRewardsDuration:\n// rewardPerToken() = 100e18 + (2000-1000) * 1e18 * 1e18 / 1000e18\n//                  = 100e18 + 1000e18\n//                  = 1100e18\n// \n// User with 100e18 balance:\n// If userRewardPerTokenPaid[user] = 100e18\n// earned = 100e18 * (1100e18 - 100e18) / 1e18 + 0 = 100e18 (100 INFRA earned)\n// \n// After _setRewardsDuration (VULNERABLE):\n// 1. lastUpdateTime set to 2000\n// 2. rewardPerTokenStored NOT updated (still 100e18)\n// 3. Next call to rewardPerToken():\n//    = 100e18 + (2000-2000) * 1e18 * 1e18 / 1000e18\n//    = 100e18 + 0\n//    = 100e18\n// 4. User's earned = 100e18 * (100e18 - 100e18) / 1e18 + 0 = 0\n// 5. The 100 INFRA rewards from blocks 1000-2000 are LOST"
      },
      {
        "name": "Loss Scenario",
        "path": "reference/infrared_reward_loss.md",
        "relevance": "Documents the reward loss scenario",
        "content": "SCENARIO: Governor Updates Reward Duration, Users Lose Pending Rewards\n\nSetup:\n- Vault: Infrared staking vault\n- Reward token: INFRA (native governance token)\n- Deposit: 100 INFRA staked\n- Reward rate: 10 INFRA per block\n- Period duration: 1000 blocks\n\nTimeline:\n\nBlock 1000:\n- Reward period started\n- lastUpdateTime[INFRA] = 1000\n- rewardPerTokenStored[INFRA] = 0\n- periodFinish[INFRA] = 2000\n- Users deposit and start earning\n\nBlock 1500:\n- Some user claims rewards via updateReward\n- lastUpdateTime[INFRA] updated to 1500\n- rewardPerTokenStored[INFRA] = 50 (accrued 500 blocks * 10 / 1000 supply)\n- pending rewards capped out\n\nBlock 1900:\n- Period almost over (100 blocks remaining)\n- No new claims have been made since block 1500\n- Pending accrual: (1900 - 1500) * 10 = 4000 INFRA waiting to be claimed\n- Governor decides to extend reward duration\n\nBlock 2000:\n- Reward period ended (periodFinish = 2000)\n- rewardPerTokenStored[INFRA] still = 50 (last updated at block 1500)\n- Unaccrued rewards: 400 blocks * 10 = 4000 INFRA\n- Governor calls _setRewardsDuration(newDuration) ← VULNERABLE CALL\n\nVulnerable Execution:\n1. _setRewardsDuration checks: block.timestamp (2000) > periodFinish (2000)? NO, should fail\n   But if called immediately after periodFinish, it passes\n2. Sets rewardData[INFRA].rewardsDuration = newDuration\n3. Sets lastUpdateTime[INFRA] = 2000 (DANGEROUS)\n4. Sets periodFinish[INFRA] = 2000 + newDuration\n5. BUG: Never calls updateReward(address(0))\n6. BUG: rewardPerTokenStored[INFRA] NOT updated\n7. Unaccrued 4000 INFRA are PERMANENTLY LOST\n\nAfter the Update:\n- lastUpdateTime = 2000\n- rewardPerTokenStored still = 50\n- New period: 2000 to 2000+newDuration\n- User claims rewards: earned = balance * (50 - userPaid) / 1e18\n- But from blocks 1500-2000, 4000 INFRA should have been accrued\n- Instead: NOTHING. Those rewards are gone.\n\nFix Required:\nCall updateReward(address(0)) BEFORE updating lastUpdateTime:\n\nfunction _setRewardsDuration(address _rewardsToken, uint256 _rewardsDuration) internal {\n    require(block.timestamp > rewardData[_rewardsToken].periodFinish, \"...\");\n    \n    // FIX: Accrue pending rewards first\n    updateReward(address(0));  // ← MISSING IN VULNERABLE VERSION\n    \n    rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n    rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n    rewardData[_rewardsToken].periodFinish = block.timestamp + _rewardsDuration;\n}\n\nAlternatively (off-chain):\nGovernor always calls claimRewards(address(0)) before calling _setRewardsDuration\nto ensure all rewards are flushed"
      }
    ],
    "call_flow": [
      "1. Reward period active: lastUpdateTime = 1000",
      "2. Blocks pass: 1000 → 2000",
      "3. Pending rewards accumulate: 1000 blocks * rewardRate",
      "4. No one calls updateReward, so rewardPerTokenStored not updated",
      "5. rewardPerTokenStored still reflects state at block 1000",
      "6. Governor calls _setRewardsDuration(newDuration) at block 2000",
      "7. _setRewardsDuration SKIPS updateReward call",
      "8. lastUpdateTime set to 2000",
      "9. rewardPerTokenStored NOT updated",
      "10. Pending rewards from blocks 1000-2000 lost forever",
      "11. Next claim: user earned = (rewardPerToken - userPaid) * balance",
      "12. But rewardPerToken hasn't increased since block 1000",
      "13. earned = 0, rewards are gone"
    ],
    "context_hint": "The core issue is updating lastUpdateTime without first calling updateReward to accrue pending rewards. In reward systems, lastUpdateTime and rewardPerTokenStored are tightly coupled: when lastUpdateTime changes, rewardPerTokenStored should be updated simultaneously via updateReward. Decoupling them causes reward loss.",
    "expert_notes": "This is a classic bug in multi-reward systems. The vulnerability requires understanding how compound reward accrual works: the 'rewardPerTokenStored' accumulator must be kept in sync with 'lastUpdateTime' at all times. The fix is simple but critical: call updateReward(address(0)) before modifying lastUpdateTime in _setRewardsDuration. Infrared fixed this in PR #642, adding the missing updateReward call.",
    "fix_description": "Call updateReward(address(0)) at the beginning of _setRewardsDuration to accrue all pending rewards before updating lastUpdateTime and starting a new period.",
    "fix_code": "function _setRewardsDuration(\n    address _rewardsToken,\n    uint256 _rewardsDuration\n) internal updateReward(address(0)) {  // FIXED: Add this modifier\n    require(\n        block.timestamp > rewardData[_rewardsToken].periodFinish,\n        \"Reward period still active\"\n    );\n    \n    // Now all pending rewards have been accrued:\n    // - rewardPerTokenStored updated\n    // - lastUpdateTime updated to current block\n    // - Users' pending rewards flushed\n    \n    // Safe to start new period\n    rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n    rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n    rewardData[_rewardsToken].periodFinish = block.timestamp + _rewardsDuration;\n}\n\n// Or alternatively, explicit call:\nfunction _setRewardsDuration(\n    address _rewardsToken,\n    uint256 _rewardsDuration\n) internal {\n    require(\n        block.timestamp > rewardData[_rewardsToken].periodFinish,\n        \"Reward period still active\"\n    );\n    \n    // FIXED: Explicit call to accrue pending rewards\n    updateReward(address(0));\n    \n    rewardData[_rewardsToken].rewardsDuration = _rewardsDuration;\n    rewardData[_rewardsToken].lastUpdateTime = block.timestamp;\n    rewardData[_rewardsToken].periodFinish = block.timestamp + _rewardsDuration;\n}"
  }
]