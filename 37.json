[
  {
    "id": "gs_guardian_fastlane_H01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "H-01",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "high",
    "vulnerability_type": "access_control_bypass",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Atomic Liquidity Fee Bypassed At Max Capacity",
    "finding_description": "The function agentWithdrawFromCommitted is meant to let a policy agent pull from a user's committed balance while paying a fee to the atomic pool. When the isUnderlying argument is set to true (requesting MON), the function calls _getGrossAndFeeFromNetAssets. If there is insufficient liquidity, the function caps the returned gross amount but maintains the original net amount as the amount to transfer. This allows the agent to bypass the liquidity cap and seize the fee meant to buffer the float/protocol revenue.",
    "attack_scenario": "1. Agent calls agentWithdrawFromCommitted with isUnderlying = true.\n2. Pool has low liquidity.\n3. Function caps the gross amount but sends the original requested net amount.\n4. Agent receives funds without paying the utilization fee and leaves the pool insolvent relative to its accounting.\n5. Agent can repeat this whenever the pool refills, draining liquidity.",
    "fix_description": "After calling _getGrossAndFeeFromNetAssets, calculate the deliverable net by calculating gross - fee. If it doesn't match the requested net amount, either revert or return the actual net amount.",
    "primary_file": {
      "path": "src/shmonad/ShMonad.sol",
      "content": "// Content not provided in report. Vulnerability located at line 196.\n\nfunction agentWithdrawFromCommitted(..., bool isUnderlying) external {\n    // Vulnerable logic handles isUnderlying == true incorrectly when capped\n}",
      "vulnerable_lines": [196],
      "vulnerable_functions": [
        "agentWithdrawFromCommitted"
      ]
    },
    "context_files": [],
    "call_flow": "agentWithdrawFromCommitted -> _getGrossAndFeeFromNetAssets -> _accountForWithdraw (mismatch)",
    "context_hint": "The mismatch occurs because the function respects the net amount requested even when the gross amount (which includes the fee) was capped due to liquidity constraints.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_H02",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "H-02",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "high",
    "vulnerability_type": "accounting_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Withdrawals Exceed Intended Limits",
    "finding_description": "The _accountForWithdraw function allows withdrawals up to allocatedAmount plus earnedRevenue. When allocatedAmount is depleted, the function increases allocatedAmount by the shortfall (covered by revenue). However, subsequent checks compare against an inflated limit (allocatedAmount + earnedRevenueOffset), effectively double-counting the revenue allowance.",
    "attack_scenario": "1. User performs instant withdrawal when allocatedAmount is depleted.\n2. System increases allocatedAmount to cover shortfall using earnedRevenue.\n3. User repeats withdrawal; the check allows _distributedAmount + netAmount against an inflated limit.\n4. User drains contract funds reserved for other operations.",
    "fix_description": "Modify _accountForWithdraw to properly account for already used earnedRevenue, ensuring instant withdrawals cannot exceed the combined allocated and earnedRevenue amount.",
    "primary_file": {
      "path": "src/shmonad/StakeTracker.sol",
      "content": "// Content not provided in report. Vulnerability located at line 1486.\n\nfunction _accountForWithdraw(...) internal {\n    // Vulnerable accounting logic allowing expanded withdrawal limits\n}",
      "vulnerable_lines": [1486],
      "vulnerable_functions": [
        "_accountForWithdraw"
      ]
    },
    "context_files": [],
    "call_flow": "withdraw/redeem -> _accountForWithdraw -> Improper limit update",
    "context_hint": "Double counting of earnedRevenue allows the withdrawal limit to expand indefinitely as long as individual withdrawals are smaller than the revenue amount.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_H03",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "H-03",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "high",
    "vulnerability_type": "denial_of_service",
    "difficulty_tier": 3,
    "context_level": "single_file",
    "finding_title": "Overflow DOS In Crank Locks Funds",
    "finding_description": "In _crankGlobal, specifically _checkSetNewAtomicLiquidityTarget, the system calculates _newScaledTargetPercent. If a large amount of shMON has been requested to unstake, equity becomes very small. This causes the target percentage (distributedAmount / totalEquity) to exceed 655% (uint16 max in basis points), causing an overflow revert.",
    "attack_scenario": "1. Users request large unstake (creating liability, reducing equity).\n2. Atomic unstake occurs.\n3. Crank runs _checkSetNewAtomicLiquidityTarget.\n4. _newScaledTargetPercent calculation overflows uint16.\n5. Crank reverts permanently, locking funds and preventing epoch advancement.",
    "fix_description": "Cap the calculated _newScaledTargetPercent at 100%, and perform an emergency decrease of allocated and distributed amounts in _afterRequestUnstake if the unstaked amount + allocated + recent revenue > total equity.",
    "primary_file": {
      "path": "src/shmonad/StakeTracker.sol",
      "content": "// Content not provided in report.\n\nfunction _checkSetNewAtomicLiquidityTarget(...) internal {\n    // Vulnerable calculation of _newScaledTargetPercent\n}",
      "vulnerable_lines": [],
      "vulnerable_functions": [
        "_checkSetNewAtomicLiquidityTarget",
        "_crankGlobal"
      ]
    },
    "context_files": [],
    "call_flow": "_crankGlobal -> _checkSetNewAtomicLiquidityTarget -> _unscaledTargetLiquidityPercentage (overflow)",
    "context_hint": "Division by a small equity value results in a percentage > 65535 basis points, overflowing the uint16 container.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_Remediation_H01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "Remediation H-01",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "high",
    "vulnerability_type": "arithmetic_underflow",
    "difficulty_tier": 3,
    "context_level": "multi_file",
    "finding_title": "Global Pending Updates Affect Allocations",
    "finding_description": "During the validator crank loop, an undelegate() call immediately increments s_globalPending.pendingUnstaking. This reduces globalUnstakableAmount for subsequent validators in the same crank. Because queueForUnstake is cached at the start but globalUnstakableAmount is recalculated, the allocation formula produces a stakeAllocationDecrease larger than expected, causing an underflow.",
    "attack_scenario": "1. Validator crank starts.\n2. Validator N undelegates, increasing global pendingUnstaking.\n3. Validator N+1 is processed.\n4. Allocation calculation uses cached queueForUnstake but reduced globalUnstakableAmount.\n5. Calculated decrease exceeds target stake -> Underflow/Revert.",
    "fix_description": "Cache pendingUnstaking at the start of the crank cycle to ensure consistent calculations throughout the loop.",
    "primary_file": {
      "path": "src/shmonad/libraries/StakeAllocationLib.sol",
      "content": "// Content not provided in report. Vulnerability located at lines 88-89.\n\nfunction calculateAllocation(...) internal {\n    // Vulnerable math using mixed cached/live state\n}",
      "vulnerable_lines": [88, 89],
      "vulnerable_functions": []
    },
    "context_files": [],
    "call_flow": "Crank Loop -> undelegate (Validator N) -> Update Global State -> Calculate Allocation (Validator N+1) -> Underflow",
    "context_hint": "Inconsistency between cached loop variables and live state updates within the same loop iteration causes math errors.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-01",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 1,
    "context_level": "single_file",
    "finding_title": "Auto Top-up Ignores minCommitted Threshold",
    "finding_description": "The auto-top-up mechanism is intended to maintain a minCommitted balance. However, _spendFromCommitted only attempts top-up if the requested shares exceed fundsAvailable. If an agent ensures transfers are within the current committed balance, the balance can be drained below minCommitted without triggering a top-up.",
    "attack_scenario": "1. Agent has committed balance X and minCommitted Y.\n2. Agent transfers amount Z (where Z <= X).\n3. _spendFromCommitted checks if Z > X (False).\n4. Transfer proceeds, balance reduces.\n5. Top-up logic skipped even if new balance < minCommitted.",
    "fix_description": "Trigger the top-up when the updated fundsAvailable is below the shares + minCommited, regardless of whether the specific spend was covered.",
    "primary_file": {
      "path": "src/shmonad/Policies.sol",
      "content": "// Content not provided in report. Vulnerability located at line 660.\n\nfunction _spendFromCommitted(...) internal {\n    // Vulnerable condition for triggering _tryTopUp\n}",
      "vulnerable_lines": [660],
      "vulnerable_functions": [
        "_spendFromCommitted"
      ]
    },
    "context_files": [],
    "call_flow": "_spendFromCommitted -> condition check -> _tryTopUp (skipped)",
    "context_hint": "Logic error in the conditional check for refilling balances.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M02",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-02",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "access_control_bypass",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Agent Instant-Uncommit Can Be Bypassed",
    "finding_description": "The system prevents agents from uncommitting their own balance from a policy. However, this check can be circumvented by transferring the committed balance to a non-agent address (which the agent controls) and then uncommitting from there.",
    "attack_scenario": "1. Malicious agent has committed balance.\n2. Agent calls agentTransferFromCommited to a non-agent address they own.\n3. Agent calls agentTransferToUncommitted from the second address.\n4. Funds are uncommitted, bypassing the agent restriction.",
    "fix_description": "Prevent agents from transferring their own committed balances to non-agent addresses without a delay.",
    "primary_file": {
      "path": "src/shmonad/ShMonad.sol",
      "content": "// Content not provided in report. Vulnerability located at line 131.\n\nfunction agentTransferFromCommited(...) external {\n    // Missing restriction on destination or delay\n}",
      "vulnerable_lines": [131],
      "vulnerable_functions": [
        "agentTransferFromCommited"
      ]
    },
    "context_files": [],
    "call_flow": "agentTransferFromCommited -> agentTransferToUncommitted",
    "context_hint": "Indirect state change via an intermediary account bypasses source-based restrictions.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M03",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-03",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Single-Failure Deactivation Of New Validators",
    "finding_description": "Validators are deactivated if inActiveSet_Last and inActiveSet_Current are both false. New validators initialize with inActiveSet_Current = false. The function _advanceActiveSetFlags sets inActiveSet_Last to false. If the first crank fails (setting current to false), the validator is deactivated immediately, bypassing the intended two-strike rule.",
    "attack_scenario": "1. New validator added (inActiveSet_Current defaults to false).\n2. _advanceActiveSetFlags sets inActiveSet_Last = false.\n3. First crank experiences failure, setting inActiveSet_Current = false.\n4. Condition (Last=false && Current=false) met.\n5. Validator deactivated after single failure.",
    "fix_description": "Ensure newly added validators are initialized with appropriate active set state or implement a grace period before applying standard deactivation logic.",
    "primary_file": {
      "path": "src/shmonad/StakeTracker.sol",
      "content": "// Content not provided in report. Vulnerability located at line 711.\n\nfunction _rollValidatorEpochForwards(...) internal {\n    // Logic checks for deactivation criteria\n}",
      "vulnerable_lines": [711],
      "vulnerable_functions": [
        "_rollValidatorEpochForwards"
      ]
    },
    "context_files": [],
    "call_flow": "Add Validator -> _advanceActiveSetFlags -> _rollValidatorEpochForwards (failure) -> Deactivation",
    "context_hint": "Default initialization values satisfy one half of the deactivation condition, reducing fault tolerance for new entities.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M04",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-04",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "accounting_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Withdrawal Rewards Misclassified As Surplus",
    "finding_description": "The function _handleCompleteDecreasedAllocation treats any amount received from withdrawal in excess of expectedAmount as 'surplus' capital, redirecting it to the stake queue. On Monad, withdrawals include rewards. This misclassifies rewards as surplus, bypassing commission and underreporting revenue.",
    "attack_scenario": "1. Protocol withdraws principal + rewards from Monad.\n2. Amount > expectedAmount.\n3. Excess booked as surplus.\n4. Excess re-staked instead of distributed as rewards.\n5. Validator performance metrics skewed; commission lost.",
    "fix_description": "When amount > expectedAmount, treat amount - expectedAmount as validator rewards and process it through _handleEarnedStakingYield.",
    "primary_file": {
      "path": "src/shmonad/StakeTracker.sol",
      "content": "// Content not provided in report. Vulnerability located at line 1244.\n\nfunction _handleCompleteDecreasedAllocation(...) internal {\n    // Logic processing withdrawal returns\n}",
      "vulnerable_lines": [1244],
      "vulnerable_functions": [
        "_handleCompleteDecreasedAllocation"
      ]
    },
    "context_files": [],
    "call_flow": "Withdrawal completion -> _handleCompleteDecreasedAllocation -> Misclassification",
    "context_hint": "Failure to distinguish between principal return excess (surplus) and yield generation (rewards).",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M05",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-05",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Boosting From Committed Shares",
    "finding_description": "agentBoostYieldFromCommitted books revenue and increases queueToStake without actual MON inflow. This inflates earnedRevenue. Since instant withdrawals use earnedRevenue to offset liquidity checks, this allows withdrawals backed by 'ghost' revenue, draining real liquid assets reserved for other purposes.",
    "attack_scenario": "1. Agent calls agentBoostYieldFromCommitted (no new MON).\n2. earnedRevenue increases.\n3. Users call instant withdraw.\n4. System permits withdrawal believing revenue covers it.\n5. Liquid assets drained; liquidity for backfilling unstakes unavailable.",
    "fix_description": "Keep queueForUnstake and revenue tied to real inflows so staking, withdrawals, and instant-withdraw capacity reflect actual liquidity.",
    "primary_file": {
      "path": "src/shmonad/ShMonad.sol",
      "content": "// Content not provided in report. Vulnerability located at line 235.\n\nfunction agentBoostYieldFromCommitted(...) external {\n    // Logic increasing revenue without inflow\n}",
      "vulnerable_lines": [235],
      "vulnerable_functions": [
        "agentBoostYieldFromCommitted"
      ]
    },
    "context_files": [],
    "call_flow": "agentBoostYieldFromCommitted -> _handleBoostYield -> withdraw (liquidity check passed falsely)",
    "context_hint": "Accounting variables must track actual asset balances; boosting revenue from internal state creates a disconnect between accounting and solvency.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M06",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-06",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "mev",
    "difficulty_tier": 3,
    "context_level": "single_file",
    "finding_title": "MEV Through Atomic Withdrawals",
    "finding_description": "Atomic unstake fees are priced off current utilization. A successful unstake increases utilization for the next call. MEV bots can front-run large withdrawals with a small redeem to push utilization up, increasing the fee paid by the victim, which benefits the bot's remaining shMON holdings.",
    "attack_scenario": "1. Victim submits large instant withdrawal.\n2. MEV Bot observes tx in mempool.\n3. Bot front-runs with small redeem/withdraw.\n4. Utilization increases -> Fee rate increases.\n5. Victim executes at higher fee.\n6. Bot profits via increased yield on their holdings.",
    "fix_description": "Add slippage controls to every instant-unstake path so users aren't forced to execute at a worse fee than they previewed.",
    "primary_file": {
      "path": "src/shmonad/StakeTracker.sol",
      "content": "// Content not provided in report. Vulnerability located at line 1486.\n\nfunction _getLiquidityForAtomicUnstaking(...) internal {\n    // Fee calculation based on instantaneous spot utilization\n}",
      "vulnerable_lines": [1486],
      "vulnerable_functions": [
        "_getLiquidityForAtomicUnstaking",
        "_accountForWithdraw"
      ]
    },
    "context_files": [],
    "call_flow": "Attacker Redeem -> Utilization UP -> Victim Withdraw -> High Fee -> Attacker Profit",
    "context_hint": "Affine fee curves based on spot utilization are susceptible to sandwiching/front-running if no slippage protection exists.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M07",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-07",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "arithmetic_overflow",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "solveGrossGivenNet Overflow",
    "finding_description": "The function solveGrossGivenNet computes (2*m*RAY*targetNet)/L inside Math.mulDiv. For withdrawals > 5.79M MON (with default parameters), the intermediate product exceeds 256 bits, causing a revert.",
    "attack_scenario": "1. User attempts to withdraw > 5.79M MON.\n2. solveGrossGivenNet calculates intermediate product.\n3. Product > type(uint256).max.\n4. Transaction reverts, preventing large withdrawals.",
    "fix_description": "Replace the 256-bit function mulDiv with the 512-bit version fullMulDiv.",
    "primary_file": {
      "path": "src/shmonad/libraries/FeeLib.sol",
      "content": "// Content not provided in report. Vulnerability located at line 311.\n\nfunction solveGrossGivenNet(...) internal {\n    // Math.mulDiv calculation causing overflow\n}",
      "vulnerable_lines": [311],
      "vulnerable_functions": [
        "solveGrossGivenNet"
      ]
    },
    "context_files": [],
    "call_flow": "withdraw -> solveGrossGivenNet -> Math.mulDiv (overflow)",
    "context_hint": "Standard mulDiv often overflows intermediate products; 512-bit math extension is required for large value ranges.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M08",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-08",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "accounting_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Double Liability Deduction In Target Stake",
    "finding_description": "targetStakedAmount subtracts liabilities via 'totalLiabilities' AND via 'reservedAmount'. However, 'reservedAmount' effectively already includes rewardsPayable and redemptionsPayable. This double deduction leads to an understated staking target and underutilization of equity.",
    "attack_scenario": "1. System calculates targetStakedAmount.\n2. Deducts totalLiabilities (includes rewards/redemptions).\n3. Deducts reservedAmount (also includes rewards/redemptions).\n4. Resulting target is lower than intended.\n5. Protocol fails to stake available equity.",
    "fix_description": "Adjust the targetStakedAmount computation to avoid double-counting obligations that are already captured in both totalLiabilities and reservedAmount.",
    "primary_file": {
      "path": "src/shmonad/libraries/AccountingLib.sol",
      "content": "// Content not provided in report. Vulnerability located at line 297.\n\nfunction targetStakedAmount(...) internal {\n    // Accounting logic subtracting liabilities twice\n}",
      "vulnerable_lines": [297],
      "vulnerable_functions": [
        "targetStakedAmount"
      ]
    },
    "context_files": [],
    "call_flow": "targetStakedAmount -> Calculation Logic",
    "context_hint": "Accounting variables often have overlapping definitions; ensuring they are orthogonal in aggregate calculations is critical.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_M09",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "M-09",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Inactive Validator's Pending Stake Not Unstaked",
    "finding_description": "When cranking an inactive validator, the protocol unstakes only _validatorUnstakableAmount (target - pending). This sets nextTarget to 0. The pendingStaking amount is excluded from the unstake queue and remains locked indefinitely.",
    "attack_scenario": "1. Validator has 100 ETH target + 10 ETH pending.\n2. Validator becomes inactive.\n3. Crank unstakes 90 ETH (100 - 10).\n4. nextTarget set to 0.\n5. 10 ETH pending remains in system, unaccounted for.",
    "fix_description": "Consider assigning difference between previous targetStakeAmount and _validatorUnstakableAmount as next target stake amount to ensure pending funds are handled.",
    "primary_file": {
      "path": "src/shmonad/StakeTracker.sol",
      "content": "// Content not provided in report. Vulnerability located at lines 638-650.\n\nfunction _crankValidator(...) internal {\n    // Logic handling inactive validators excludes pending stake\n}",
      "vulnerable_lines": [638, 639, 640, 641, 642, 643, 644, 645, 646, 647, 648, 649, 650],
      "vulnerable_functions": [
        "_crankValidator"
      ]
    },
    "context_files": [],
    "call_flow": "_crankValidator -> Inactive Path -> Calculation error",
    "context_hint": "When zeroing out a position, pending in-flight transactions must be accounted for or they become orphaned.",
    "is_vulnerable": true
  },
  {
    "id": "gs_guardian_fastlane_Remediation_M01",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "monad",
    "source_platform": "guardian",
    "source_report": "FastLane Protocol Security Assessment",
    "source_finding_id": "Remediation M-01",
    "report_url": "https://github.com/guardianaudits",
    "github_repo_url": "https://github.com/FastLane-Labs",
    "contest_date": "2025-12-08",
    "severity": "medium",
    "vulnerability_type": "logic_error",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "finding_title": "Agent Withdraw Burn Mismatch",
    "finding_description": "When agentWithdrawFromCommitted is capped due to low liquidity, _assetsToReceive is reduced (capped gross - fee), but _sharesToDeduct remains based on the original requested amount. This causes _spendFromCommitted to burn the full amount of shares while the agent receives fewer assets than paid for.",
    "attack_scenario": "1. Agent requests withdrawal.\n2. Liquidity is low; payout is capped.\n3. _sharesToDeduct is NOT updated to reflect cap.\n4. Agent receives partial payout.\n5. Agent burns full share amount (Loss of funds).",
    "fix_description": "Recompute _sharesToDeduct from _grossAssetsCapped before calling _spendFromCommitted, or revert when _grossAssetsCapped < _grossAssetsWanted.",
    "primary_file": {
      "path": "src/shmonad/ShMonad.sol",
      "content": "// Content not provided in report. Vulnerability located at line 221.\n\nfunction agentWithdrawFromCommitted(...) external {\n    // Mismatch between calculated payout and burned shares\n}",
      "vulnerable_lines": [221],
      "vulnerable_functions": [
        "agentWithdrawFromCommitted"
      ]
    },
    "context_files": [],
    "call_flow": "agentWithdrawFromCommitted -> Cap Assets -> _spendFromCommitted (Excess Burn)",
    "context_hint": "Input parameters for the burn function must be updated if the payout calculation logic modifies the output amount.",
    "is_vulnerable": true
  }
]