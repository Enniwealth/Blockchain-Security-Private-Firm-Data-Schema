{
  "id": "gs_quantstamp_campre_camp001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp Protocol - Re-Audit",
  "source_finding_id": "CAMP-1",
  "report_url": "https://certificate.quantstamp.com/full/camp-re-audit/2a90a14d-4635-462c-905c-0b444e0d8cf8/index.html",
  "github_repo_url": "https://github.com/campaign-layer/camp-oft",
  "contest_date": "2025-08-13",
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "Griefing Users Can Cause Deposits to Fail on the Destination Chain Due to Lack of Minimum _gaslimit Validation",
  "finding_description": "The bridgeOut() and release() functions allow the caller to specify a _gaslimit argument. This value is the maximum amount of gas units the executor should use on the destination chain when completing the bridge. However, in the case of the CampTimelockEscrow contract, there is never any validation that some minimum amount of gas is available on the destination chain to ensure the bridge transaction is successful. Therefore, User A could process User B's deposit via the release() function, specifying a very small _gaslimit, causing the transaction to fail on the destination chain. This means the affected user would have to directly call the lzReceive() function on the target chain's implementation of the Camp OFT contract in order to complete their bridge action successfully.",
  "attack_scenario": "1. Alice queues a deposit for bridging by calling bridgeOut() with amount=1000 CAMP tokens\n2. After holdPeriod expires, Bob (or any other user) calls release(aliceDepositId, _gaslimit=21000) with a very small gas limit\n3. The transaction is sent to LayerZero but fails on Ethereum mainnet due to insufficient gas\n4. Alice's tokens remain locked in the escrow contract on Camp Network\n5. Alice must manually call lzReceive() on the destination chain to complete the bridge\n6. This creates a poor user experience and potential fund loss if Alice doesn't understand the recovery mechanism\n7. Attacker (Bob) incurs minimal cost while griefing Alice's bridge transaction",
  "fix_description": "Estimate a minimum amount of gas required on the target chain to complete a basic bridge action (MIN_GAS_LIMIT) and validate that _gaslimit >= MIN_GAS_LIMIT. Since the CampTimelockEscrow contract never attaches any data within its SendParam struct, the minimum gas can be estimated based on the bytecode complexity of the destination Camp OFT contract. Add validation: require(_gaslimit >= MIN_GAS_LIMIT, 'Gas limit too low'). Set MIN_GAS_LIMIT to at least 100,000 to ensure sufficient gas for LayerZero execution, message passing, and token minting on destination.",
  "primary_file": {
    "path": "contracts/CampTimelockEscrow.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@layerzerolabs/lz-evm-oapp-v2/contracts/oapp/OAppCore.sol\";\n\ncontract CampTimelockEscrow is OAppCore {\n    struct Deposit {\n        address to;\n        uint256 amount;\n        uint256 unlockTimestamp;\n    }\n    \n    mapping(uint256 => Deposit) public pending;\n    uint256 public totalDeposits;\n    uint256 public holdPeriod = 1 days;\n    \n    // VULNERABLE: No minimum _gaslimit validation\n    function bridgeOut(\n        address _to,\n        uint128 _gaslimit,  // VULNERABLE: No minimum check\n        uint256 _bridgeAmount,\n        uint256 _minAmount\n    ) external payable {\n        require(_bridgeAmount > 0, \"Amount must be greater than 0\");\n        require(_to != address(0), \"Invalid recipient\");\n        // VULNERABLE: Accepts any _gaslimit value, even 21000\n        \n        uint256 depositId = totalDeposits;\n        pending[depositId] = Deposit(\n            _to,\n            _bridgeAmount,\n            block.timestamp + holdPeriod\n        );\n        totalDeposits++;\n    }\n    \n    // VULNERABLE: No minimum _gaslimit validation in release path either\n    function release(\n        uint256 _depositId,\n        uint128 _gaslimit  // VULNERABLE: No minimum check\n    ) external payable {\n        Deposit memory d = pending[_depositId];\n        require(block.timestamp >= d.unlockTimestamp, \"Not ready\");\n        \n        delete pending[_depositId];\n        \n        // Process bridge with arbitrary _gaslimit\n        // If _gaslimit is too small, destination chain execution will fail\n        _bridgeNativeTokens(d.to, d.amount, _gaslimit);\n    }\n    \n    function _bridgeNativeTokens(\n        address _to,\n        uint256 _amount,\n        uint128 _gaslimit  // Could be 21000 or other very small value\n    ) internal {\n        SendParam memory sendParam = SendParam({\n            dstEid: dstEid,\n            to: _to,\n            amountLD: _amount,\n            minAmountLD: _amount,\n            extraOptions: \"\"  // No data payload\n        });\n        \n        // VULNERABLE: LayerZero will attempt to execute on destination with provided _gaslimit\n        // If _gaslimit < actual required gas, transaction reverts on destination\n        // But funds are considered \"sent\" and user must manually recover via lzReceive()\n        \n        _send(\n            _to,\n            _amount,\n            _gaslimit\n        );\n    }\n}\n",
    "vulnerable_lines": [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38],
    "vulnerable_functions": ["bridgeOut", "release", "_bridgeNativeTokens"]
  },
  "context_files": [
    {
      "path": "contracts/CampTimelockEscrow.sol",
      "content": "// Fixed implementation:\n//\n// contract CampTimelockEscrow is OAppCore {\n//     // LayerZero execution requires at least 100k gas for:\n//     // - Message validation and decoding\n//     // - Token unwrapping and minting\n//     // - State updates and event emission\n//     uint128 constant MIN_GAS_LIMIT = 100_000;\n//\n//     function bridgeOut(\n//         address _to,\n//         uint128 _gaslimit,\n//         uint256 _bridgeAmount,\n//         uint256 _minAmount\n//     ) external payable {\n//         require(_bridgeAmount > 0, \"Amount must be greater than 0\");\n//         require(_to != address(0), \"Invalid recipient\");\n//         require(_gaslimit >= MIN_GAS_LIMIT, \"Gas limit too low\");  // FIX\n//         \n//         uint256 depositId = totalDeposits;\n//         pending[depositId] = Deposit(\n//             _to,\n//             _bridgeAmount,\n//             block.timestamp + holdPeriod\n//         );\n//         totalDeposits++;\n//     }\n//\n//     function release(\n//         uint256 _depositId,\n//         uint128 _gaslimit\n//     ) external payable {\n//         Deposit memory d = pending[_depositId];\n//         require(block.timestamp >= d.unlockTimestamp, \"Not ready\");\n//         require(_gaslimit >= MIN_GAS_LIMIT, \"Gas limit too low\");  // FIX\n//         \n//         delete pending[_depositId];\n//         _bridgeNativeTokens(d.to, d.amount, _gaslimit);\n//     }\n// }\n//\n// Why 100,000 gas?\n// - LayerZero message verification: ~50,000 gas\n// - OFT receive and mint: ~40,000 gas\n// - Event emission and storage: ~10,000 gas\n// - Buffer for complexity: total 100,000 recommended\n",
      "relevance": "Shows the fix and explains the gas cost breakdown for LayerZero execution on destination"
    }
  ],
  "call_flow": "User A.bridgeOut(amount, gaslimit=21000) → Deposit queued → User B.release(depositId, gaslimit=21000) → _bridgeNativeTokens() → LayerZero send with 21000 gas → Destination chain OFT.lzReceive() → Out of gas revert → Tokens stuck, User A must manually recover",
  "context_hint": "This vulnerability exploits the separation of responsibility in LayerZero bridge architecture. The CampTimelockEscrow contract on source chain cannot know what gas is actually required on destination chain. However, it can enforce a minimum based on typical execution costs. The griefing vector exists because release() is permissionless (anyone can call it with any _gaslimit), combined with no validation. The fix is simple: enforce a sensible minimum that covers all normal execution paths.",
  "is_vulnerable": true,
  "expert_notes": "This is a design-level vulnerability in cross-chain systems where source-chain contracts delegate execution to destination-chain actors without enforcing minimum requirements. The fix is straightforward (add a constant and one require statement) but the impact can be significant for user experience. In production, Camp likely estimates MIN_GAS_LIMIT through testing the Camp OFT contract's lzReceive() function. The vulnerability appears in the re-audit because the original bridging mechanism (batch processing) was removed in favor of user-initiated release, changing the threat model."
}
