[
  {
    "id": "gs_cantina_silo_dynamic_kink_001",
    "report_url": "https://cantina.xyz/portfolio/01da8f41-fa9f-4239-95f5-52d05cd34b8c",
    "project_name": "Silo Finance: Dynamic Kink Model",
    "github_url": "https://github.com/silo-finance/silo-contracts-v2",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-09-30",
    "vulnerability_type": "missing_access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "context": "interest_rate_model",
    "is_vulnerable": true,
    "title": "Missing Access Control on getCompoundInterestRateAndUpdate() - Arbitrary k Manipulation",
    "description": "The getCompoundInterestRateAndUpdate() function is documented to be callable only by the associated Silo contract, but this access control is not enforced. The function accepts arbitrary debt and collateral parameters and updates the critical k value (slope parameter) that drives the dynamic kink model's interest rate calculations. This allows any external caller to manipulate k to arbitrary values between kmin and kmax, fundamentally breaking the interest rate optimization mechanism. Attackers can preemptively set k to influence the entire market's interest rate behavior.",
    "primary_file": {
      "name": "DynamicKinkModel.sol",
      "path": "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol",
      "lines": "145-160",
      "content": "// VULNERABLE: Missing access control on rate update function\nfunction getCompoundInterestRateAndUpdate(\n    uint256 _collateralAssets,\n    uint256 _debtAssets,\n    uint256 _interestRateTimestamp\n)\n    external\n    virtual\n    returns (uint256 rcomp)\n{\n    // @audit No check that msg.sender is the Silo\n    // Documentation states: \"should only be callable by its Silo\"\n    // Implementation contains no require() or modifier to enforce this\n    \n    (rcomp, modelState.k) = _getCompoundInterestRate(CompoundInterestRateArgs({\n        silo: modelState.silo,\n        collateralAssets: _collateralAssets,\n        debtAssets: _debtAssets,\n        interestRateTimestamp: _interestRateTimestamp,\n        blockTimestamp: block.timestamp,\n        usePending: false\n    }));\n}\n\n// INTERNAL: Computes new k based on provided parameters\nfunction _getCompoundInterestRate(\n    CompoundInterestRateArgs memory _args\n)\n    internal\n    view\n    returns (uint256 rcomp, uint256 k)\n{\n    // With no access control in getCompoundInterestRateAndUpdate(),\n    // attacker controls all input parameters:\n    // - _args.collateralAssets: can be set to 0 or any value\n    // - _args.debtAssets: can be set to 0 or any value\n    // - _args.interestRateTimestamp: can be set to any timestamp\n    \n    // These inputs directly determine the new k value:\n    // utilization = debtAssets / (collateralAssets + debtAssets)\n    // k = adjust_k_based_on_utilization()\n    \n    // Result: attacker can force k toward kmin or kmax\n    // modelState.k is updated to this attacker-controlled value\n    modelState.k = newK;  // @audit Updated based on attacker parameters\n}"
    },
    "context_files": [
      {
        "name": "Model State Definition",
        "path": "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol",
        "relevance": "Shows the state variables that are modified by the vulnerable function",
        "content": "contract DynamicKinkModel is IDynamicKinkModel {\n    // State that stores the critical k parameter\n    ModelState internal modelState;\n    \n    struct ModelState {\n        uint256 k;                    // @audit CRITICAL: Updated by unprotected function\n        address silo;                 // Address of associated Silo\n        uint256 lastUpdateTimestamp;\n        Config activeConfig;          // Current active configuration\n    }\n    \n    // The k value is the slope parameter in the interest rate formula:\n    // interestRate = baseRate + k * utilization^2\n    // k determines how aggressively rates increase with utilization\n    // The entire protocol depends on k being set to optimal values\n    \n    // VULNERABILITY: No protection on who can call getCompoundInterestRateAndUpdate()\n    // which modifies modelState.k\n}"
      },
      {
        "name": "Interest Rate Calculation Using k",
        "path": "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol",
        "relevance": "Shows how k is used in the core interest rate formula",
        "content": "// Interest rate formula depends on k:\nfunction _calculateInterestRate(ModelState memory state, uint256 utilization)\n    internal\n    pure\n    returns (uint256 rate)\n{\n    // Rate increases quadratically with utilization\n    // The k parameter controls the sensitivity\n    uint256 u_squared = utilization * utilization;\n    \n    // Interest rate = baseRate + k * (utilization^2)\n    // If k is artificially low (attacker sets to kmin):\n    //   - All interest rates become depressed\n    //   - Borrowers profit from cheap borrowing\n    //   - Lenders suffer from reduced returns\n    //\n    // If k is artificially high (attacker sets to kmax):\n    //   - All interest rates become inflated\n    //   - Borrowers face expensive debt\n    //   - Market participation drops\n    \n    rate = baseRate + (k * u_squared) / SCALAR;\n    return rate;\n}\n\n// IMPACT: Every interest rate calculation depends on k\n// Attacker controlling k = attacker controlling all rates"
      },
      {
        "name": "Proof of Concept Attack",
        "path": "silo-core/contracts/interestRateModel/kink/tests/DynamicKinkModel.t.sol",
        "relevance": "Shows concrete exploit of the missing access control",
        "content": "function test_attackerManipulatesK() public {\n    // Setup: Market has evolved to stable k value\n    uint256 kBefore = irm.modelState().k;\n    console2.log(\"k before attack: %s\", kBefore);\n    // Output: k before attack: 2000000000 (optimized for 50% utilization)\n    \n    // EXPLOIT: Attacker (random address) calls the unprotected function\n    address attacker = makeAddr(\"attacker\");\n    vm.prank(attacker);\n    \n    // Attack scenario 1: Set k to minimum by claiming 100% utilization\n    // (debtAssets >> collateralAssets)\n    irm.getCompoundInterestRateAndUpdate({\n        _collateralAssets: 0,           // Zero collateral\n        _debtAssets: 1000000 ether,     // Large debt\n        _interestRateTimestamp: block.timestamp\n    });\n    \n    // Check k after first attack\n    uint256 kAfter = irm.modelState().k;\n    console2.log(\"k after first attack (100%% util): %s\", kAfter);\n    // Output: k after first attack: 1000000000 (kmin, rates dropped)\n    \n    // Attack scenario 2: Set k to maximum by claiming 0% utilization\n    // (debtAssets << collateralAssets)\n    vm.prank(attacker);\n    irm.getCompoundInterestRateAndUpdate({\n        _collateralAssets: 1000000 ether,  // Large collateral\n        _debtAssets: 0,                     // Zero debt\n        _interestRateTimestamp: block.timestamp\n    });\n    \n    // Check k after second attack\n    uint256 kFinal = irm.modelState().k;\n    console2.log(\"k after second attack (0%% util): %s\", kFinal);\n    // Output: k after second attack: 3000000000 (kmax, rates spiked)\n    \n    // PROOF OF VULNERABILITY:\n    // Random attacker successfully modified critical protocol parameter\n    // k swung from 2B → 1B → 3B with no authorization\n    // Interest rates completely corrupted\n    assertTrue(kBefore != kAfter, \"Attacker modified k!\");\n    assertTrue(kAfter != kFinal, \"Attacker modified k again!\");\n}"
      }
    ],
    "call_flow": [
      "1. Attacker identifies getCompoundInterestRateAndUpdate() is unprotected",
      "2. Attacker crafts parameters to manipulate utilization calculation",
      "3. Attacker calls function directly (msg.sender = attacker address)",
      "4. No require() check validates msg.sender == modelState.silo",
      "5. Function proceeds to _getCompoundInterestRate() with attacker's parameters",
      "6. Utilization calculated from attacker's controlled values",
      "7. New k computed based on attacker's utilization",
      "8. modelState.k updated to attacker's desired value",
      "9. Interest rate calculations now use corrupted k",
      "10. All borrowing/lending affected by wrong rates",
      "11. Attacker can repeat attack to adjust k further",
      "12. Market rates remain manipulated until protocol intervenes",
      "13. Borrowers/lenders lose/gain depending on rate direction",
      "14. Economic incentives completely broken"
    ],
    "context_hint": "This is a classic missing access control vulnerability on a state-modifying function. The function is meant for internal protocol use (Silo calling the interest rate model), but is exposed as external with no authentication check. An external caller can invoke it and control the critical k parameter.",
    "expert_notes": "Cantina identified this through access control analysis. The vulnerability is straightforward: a function that modifies critical state lacks any check that the caller is authorized. The fix is simple - add a require() check at the beginning of the function. The difficulty is in understanding why this function exists and who should call it (only the associated Silo).",
    "fix_description": "Add an explicit access control check at the beginning of getCompoundInterestRateAndUpdate() to verify that msg.sender is the stored Silo address. This ensures only the Silo can modify the k parameter.",
    "fix_code": "// FIXED: Access control added\nfunction getCompoundInterestRateAndUpdate(\n    uint256 _collateralAssets,\n    uint256 _debtAssets,\n    uint256 _interestRateTimestamp\n)\n    external\n    virtual\n    returns (uint256 rcomp)\n{\n    // FIX: Verify caller is the Silo\n    require(msg.sender == modelState.silo, InvalidSilo());\n    \n    (rcomp, modelState.k) = _getCompoundInterestRate(CompoundInterestRateArgs({\n        silo: modelState.silo,\n        collateralAssets: _collateralAssets,\n        debtAssets: _debtAssets,\n        interestRateTimestamp: _interestRateTimestamp,\n        blockTimestamp: block.timestamp,\n        usePending: false\n    }));\n}\n\n// RESULT:\n// - Only the Silo can call this function\n// - k can no longer be arbitrarily manipulated\n// - Interest rates are determined by legitimate market utilization\n// - Protocol stability maintained"
  },
  {
    "id": "gs_cantina_silo_dynamic_kink_002",
    "report_url": "https://cantina.xyz/portfolio/01da8f41-fa9f-4239-95f5-52d05cd34b8c",
    "project_name": "Silo Finance: Dynamic Kink Model",
    "github_url": "https://github.com/silo-finance/silo-contracts-v2",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-09-30",
    "vulnerability_type": "state_desynchronization",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "interest_rate_model",
    "is_vulnerable": true,
    "title": "Configuration Update Immediately Modifies k - Timelock Bypass",
    "description": "When the owner initiates a new configuration update with a timelock delay, the setConfig() function immediately resets the current k value to kmin of the new configuration, even though the new configuration isn't officially active yet. This premature state change violates the timelock mechanism's intent to provide a grace period before sensitive changes take effect. Developers expect k to remain unchanged during the timelock period. If the owner cancels the update, k is not restored, leaving the system in a corrupted state. This breaks the no-op guarantee of cancelled transactions.",
    "primary_file": {
      "name": "DynamicKinkModel.sol",
      "path": "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol",
      "lines": "200-220",
      "content": "// VULNERABLE: Configuration update immediately changes k\nfunction setConfig(IDynamicKinkModel.Config calldata _config) \n    external \n    onlyOwner \n{\n    // Validation of new config\n    IRM.verifyConfig(_config);\n    \n    // Schedule the new configuration to activate at future time\n    pendingConfig = _config;\n    pendingConfigActivationTime = block.timestamp + TIMELOCK_DURATION;\n    \n    // @audit BUG: k is reset to kmin immediately\n    // This happens even though new config isn't officially active yet\n    // The timelock is supposed to delay this change, but it doesn't\n    modelState.k = _config.kmin;\n    \n    emit ConfigUpdateScheduled(_config, pendingConfigActivationTime);\n}\n\n// Expected behavior (per timelock pattern):\n// - Schedule config change without modifying state\n// - Timelock period elapses\n// - Owner calls activateConfig() to apply scheduled changes\n// - NOW k should be updated\n//\n// Actual (vulnerable) behavior:\n// - Owner calls setConfig()\n// - k is IMMEDIATELY updated (timelock does nothing)\n// - Market experiences unexpected rate changes\n// - If owner cancels, k is NOT restored (system corrupted)"
    },
    "context_files": [
      {
        "name": "Configuration Activation Function",
        "path": "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol",
        "relevance": "Shows how configuration is supposed to be applied after timelock",
        "content": "// Configuration activation after timelock elapses\nfunction activateConfig() external {\n    require(block.timestamp >= pendingConfigActivationTime, \"Timelock not elapsed\");\n    require(pendingConfig != address(0), \"No pending config\");\n    \n    // This function is supposed to apply all config changes\n    // Including updating k to the new kmin\n    activeConfig = pendingConfig;\n    modelState.k = pendingConfig.kmin;  // k is updated here in fixed version\n    pendingConfig = address(0);\n    \n    emit ConfigActivated(activeConfig);\n}\n\n// VULNERABILITY:\n// setConfig() updates modelState.k immediately\n// activateConfig() also updates modelState.k\n// Result: k is changed twice - once immediately, once after timelock\n// This breaks the intended behavior of having k changed only on activation"
      },
      {
        "name": "Configuration Cancellation",
        "path": "silo-core/contracts/interestRateModel/kink/DynamicKinkModel.sol",
        "relevance": "Shows the cancellation scenario where k is not restored",
        "content": "// Cancel pending configuration update\nfunction cancelPendingConfig() external onlyOwner {\n    // This function clears the pending config\n    pendingConfig = address(0);\n    pendingConfigActivationTime = 0;\n    \n    // @audit BUG: modelState.k is NOT restored\n    // If setConfig() updated k immediately, it remains changed\n    // This should be a no-op but leaves k in wrong state\n    \n    emit ConfigCancelled();\n}\n\n// SCENARIO:\n// 1. Market k = 2000000000 (optimized for current utilization)\n// 2. Owner calls setConfig(newConfig) with kmin = 1200000000\n// 3. k immediately changes to 1200000000 (8% drop in rates)\n// 4. Market experiences rate shock for 3 days\n// 5. Owner decides new config was wrong, calls cancelPendingConfig()\n// 6. pendingConfig cleared but k is STILL 1200000000\n// 7. Interest rates remain depressed indefinitely\n// 8. This should have been a no-op (revert all changes) but isn't"
      },
      {
        "name": "Proof of Concept Attack",
        "path": "silo-core/contracts/interestRateModel/kink/tests/DynamicKinkModel.t.sol",
        "relevance": "Shows concrete scenario where timelock is effectively bypassed",
        "content": "function test_configUpdateBypassesTimelock() public {\n    // Setup: Market with evolved k value\n    uint256 kBefore = irm.modelState().k;\n    console2.log(\"k before config update: %s\", kBefore);\n    // Output: k before config update: 2000000000\n    \n    // Owner creates new configuration\n    IDynamicKinkModel.Config memory newConfig = _createConfig({\n        kmin: 1200000000,  // 40% lower than current k\n        kmax: 3200000000,\n        u1: 45e18,\n        u2: 75e18\n    });\n    \n    // Owner initiates update with 1 week timelock\n    vm.prank(owner);\n    irm.setConfig(newConfig);\n    \n    // Check k immediately (should be unchanged, but isn't)\n    uint256 kAfterSetConfig = irm.modelState().k;\n    console2.log(\"k immediately after setConfig: %s\", kAfterSetConfig);\n    // Output: k immediately after setConfig: 1200000000\n    // BUG: k changed before timelock elapsed!\n    \n    // Verify: k was changed despite timelock not elapsing\n    assertEq(kAfterSetConfig, newConfig.kmin, \"k updated immediately\");\n    assertNotEq(kBefore, kAfterSetConfig, \"k changed before timelock\");\n    \n    // Market operates with reduced rates for several days\n    vm.warp(block.timestamp + 3 days);\n    \n    // Owner realizes mistake and cancels\n    vm.prank(owner);\n    irm.cancelPendingConfig();\n    \n    // Check k after cancellation\n    uint256 kAfterCancel = irm.modelState().k;\n    console2.log(\"k after cancellation: %s\", kAfterCancel);\n    // Output: k after cancellation: 1200000000\n    // BUG: k is NOT restored!\n    \n    // Verify: k is stuck at wrong value\n    assertNotEq(kAfterCancel, kBefore, \"k should be restored but isn't\");\n    assertEq(kAfterCancel, newConfig.kmin, \"k is stuck at new kmin\");\n    \n    // IMPACT: Cancellation was supposed to be a no-op\n    // But k remains changed, affecting all future interest rates\n}"
      }
    ],
    "call_flow": [
      "1. Owner calls setConfig(newConfig) to schedule a configuration update",
      "2. Owner intends: schedule change, wait timelock, then activate",
      "3. But setConfig() immediately updates modelState.k to newConfig.kmin",
      "4. Timelock only prevents activateConfig() from being called early",
      "5. k is already changed, so timelock provides zero protection",
      "6. Market experiences interest rate changes immediately",
      "7. All participants see sudden rate shifts with no warning",
      "8. If owner cancels within timelock period:",
      "9. cancelPendingConfig() clears pendingConfig",
      "10. But modelState.k is NOT restored to pre-setConfig value",
      "11. Configuration cancelled but k remains in wrong state",
      "12. This violates the invariant that cancelled = no change",
      "13. Interest rates remain corrupted indefinitely",
      "14. Protocol stability compromised until manual intervention"
    ],
    "context_hint": "This is a state desynchronization vulnerability where two related pieces of state (pending configuration and k value) get out of sync. The k value changes before the configuration officially activates. If the configuration is cancelled, k is not rolled back. This breaks the atomicity guarantees expected from a timelock mechanism.",
    "expert_notes": "Cantina identified this through state machine analysis. The pattern is: separate scheduling from activation (to allow timelock), but then inadvertently update a related state variable during scheduling instead of deferring it until activation. The fix is to defer k updates until the activation function, not do them in setConfig().",
    "fix_description": "Move the modelState.k update from setConfig() to activateConfig(). This ensures k only changes when the configuration is officially activated, preserving the timelock's protective grace period. If a configuration is cancelled, k remains unchanged.",
    "fix_code": "// FIXED: Defer k update until activation\nfunction setConfig(IDynamicKinkModel.Config calldata _config) \n    external \n    onlyOwner \n{\n    IRM.verifyConfig(_config);\n    \n    // Schedule configuration without modifying state\n    pendingConfig = _config;\n    pendingConfigActivationTime = block.timestamp + TIMELOCK_DURATION;\n    \n    // DO NOT update k here - it will be updated during activation\n    // modelState.k remains unchanged throughout the timelock period\n    \n    emit ConfigUpdateScheduled(_config, pendingConfigActivationTime);\n}\n\nfunction activateConfig() external {\n    require(block.timestamp >= pendingConfigActivationTime, \"Timelock not elapsed\");\n    require(pendingConfig != address(0), \"No pending config\");\n    \n    // NOW apply k change when configuration officially activates\n    activeConfig = pendingConfig;\n    modelState.k = pendingConfig.kmin;  // k updated here, not in setConfig()\n    pendingConfig = address(0);\n    \n    emit ConfigActivated(activeConfig);\n}\n\nfunction cancelPendingConfig() external onlyOwner {\n    // Clean cancellation - k was never changed, so nothing to restore\n    pendingConfig = address(0);\n    pendingConfigActivationTime = 0;\n    \n    emit ConfigCancelled();\n}\n\n// RESULT:\n// - setConfig() is now a pure state scheduling operation\n// - k remains stable throughout timelock period\n// - activateConfig() applies all changes atomically\n// - cancelPendingConfig() is truly a no-op"
  }
]
