[
  {
    "id": "gs_cantina_coinbase_001",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "base",
    "source_platform": "cantina",
    "source_report": "Coinbase Flywheel",
    "source_finding_id": "CRITICAL-1",
    "report_url": "https://cantina.xyz/portfolio/42fb7c2a-ff43-4d64-a061-67ee016f8d6d",
    "github_repo_url": "https://github.com/coinbase/flywheel-contracts",
    "contest_date": "2025-09-15",
    "severity": "critical",
    "vulnerability_type": "asset_locking",
    "difficulty_tier": 2,
    "context_level": "cross_contract",
    "finding_title": "Flywheel does not support native tokens, leading to funds being locked in campaigns",
    "finding_description": "The Campaign contract is designed to accept native tokens as a funding source, but its solvency checks do not support them. Functions that rely on _assertCampaignSolvency, such as send(), allocate(), deallocate(), distribute(), distributeFees(), and withdrawFunds(), will revert if the campaign holds native tokens. This results in any native tokens sent to Campaign contracts becoming permanently locked, as there is no mechanism to withdraw them once the solvency check starts failing.",
    "attack_scenario": "1. A user creates a campaign via Flywheel.createCampaign() and funds it with native tokens (ETH) by sending msg.value\n2. The native tokens are successfully transferred to the newly created Campaign contract\n3. Campaign contract now holds both native ETH and potentially ERC20 reward tokens\n4. The user later attempts to withdraw funds by calling withdrawFunds()\n5. The withdrawFunds() function calls _assertCampaignSolvency() before allowing withdrawal\n6. _assertCampaignSolvency() only checks ERC20 rewardToken balance, ignoring native token balance\n7. The solvency check fails because ERC20 balance < liabilities, even though total assets (ERC20 + native) would pass\n8. The transaction reverts with 'Campaign insolvency' error\n9. User's native tokens remain permanently locked in Campaign contract with no recovery mechanism\n10. Any attempts to call send(), allocate(), deallocate(), distribute(), or distributeFees() also fail due to same solvency check",
    "fix_description": "Add support for native token balance checks in the _assertCampaignSolvency() function. The fix should:\n1. Check if rewardToken is address(0) or a special constant representing native tokens\n2. If native token campaign: totalBalances = address(this).balance\n3. If ERC20 campaign: totalBalances = IERC20(rewardToken).balanceOf(address(this))\n4. Or support hybrid campaigns by summing both balances with proper accounting\n\nUpdated _assertCampaignSolvency():\n```solidity\nfunction _assertCampaignSolvency() internal view {\n    uint256 totalBalances;\n    if (rewardToken == address(0)) {\n        // Native token campaign\n        totalBalances = address(this).balance;\n    } else {\n        // ERC20 token campaign\n        totalBalances = IERC20(rewardToken).balanceOf(address(this));\n    }\n    uint256 totalLiabilities = totalRewardsDistributed + totalFeesCollected;\n    require(totalBalances >= totalLiabilities, \"Campaign insolvency\");\n}\n```",
    "primary_file": {
      "path": "src/Campaign.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Flywheel} from \"./Flywheel.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title Campaign\n * @notice Manages reward distribution campaigns for builders\n * @dev Vulnerable: Native token support missing in solvency checks\n */\ncontract Campaign {\n    using SafeERC20 for IERC20;\n\n    /// @dev The Flywheel contract that created this campaign\n    Flywheel public immutable flywheel;\n\n    /// @dev Campaign owner who can manage funds\n    address public owner;\n\n    /// @dev Campaign metadata and configuration\n    Flywheel.CampaignData public data;\n\n    /// @dev The implementation of the campaign hook for custom logic\n    address public immutable hook;\n\n    /// @dev The ERC-20 token used for rewards (address(0) for native tokens)\n    address public immutable rewardToken;\n\n    /// @dev The total amount of rewards distributed to builders\n    uint256 public totalRewardsDistributed;\n\n    /// @dev The total amount of fees collected by the protocol\n    uint256 public totalFeesCollected;\n\n    /// @dev Mapping of builder addresses to their allocated rewards\n    mapping(address => uint256) public allocatedRewards;\n\n    /// @dev Mapping of builder addresses to their already distributed rewards\n    mapping(address => uint256) public distributedRewards;\n\n    event RewardsSent(address indexed builder, uint256 amount);\n    event FundsWithdrawn(address indexed to, uint256 amount);\n    event RewardsAllocated(address indexed builder, uint256 amount);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    /**\n     * @notice Initialize a new campaign\n     * @param flywheel_ The Flywheel factory contract\n     * @param owner_ The campaign owner\n     * @param data_ Campaign configuration data\n     * @param hook_ Optional hook contract for custom logic\n     * @param rewardToken_ The token used for rewards (address(0) for native)\n     */\n    constructor(\n        address flywheel_,\n        address owner_,\n        Flywheel.CampaignData memory data_,\n        address hook_,\n        address rewardToken_\n    ) {\n        flywheel = Flywheel(flywheel_);\n        owner = owner_;\n        data = data_;\n        hook = hook_;\n        rewardToken = rewardToken_;\n    }\n\n    /**\n     * @notice Send rewards to builders\n     * @param builders Array of builder addresses\n     * @param contexts Additional context data for each builder\n     * @param amounts Reward amounts for each builder\n     */\n    function send(\n        address[] calldata builders,\n        bytes[] calldata contexts,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        // VULNERABILITY: This solvency check doesn't account for native tokens\n        _assertCampaignSolvency();\n        \n        require(builders.length == amounts.length, \"Length mismatch\");\n        require(builders.length == contexts.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < builders.length; i++) {\n            require(builders[i] != address(0), \"Invalid builder\");\n            require(amounts[i] > 0, \"Invalid amount\");\n\n            // Update accounting\n            allocatedRewards[builders[i]] += amounts[i];\n            distributedRewards[builders[i]] += amounts[i];\n            totalRewardsDistributed += amounts[i];\n\n            // Transfer rewards\n            if (rewardToken == address(0)) {\n                // Native token transfer\n                (bool success, ) = builders[i].call{value: amounts[i]}(\"\");\n                require(success, \"Transfer failed\");\n            } else {\n                // ERC20 transfer\n                IERC20(rewardToken).safeTransfer(builders[i], amounts[i]);\n            }\n\n            emit RewardsSent(builders[i], amounts[i]);\n        }\n    }\n\n    /**\n     * @notice Allocate rewards to builders without distributing\n     * @param builders Array of builder addresses\n     * @param amounts Amounts to allocate\n     */\n    function allocate(\n        address[] calldata builders,\n        uint256[] calldata amounts\n    ) external onlyOwner {\n        // VULNERABILITY: This solvency check doesn't account for native tokens\n        _assertCampaignSolvency();\n\n        require(builders.length == amounts.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < builders.length; i++) {\n            allocatedRewards[builders[i]] += amounts[i];\n            emit RewardsAllocated(builders[i], amounts[i]);\n        }\n    }\n\n    /**\n     * @notice Distribute previously allocated rewards\n     * @param builders Array of builder addresses\n     */\n    function distribute(address[] calldata builders) external onlyOwner {\n        // VULNERABILITY: This solvency check doesn't account for native tokens\n        _assertCampaignSolvency();\n\n        for (uint256 i = 0; i < builders.length; i++) {\n            uint256 allocated = allocatedRewards[builders[i]];\n            uint256 alreadyDistributed = distributedRewards[builders[i]];\n            uint256 toDistribute = allocated - alreadyDistributed;\n\n            if (toDistribute > 0) {\n                distributedRewards[builders[i]] = allocated;\n                totalRewardsDistributed += toDistribute;\n\n                if (rewardToken == address(0)) {\n                    (bool success, ) = builders[i].call{value: toDistribute}(\"\");\n                    require(success, \"Transfer failed\");\n                } else {\n                    IERC20(rewardToken).safeTransfer(builders[i], toDistribute);\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Distribute protocol fees\n     * @param feeRecipient Address to receive fees\n     * @param amount Fee amount to distribute\n     */\n    function distributeFees(address feeRecipient, uint256 amount) external {\n        require(msg.sender == address(flywheel), \"Only flywheel\");\n        // VULNERABILITY: This solvency check doesn't account for native tokens\n        _assertCampaignSolvency();\n\n        totalFeesCollected += amount;\n\n        if (rewardToken == address(0)) {\n            (bool success, ) = feeRecipient.call{value: amount}(\"\");\n            require(success, \"Transfer failed\");\n        } else {\n            IERC20(rewardToken).safeTransfer(feeRecipient, amount);\n        }\n    }\n\n    /**\n     * @notice Check if campaign has sufficient funds to cover liabilities\n     * @dev VULNERABILITY: Only checks ERC20 balance, ignores native token balance\n     */\n    function _assertCampaignSolvency() internal view {\n        // CRITICAL BUG: This only checks rewardToken balance\n        // If rewardToken is an ERC20 but campaign was funded with native tokens,\n        // this check will fail even though the contract has sufficient funds\n        uint256 totalBalances = IERC20(rewardToken).balanceOf(address(this));\n        \n        // Calculate total liabilities\n        uint256 totalLiabilities = totalRewardsDistributed + totalFeesCollected;\n        \n        // This require will fail if:\n        // 1. Campaign was funded with native tokens (ETH)\n        // 2. rewardToken points to an ERC20 address\n        // 3. The native token balance would be sufficient but isn't checked\n        require(totalBalances >= totalLiabilities, \"Campaign insolvency\");\n        \n        // MISSING: Check for native token balance\n        // Should be:\n        // if (rewardToken == address(0)) {\n        //     totalBalances = address(this).balance;\n        // } else {\n        //     totalBalances = IERC20(rewardToken).balanceOf(address(this));\n        // }\n    }\n\n    /**\n     * @notice Withdraw excess funds from campaign\n     * @param to Recipient address\n     * @param amount Amount to withdraw\n     * @dev VULNERABILITY: Calls solvency check that doesn't account for native tokens\n     */\n    function withdrawFunds(address to, uint256 amount) external onlyOwner {\n        // VULNERABILITY: This will revert if campaign has native tokens\n        // because _assertCampaignSolvency doesn't check native balance\n        _assertCampaignSolvency();\n        \n        require(to != address(0), \"Invalid address\");\n        require(amount > 0, \"Invalid amount\");\n\n        // Calculate available funds (this part correctly handles native tokens)\n        uint256 availableToWithdraw;\n        if (rewardToken == address(0)) {\n            availableToWithdraw = address(this).balance;\n        } else {\n            availableToWithdraw = IERC20(rewardToken).balanceOf(address(this));\n        }\n        \n        // Subtract liabilities\n        uint256 totalLiabilities = totalRewardsDistributed + totalFeesCollected;\n        require(availableToWithdraw >= totalLiabilities, \"Insufficient funds\");\n        availableToWithdraw -= totalLiabilities;\n\n        require(amount <= availableToWithdraw, \"Insufficient balance\");\n\n        // Transfer funds\n        if (rewardToken == address(0)) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"Transfer failed\");\n        } else {\n            IERC20(rewardToken).safeTransfer(to, amount);\n        }\n\n        emit FundsWithdrawn(to, amount);\n    }\n\n    /**\n     * @notice Accept native token deposits\n     */\n    receive() external payable {\n        // Native tokens can be sent here, but they can't be withdrawn\n        // due to the broken solvency check\n    }\n\n    /**\n     * @notice Get campaign solvency status\n     * @return isSolvent Whether campaign can cover its liabilities\n     * @return totalAssets Total assets held by campaign\n     * @return totalLiabilities Total liabilities owed\n     */\n    function getSolvencyStatus() external view returns (\n        bool isSolvent,\n        uint256 totalAssets,\n        uint256 totalLiabilities\n    ) {\n        if (rewardToken == address(0)) {\n            totalAssets = address(this).balance;\n        } else {\n            totalAssets = IERC20(rewardToken).balanceOf(address(this));\n        }\n        \n        totalLiabilities = totalRewardsDistributed + totalFeesCollected;\n        isSolvent = totalAssets >= totalLiabilities;\n    }\n}\n\n/**\n * @title Flywheel\n * @notice Factory contract for creating campaigns\n */\ncontract Flywheel {\n    struct CampaignData {\n        string name;\n        string description;\n        uint256 startTime;\n        uint256 endTime;\n    }\n\n    event CampaignCreated(address indexed campaign, address indexed owner);\n\n    /**\n     * @notice Create a new campaign\n     * @param data Campaign configuration\n     * @param hook Optional hook contract\n     * @param rewardToken Token for rewards (address(0) for native)\n     * @return campaign Address of created campaign\n     */\n    function createCampaign(\n        CampaignData memory data,\n        address hook,\n        address rewardToken\n    ) external payable returns (address campaign) {\n        // Deploy new campaign\n        campaign = address(new Campaign(\n            address(this),\n            msg.sender,\n            data,\n            hook,\n            rewardToken\n        ));\n\n        // Forward any native tokens sent\n        if (msg.value > 0) {\n            (bool success, ) = campaign.call{value: msg.value}(\"\");\n            require(success, \"Transfer failed\");\n        }\n\n        emit CampaignCreated(campaign, msg.sender);\n    }\n}\n\n/**\n * @title FundsLockingExploit\n * @notice Demonstrates how funds become permanently locked\n */\ncontract FundsLockingExploit {\n    Flywheel public flywheel;\n    Campaign public campaign;\n    \n    constructor(Flywheel _flywheel) {\n        flywheel = _flywheel;\n    }\n    \n    /**\n     * @notice Demonstrate the vulnerability\n     */\n    function demonstrateLocking() external payable {\n        // Step 1: Create campaign with native tokens\n        Flywheel.CampaignData memory data = Flywheel.CampaignData({\n            name: \"Test Campaign\",\n            description: \"Demo\",\n            startTime: block.timestamp,\n            endTime: block.timestamp + 30 days\n        });\n        \n        // Create campaign with ERC20 token but fund with native tokens\n        // This is a common mistake - user intends to use native tokens\n        // but accidentally specifies an ERC20 address\n        address someERC20 = address(0x1234); // Some ERC20 token\n        campaign = Campaign(flywheel.createCampaign{value: 10 ether}(\n            data,\n            address(0),\n            someERC20 // BUG: Specified ERC20 but funded with native tokens\n        ));\n        \n        // Step 2: Campaign now has 10 ETH but solvency checks ERC20 balance\n        \n        // Step 3: Try to withdraw - this will REVERT\n        // because _assertCampaignSolvency checks ERC20 balance (0)\n        // against liabilities (0), which passes\n        // But wait - if we try after any rewards distributed, it fails:\n        \n        // Allocate some rewards\n        address[] memory builders = new address[](1);\n        builders[0] = address(this);\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = 1 ether;\n        \n        // This will revert because:\n        // - totalRewardsDistributed = 1 ether\n        // - ERC20 balance = 0\n        // - 0 < 1 ether = REVERT\n        // Even though native balance is 10 ether!\n        campaign.allocate(builders, amounts);\n        \n        // Now the 10 ETH is permanently locked\n        // Can't withdraw, can't distribute, can't do anything\n    }\n}",
      "vulnerable_lines": [200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220],
      "vulnerable_functions": ["_assertCampaignSolvency", "send", "allocate", "distribute", "distributeFees", "withdrawFunds"]
    },
    "context_files": [
      {
        "path": "src/Flywheel.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Campaign} from \"./Campaign.sol\";\n\n/**\n * @title Flywheel\n * @notice Factory contract for creating and managing reward campaigns\n */\ncontract Flywheel {\n    struct CampaignData {\n        string name;\n        string description;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 totalBudget;\n    }\n\n    mapping(address => bool) public isCampaign;\n    address[] public allCampaigns;\n\n    event CampaignCreated(\n        address indexed campaign,\n        address indexed owner,\n        address rewardToken,\n        uint256 initialFunding\n    );\n\n    /**\n     * @notice Create a new reward campaign\n     * @param data Campaign metadata and configuration\n     * @param hook Optional hook contract for custom logic\n     * @param rewardToken Token used for rewards (address(0) for native)\n     * @return campaign Address of the deployed Campaign contract\n     */\n    function createCampaign(\n        CampaignData memory data,\n        address hook,\n        address rewardToken\n    ) external payable returns (address campaign) {\n        // Deploy new Campaign contract\n        campaign = address(new Campaign(\n            address(this),\n            msg.sender,\n            data,\n            hook,\n            rewardToken\n        ));\n\n        // Register campaign\n        isCampaign[campaign] = true;\n        allCampaigns.push(campaign);\n\n        // Forward any native tokens sent with the transaction\n        // This is where the vulnerability is introduced:\n        // User can fund with native tokens regardless of rewardToken setting\n        if (msg.value > 0) {\n            (bool success, ) = campaign.call{value: msg.value}(\"\");\n            require(success, \"Initial funding transfer failed\");\n        }\n\n        emit CampaignCreated(campaign, msg.sender, rewardToken, msg.value);\n        return campaign;\n    }\n\n    /**\n     * @notice Get total number of campaigns\n     */\n    function getCampaignCount() external view returns (uint256) {\n        return allCampaigns.length;\n    }\n}",
        "relevance": "The Flywheel factory contract shows how campaigns are created and initially funded. The createCampaign function accepts msg.value and forwards it to the Campaign contract regardless of whether rewardToken is set to address(0) or an ERC20 address. This creates the conditions for the vulnerability where native tokens can be sent to a campaign configured for ERC20 rewards."
      }
    ],
    "call_flow": "User.createCampaign{value: 10 ETH}(rewardToken=ERC20) -> Flywheel.createCampaign() -> new Campaign() -> forwards ETH to Campaign -> Campaign now has ETH but expects ERC20 -> User.withdrawFunds() -> Campaign._assertCampaignSolvency() -> checks IERC20(rewardToken).balanceOf() = 0 -> ignores address(this).balance = 10 ETH -> requires(0 >= 0) passes initially -> User.allocate(1 ETH) -> _assertCampaignSolvency() -> requires(0 >= 1 ETH) REVERTS -> funds permanently locked",
    "context_hint": "This vulnerability represents a critical mismatch between asset handling and accounting. The Campaign contract supports both native tokens and ERC20 tokens for transfers (as evidenced by the conditional logic in send(), distribute(), and withdrawFunds()), but the solvency validation only checks ERC20 balances. This creates a severe disconnect: funds can enter and would normally be transferrable, but the solvency guard prevents all operations. The root cause is incomplete refactoring - someone added native token transfer support but forgot to update the solvency checks. This is particularly dangerous because: (1) The contract accepts native tokens via receive(), (2) The Flywheel factory forwards msg.value regardless of rewardToken configuration, (3) Once any liabilities exist (allocations, distributions, fees), all operations lock up permanently, (4) There's no emergency withdrawal function that bypasses solvency checks. The vulnerability affects ALL campaign operations, not just withdrawals, making it a complete denial of service once triggered.",
    "is_vulnerable": true,
    "expert_notes": "This is a critical asset locking vulnerability caused by incomplete dual-asset support. Key insights: (1) The contract architecture shows clear intent to support both native and ERC20 tokens (conditional transfers, receive() function), but validation logic was not updated, (2) This represents a common refactoring bug - adding feature support in some functions but missing critical validation paths, (3) The severity is amplified because it affects a factory pattern - multiple campaign instances can be affected, (4) The lock is permanent and unrecoverable without contract upgrade or migration, (5) Unlike typical reentrancy or overflow bugs, this is a logic flaw that's harder to catch with automated tools. Real-world parallels: Parity wallet freeze ($280M locked), various bridge contracts with incomplete multi-asset support. Defense strategies: (1) Comprehensive integration testing with all supported asset types, (2) Formal verification of solvency invariants across all functions, (3) Emergency recovery mechanisms with timelock governance, (4) Asset-type checks in constructor to prevent misconfiguration, (5) Clear documentation about supported funding methods. The fix requires updating _assertCampaignSolvency to check address(this).balance when rewardToken == address(0), and potentially adding a token-type validation in constructor to prevent ERC20 campaigns from accepting native tokens."
  }
]