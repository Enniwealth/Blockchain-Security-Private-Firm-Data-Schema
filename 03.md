{
  "id": "gs_quantstamp_strata_strt001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Strata Tranches",
  "source_finding_id": "STR-T-1",
  "report_url": "https://certificate.quantstamp.com/full/strata-tranches/",
  "github_repo_url": "https://github.com/Stratapad/tranches-contracts",
  "contest_date": "2025-10-09",
  "severity": "medium",
  "vulnerability_type": "rounding_error",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "Decimal Precision Normalization Missing in Slippage Calculation",
  "finding_description": "The deposit_viaSwap() function in TrancheDepositor does not normalize decimal differences between the input swap token and the tranche's base asset. When a user deposits a 6-decimal asset (USDC) into a tranche designed for 18-decimal assets (USDe), the slippage protection uses the wrong decimal scale, causing the transaction to be vulnerable to 99%+ MEV extraction despite slippage parameters being set.",
  "attack_scenario": "1. User wants to deposit 1000 USDC (1000e6 wei) into USDe tranche\n2. USDe has 18 decimals, expected deposit value = 1000e18 wei\n3. User specifies minDepositAmount = 995e18 (0.5% slippage tolerance)\n4. deposit_viaSwap() routes through DEX: USDC → USDe at market rate 1:1 (before MEV)\n5. Attacker sandwiches: depletes USDC liquidity, inflating USDe price\n6. User's 1000 USDC converted to only 10 USDe instead of 1000e18 USDe\n7. Slippage check compares: 10 USDe vs minDepositAmount (which is interpreted as 10 when decimals not normalized)\n8. Check passes: 10 >= 10, transaction succeeds\n9. User receives 10 USDe worth ~$10 instead of $1000\n10. Attacker backruns: profits from price recovery, extracts $990 of value",
  "fix_description": "Normalize decimal differences before slippage validation. In deposit_viaSwap(): (1) Query decimals of both tokens: uint8 inDecimals = IERC20Metadata(inToken).decimals(); uint8 outDecimals = IERC20Metadata(outToken).decimals(); (2) Calculate decimal offset: int8 decimalDiff = int8(outDecimals) - int8(inDecimals); (3) Scale slippage amounts: if (decimalDiff > 0) { minDepositAmount = minDepositAmount / (10 ** uint8(decimalDiff)); } else { minDepositAmount = minDepositAmount * (10 ** uint8(-decimalDiff)); } (4) Then perform slippage check on normalized amounts. Alternatively, always normalize to 18 decimals before comparisons.",
  "primary_file": {
    "path": "contracts/tranches/TrancheDepositor.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IDEXRouter {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ncontract TrancheDepositor {\n    IERC20 public inToken;\n    IERC20 public outToken;\n    IDEXRouter public dexRouter;\n    \n    event DepositViaSwap(address indexed user, uint256 amountIn, uint256 amountOut);\n    \n    function deposit_viaSwap(\n        uint256 amountIn,\n        uint256 minDepositAmount,\n        address[] calldata path,\n        uint256 deadline\n    ) public returns (uint256) {\n        require(amountIn > 0, \"Zero amount\");\n        require(path.length >= 2, \"Invalid path\");\n        \n        // Approve DEX\n        inToken.approve(address(dexRouter), amountIn);\n        \n        // VULNERABLE: No decimal normalization for slippage check\n        // If inToken is USDC (6 decimals) and outToken is USDe (18 decimals)\n        // User specifies minDepositAmount = 995e18 (995 USDe minimum)\n        // But after swap, amountOut is in USDe's 18-decimal scale\n        // Without normalization, comparison is wrong\n        \n        // Swap inToken → outToken\n        address[] memory swapPath = new address[](path.length);\n        for (uint i = 0; i < path.length; i++) {\n            swapPath[i] = path[i];\n        }\n        \n        uint256[] memory amounts = dexRouter.swapExactTokensForTokens(\n            amountIn,\n            minDepositAmount,  // VULNERABLE: Passed directly without decimal scaling\n            swapPath,\n            address(this),\n            deadline\n        );\n        \n        uint256 amountOut = amounts[amounts.length - 1];\n        \n        // VULNERABLE: Slippage check doesn't account for decimal differences\n        // If USDC input (6 decimals) swapped to USDe (18 decimals):\n        // 1000 USDC (1000e6) should give ~1000e18 USDe\n        // But if MEV inflates price and gives only 10 USDe (10e18)\n        // minDepositAmount=995e18 would FAIL the check\n        // UNLESS decimals weren't normalized, then check becomes meaningless\n        \n        require(amountOut >= minDepositAmount, \"Slippage exceeded\");\n        \n        emit DepositViaSwap(msg.sender, amountIn, amountOut);\n        return amountOut;\n    }\n    \n    // CORRECT VERSION WITH DECIMAL NORMALIZATION:\n    function deposit_viaSwap_fixed(\n        uint256 amountIn,\n        uint256 minDepositAmount,\n        address[] calldata path,\n        uint256 deadline\n    ) public returns (uint256) {\n        require(amountIn > 0, \"Zero amount\");\n        require(path.length >= 2, \"Invalid path\");\n        \n        uint8 inDecimals = IERC20Metadata(path[0]).decimals();\n        uint8 outDecimals = IERC20Metadata(path[path.length - 1]).decimals();\n        \n        // Normalize slippage amount to outToken decimals\n        uint256 normalizedMinAmount = minDepositAmount;\n        if (outDecimals < inDecimals) {\n            normalizedMinAmount = minDepositAmount / (10 ** (inDecimals - outDecimals));\n        } else if (outDecimals > inDecimals) {\n            normalizedMinAmount = minDepositAmount * (10 ** (outDecimals - inDecimals));\n        }\n        \n        inToken.approve(address(dexRouter), amountIn);\n        \n        uint256[] memory amounts = dexRouter.swapExactTokensForTokens(\n            amountIn,\n            normalizedMinAmount,\n            path,\n            address(this),\n            deadline\n        );\n        \n        uint256 amountOut = amounts[amounts.length - 1];\n        require(amountOut >= normalizedMinAmount, \"Slippage exceeded\");\n        \n        emit DepositViaSwap(msg.sender, amountIn, amountOut);\n        return amountOut;\n    }\n}\n",
    "vulnerable_lines": [49, 50, 51, 52, 53, 54, 55, 56],
    "vulnerable_functions": ["deposit_viaSwap"]
  },
  "context_files": [],
  "call_flow": "User calls deposit_viaSwap(1000 USDC, minAmount=995e18, path=[USDC, USDe]) → DEX swaps without decimal normalization → Slippage check ignores decimal mismatch → MEV succeeds despite slippage protection → User receives ~1% of expected value",
  "context_hint": "Slippage protection only works if the minimum amount is compared against the output using the same decimal scale. When input and output have different decimal places, the comparison becomes meaningless without normalization. This is particularly dangerous in tranches that use stable assets across multiple decimal standards (USDC=6, USDe=18, DAI=18, USDT=6).",
  "is_vulnerable": true,
  "expert_notes": "This vulnerability combines two common mistakes: (1) assuming all ERC20 tokens have 18 decimals, and (2) not normalizing values before comparison operations. The fix is straightforward but critical: always convert to a common decimal baseline (usually 18) before performing amount comparisons. This pattern appears in many DEX-integrated protocols where slippage protection becomes ineffective due to decimal mismatches."
}
