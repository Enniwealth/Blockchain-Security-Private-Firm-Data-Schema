[
  {
    "id": "gs_cantina_infinifi_pr228_001",
    "report_url": "https://cantina.xyz/portfolio/e6a0c02c-b177-4c51-8483-8fe34f27b6a6",
    "project_name": "infiniFi PR 228",
    "github_url": "https://github.com/InfiniFi-Labs/infinifi-contracts/pull/228",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-09",
    "vulnerability_type": "accounting_error",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "yield_distribution",
    "is_vulnerable": true,
    "title": "Loss Handling Ignores Smoothing Queue, Causing Double-Punishment of Lockers Through Over-Slashing",
    "description": "YieldSharingV2.accrue() calculates losses based on unaccruedYield() without first consuming the matured balance sitting in JCurveSmoother. When accrue() processes losses while the smoother has vested rewards, it immediately slashes lockers via _handleNegativeYield before those queued tokens can offset the loss. The slashed tokens are then later burned at a reduced price if a price cut occurs, causing lockers to absorb losses twice: once during the slash and again when the queue depreciates.",
    "primary_file": {
      "name": "YieldSharingV2.sol",
      "path": "src/YieldSharingV2.sol",
      "lines": "200-260",
      "content": "function accrue() external {\n    // BUG: Doesn't net smoother balance before measuring loss\n    uint256 unaccruedYield = _getUnaccruedYield();\n    \n    if (unaccruedYield < 0) {\n        // Negative yield path\n        uint256 negativeYield = uint256(-unaccruedYield);\n        \n        // BUG: Applies losses immediately without considering smoother queue\n        _handleNegativeYield(negativeYield);\n    } else {\n        _handlePositiveYield(unaccruedYield);\n    }\n}\n\nfunction _handleNegativeYield(uint256 _negativeYield) internal {\n    // Gets total locker balance\n    uint256 lockingReceiptTokens = LockingController(lockingModule)\n        .totalBalance();\n    \n    // BUG: This slash happens BEFORE consuming smoother queue\n    // The smoother may have matured rewards that could offset this loss\n    if (_negativeYield <= lockingReceiptTokens) {\n        // Loss fits in locker buffer\n        LockingController(lockingModule).applyLosses(_negativeYield);\n        return;\n    }\n    \n    // Loss exceeds locker buffer, marches down waterfall\n    LockingController(lockingModule).applyLosses(lockingReceiptTokens);\n    \n    // Remaining loss hits other parties\n    uint256 remainingLoss = _negativeYield - lockingReceiptTokens;\n    \n    // ... rest of waterfall ...\n    \n    // VULNERABILITY SCENARIO:\n    // State before accrue():\n    // - lockingReceiptTokens = 1000\n    // - smoother.vested() = 500 (matured rewards waiting to burn)\n    // - unaccruedYield = -800 (negative yield)\n    //\n    // Execution of accrue():\n    // 1. Calls _handleNegativeYield(-800)\n    // 2. Checks: 800 <= 1000? YES\n    // 3. applyLosses(800) on lockers\n    //    - All 800 loss hits lockers\n    //    - Lock receipt tokens reduced from 1000 to 200\n    //\n    // But the smoother has 500 matured tokens!\n    // Those 500 tokens could have offset 500 of the loss\n    // Actual loss should be: 800 - 500 = 300 (not 800)\n    // \n    // Then later:\n    // 4. JCurveSmoother.distribute() is called\n    // 5. Smoother burns its 500 matured tokens\n    //    burn(500)\n    // 6. If a price cut happens at this point:\n    //    newPrice = price * (totalSupply - loss) / totalSupply\n    //    The 500 queued tokens are ALREADY burned but price cut includes them\n    // 7. Everyone takes a haircut on the now-burned tokens\n    //\n    // Net result on lockers:\n    // - First hit: -800 in applyLosses\n    // - Second hit: haircut on 500 when price adjusts for burned queue\n    // - Total hit: more than the actual 300 loss\n}\n\n// DOUBLE-PUNISHMENT FLOW:\n// Stage 1: Loss Detection\n// - unaccruedYield = -800\n// - smoother.vested() = 500 (known but not netted)\n// - Actual net loss = 800 - 500 = 300\n// \n// Stage 2: Premature Slash (Bug)\n// - applyLosses(800) applied to lockers\n// - Lockers think they absorbed 800 loss\n// - But 500 of that could have been offset\n// - Lockers over-slashed by 500\n// \n// Stage 3: Queue Burn\n// - Later, JCurveSmoother.distribute() burns 500\n// - receipt token supply is reduced\n// - receiptToken.burn(500)\n// \n// Stage 4: Price Cut (If loss is large)\n// - If loss is large enough to reach oracle update:\n//   newPrice = price * (totalSupply - negativeYield) / totalSupply\n// - The 500 already-burned tokens are included in negativeYield\n// - Everyone (including lockers) takes haircut on those tokens\n// - Lockers hit AGAIN on the same tokens\n// \n// Lockers absorb:\n// - 500 over-slash from stage 2\n// - Haircut on 500 from stage 4\n// - Total: more than the actual 300 loss"
    },
    "context_files": [
      {
        "name": "JCurveSmoother Queue Management",
        "path": "src/JCurveSmoother.sol",
        "relevance": "Shows how rewards are queued and later burned",
        "content": "contract JCurveSmoother {\n    function accrueAndSmooth(uint256 yieldToSmooth) external {\n        // Mints tokens to smoother without immediately distributing\n        ReceiptToken(receiptToken).mint(\n            address(this),\n            yieldToSmooth\n        );\n        \n        // Interpolates the smoothing schedule\n        // These tokens will be burned over time via distribute()\n    }\n    \n    function distribute(bool _accrue) external {\n        // Burns matured rewards\n        uint256 _vested = vested();\n        \n        if (_vested != 0) {\n            // Removes tokens from supply\n            ReceiptToken(receiptToken).burn(_vested);\n        }\n        \n        if (_accrue) {\n            // Calls back to YieldSharing for accrual\n            YieldSharingV2(yieldSharing).accrue();\n        }\n    }\n    \n    // The problem:\n    // 1. accrueAndSmooth() mints tokens to itself (state: owned by smoother)\n    // 2. YieldSharingV2.accrue() can be called independently\n    // 3. If accrue() is called before distribute():\n    //    - Loss measured without accounting for smoother balance\n    //    - Losses applied prematurely\n    //    - Smoother tokens later burned at reduced price\n    // 4. If distribute() is called after accrue():\n    //    - Smoother burns its tokens\n    //    - If price cut happened, those tokens are included\n    //    - Lockers took loss twice"
      },
      {
        "name": "Receipt Token Price Adjustment",
        "path": "src/FixedPriceOracle.sol",
        "relevance": "Shows how price is adjusted when supply changes due to losses",
        "content": "function setPrice(uint256 _newPrice) external {\n    // Called during large losses\n    price = _newPrice;\n}\n\n// In YieldSharingV2._handleNegativeYield (if loss is large):\nif (propagateToOracle) {\n    uint256 totalSupply = ReceiptToken(receiptToken).totalSupply();\n    uint256 newPrice = price.mulDivDown(\n        totalSupply - _negativeYield,\n        totalSupply\n    );\n    FixedPriceOracle(oracle).setPrice(newPrice);\n}\n\n// Problem:\n// - totalSupply includes queued tokens from smoother\n// - If loss is 800 and smoother has 500 vested tokens:\n//   - Lockers hit with 800 loss\n//   - Later, 500 tokens burned\n//   - Then price adjusted: newPrice = price * (supply - 800) / supply\n//   - The 500 already-burned tokens are ALREADY out of supply\n//   - But the 800 loss calculation included them\n//   - Price cut treats them as losses when they're just distributed"
      },
      {
        "name": "Double-Punishment Scenario",
        "path": "reference/infinifi_double_slash.md",
        "relevance": "Documents the full attack scenario and impact",
        "content": "SCENARIO: Lockers Double-Punished Through Loss Ordering\n\nSetup:\n- Receipt token total supply: 2000\n- Locked tokens: 1000\n- Staked tokens: 500\n- JCurveSmoother queued: 500 (matured, waiting to distribute)\n- Receipt token price: $1.00\n- Annual yield target: 5%\n\nDay 1 - Positive Event (Smooth out over time):\n- Farm generates 500 in rewards\n- infiniFi calls jCurveSmoother.accrueAndSmooth(500)\n- Smoother mints 500 to itself\n- Receipt token supply: 2000 → 2500\n- Smoother starts interpolating: will burn 500 over 30 days\n- Day 1 state:\n  * Supply: 2500\n  * Smoother balance: 500\n  * Locker balance: 1000\n\nDay 2 - Negative Event (Loss occurs):\n- Market crash causes -800 loss in yield\n- unaccruedYield = -800\n- Backend immediately calls yieldSharing.accrue()\n\n(VULNERABILITY) Accrue Without Netting Smoother:\n\n1. YieldSharingV2.accrue() called\n2. Measures unaccruedYield = -800\n3. Calls _handleNegativeYield(800)\n4. Check: 800 <= 1000 (locker balance)? YES\n5. Applies applyLosses(800) to lockers\n   - Locker tokens reduced: 1000 → 200\n   - Locker suffers 800 loss\n\nBUT HERE'S THE PROBLEM:\n- Smoother has 500 matured tokens waiting\n- Those 500 could offset 500 of the 800 loss\n- Actual net loss should be: 800 - 500 = 300\n- Instead, lockers absorbed full 800\n- Lockers over-slashed by 500\n\nDay 3 - Queue Distribution:\n- Smoother has 400 remaining to distribute (50 burned already)\n- Backend calls jCurveSmoother.distribute(true)\n- Smoother burns remaining 400\n- Receipt token supply: 2500 - 400 = 2100\n\nDay 4 - Price Adjustment (if loss propagates to oracle):\n- If loss is large enough, price adjusts\n- newPrice = $1.00 * (2100 - 800) / 2100\n- newPrice = $1.00 * 1300 / 2100 = $0.619\n\nSecond Hit on Lockers:\n- All token holders (including lockers) see price drop\n- Locker's 200 remaining tokens:\n  * Previous value: 200 * $1.00 = $200\n  * New value: 200 * $0.619 = $123.80\n  * Loss: $76.20 (38%)\n- But these 200 tokens already absorbed the 800 loss!\n- They're being hit again on the smoothed tokens\n\nDouble-Punishment Summary:\n\n1. First Punishment (Day 2):\n   - Locker tokens: 1000 → 200 (800 loss)\n   - But 500 should have offset smoother queue\n   - Over-slashed by 500 (inflated loss)\n\n2. Second Punishment (Day 4):\n   - Price cut due to supply reduction from smoother burn\n   - 200 remaining tokens hit again\n   - Includes losses on tokens already distributed\n   - Locker hit again on the same event\n\nTotal Impact on Lockers:\n- Should absorb: 300 (actual net loss)\n- Actually absorb: 800 (first hit) + additional price cut (second hit)\n- Excess loss: 500+ (depending on price cut severity)\n\nWhy This Matters:\n- Smoother designed to buffer rewards, protecting others from volatility\n- But if accrue() ignores smoother, the buffer doesn't work\n- Lockers not only lose the buffer but are over-slashed\n- Then lose again when buffer is destroyed\n- Defeats purpose of smoothing mechanism"
      }
    ],
    "call_flow": [
      "1. JCurveSmoother.accrueAndSmooth(500) called with positive yield",
      "2. Smoother mints 500 tokens to itself",
      "3. Receipt token supply increases: 2000 → 2500",
      "4. Smoother starts interpolation schedule",
      "5. Market event causes -800 loss in yield",
      "6. unaccruedYield becomes -800",
      "7. YieldSharingV2.accrue() called",
      "8. _getUnaccruedYield() returns -800",
      "9. Calls _handleNegativeYield(800)",
      "10. Check: 800 <= lockingReceiptTokens (1000)? YES",
      "11. applyLosses(800) applied to lockers",
      "12. Locker tokens: 1000 → 200",
      "13. Lockers absorb full 800 loss (should be 300)",
      "14. Later: JCurveSmoother.distribute() called",
      "15. Smoother burns its 500 vested tokens",
      "16. Supply: 2500 → 2000",
      "17. Price adjusted: newPrice = price * (2000 - 800) / 2000",
      "18. All holders take price cut, including lockers",
      "19. Locker's 200 tokens hit again on supply reduction",
      "20. Lockers suffer double punishment"
    ],
    "context_hint": "This is a state synchronization and ordering bug. The loss calculation assumes the smoother queue is empty when making the loss determination, but the queue persists in storage and is processed separately later. The fix requires consuming the smoother queue atomically before measuring unaccruedYield, ensuring losses are netted against the actual available offset.",
    "expert_notes": "Cantina identified this as high-risk because it violates the intended invariant of the smoother design. The smoother is explicitly meant to protect lockers by buffering rewards, but improper ordering causes lockers to suffer worse outcomes than if the smoother didn't exist. The over-slashing creates a direct financial loss that could be significant in volatile markets. The team acknowledged but deferred fixing due to requiring a contract upgrade.",
    "fix_description": "Call JCurveSmoother.distribute(false) at the beginning of accrue() to consume and burn any vested tokens before measuring unaccruedYield. This ensures losses are netted against actual available assets and prevents the double-punishment scenario.",
    "fix_code": "function accrue() external {\n    // FIXED: Consume smoother queue before measuring yield\n    // This ensures losses are netted against available offsets\n    if (address(jCurveSmoother) != address(0)) {\n        JCurveSmoother(jCurveSmoother).distribute(false);\n        // Burns any vested tokens before accrual\n        // _accrue = false to avoid recursion\n    }\n    \n    // Now measure yield with smoother queue netted\n    int256 unaccruedYield = _getUnaccruedYield();\n    \n    if (unaccruedYield < 0) {\n        uint256 negativeYield = uint256(-unaccruedYield);\n        \n        // Loss now properly accounts for smoother consumption\n        // Example:\n        // - Measured loss: 800\n        // - Smoother burned: 500 (already removed from supply)\n        // - Actual net loss: 300\n        // - Lockers absorb: 300 (not 800)\n        \n        _handleNegativeYield(negativeYield);\n    } else {\n        _handlePositiveYield(unaccruedYield);\n    }\n}\n\n// With this fix:\n// Stage 1: accrue() called\n// Stage 2: smoother.distribute(false) burns 500 tokens\n// Stage 3: Supply reduced: 2500 → 2000\n// Stage 4: Loss measured: -800\n// Stage 5: But now: 2000 - 800 = 1200 remaining\n//          (no tokens to be burned later)\n// Stage 6: applyLosses(800) hits lockers\n//          But price cut is already reflected\n// Stage 7: No secondary price adjustment\n//          Lockers hit once with correct amount\n\n// Result:\n// - Actual loss: 800 (already accounts for smoother offset)\n// - Lockers absorb: 300 (800 - 500 smoother burn)\n// - No double-punishment\n// - Single, correct loss allocation"
  }
]