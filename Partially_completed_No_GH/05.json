//Marked
{
  "id": "gs_quantstamp_bucket_bku001",
  "subset": "gold_standard",
  "language": "move",
  "chain": "sui",
  "source_platform": "quantstamp",
  "source_report": "Bucket Protocol V2",
  "source_finding_id": "BKU-1",
  "report_url": "https://certificate.quantstamp.com/full/bucket-protocol-v-2/abd312d6-1a5e-45c5-963b-a6856daf6621/index.html",
  "github_repo_url": "https://github.com/Bucket-Protocol/v2-move-contracts",
  "contest_date": "2025-08-11",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "finding_title": "Security Level Constraint Can Be Circumvented via Inclusive Deposit Logic",
  "finding_description": "The update_position() function in bucket_cdp/vault.move implements access control using security levels via an if-else condition that checks the vault security level based on whether deposit_amount > 0. However, this logic can be circumvented: users can include a deposit amount in their call even when performing withdrawal, repayment, or borrow operations, allowing them to bypass security level 2 restrictions that should block these actions during emergency mode. The security level mechanism is intended to freeze vault operations during emergencies, but the current implementation allows trivial bypass by including any positive deposit amount.",
  "attack_scenario": "1. Protocol enters emergency mode: vault security_level = 2\n2. Security level 2 should only allow: deposits and liquidations\n3. Security level 2 should BLOCK: withdrawals, repayments, borrows\n4. Attacker creates UpdatePositionRequest with:\n   - deposit_amount: 1 (smallest positive amount)\n   - withdraw_amount: 1000000 (large withdrawal)\n   - repay_amount: 500000 (large repayment)\n   - borrow_amount: 250000 (large borrow)\n5. update_position() executes:\n   - if(request.deposit_amount() > 0) → TRUE\n   - Calls check_security_level(1) → passes (level 2 >= 1, but check only fails if level < 1, so level 2 passes)\n   - Enters deposit branch only, SKIPS else branch that would check level 2\n6. After passing the if-else, all operation branches execute: deposit, withdraw, repay, borrow\n7. Attacker successfully executes forbidden operations (withdraw/repay/borrow) during emergency by including minimal deposit\n8. Result: Complete bypass of emergency mode security restrictions, users extract collateral during protocol crisis",
  "fix_description": "Replace the if-else condition with independent if statements for each operation type. Each operation should independently verify it is allowed at the current security level:\n\nVULNERABLE (current):\nif(request.deposit_amount() > 0) {\n    vault.check_security_level(1);\n} else {\n    vault.check_security_level(2);\n};\n// All operations execute regardless of which branch was taken\n\nFIXED:\nif(request.deposit_amount() > 0) {\n    vault.check_security_level(1);\n};\nif(request.withdraw_amount() > 0) {\n    vault.check_security_level(2);\n};\nif(request.repay_amount() > 0) {\n    vault.check_security_level(2);\n};\nif(request.borrow_amount() > 0) {\n    vault.check_security_level(2);\n};\n\nThis ensures each operation type is independently validated against the security level before execution, preventing bypass via mixed operations.",
  "primary_file": {
    "path": "bucket_cdp/sources/vault.move",
    "content": "",
    "vulnerable_lines": [59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73],
    "vulnerable_functions": ["update_position"]
  },
  "context_files": [
    {
      "path": "bucket_cdp/sources/vault.move",
      "content": "// Security level semantics in Bucket Protocol V2:\n// The vault tracks a security_level field to control operations during emergencies\n// \n// Security Level 0 (Normal): All operations allowed\n//   - Deposits: allowed\n//   - Withdrawals: allowed\n//   - Borrows: allowed\n//   - Repays: allowed\n//   - Liquidations: allowed\n//\n// Security Level 1 (Emergency): Restrict most operations\n//   - Deposits: allowed (check_security_level(1) passes when level <= 1)\n//   - Withdrawals: BLOCKED (check_security_level(2) fails when level > 2... wait, this check is wrong)\n//   - Borrows: BLOCKED\n//   - Repays: BLOCKED\n//   - Liquidations: allowed\n//\n// Security Level 2 (Critical Emergency): Only deposits and liquidations\n//   - Deposits: allowed\n//   - Everything else: BLOCKED\n//\n// The bug: Using if-else on deposit_amount allows attacker to select which security check runs\n// Attacker includes deposit_amount > 0 to trigger the level 1 check, bypassing level 2 restrictions\n//\n// In the vulnerable code:\n// If deposit_amount > 0: checks level 1 (passes at level 0,1,2) ✓\n// If deposit_amount = 0: checks level 2 (passes at level 0,1,2) ✓\n//\n// This means both branches PASS at any security level, making the check ineffective\n// The real protection should be:\n// - Deposit: only allowed if level <= 1 (blocks at level 2)\n// - Withdraw/Repay/Borrow: only allowed if level <= 0 (blocks at level 1 and 2)\n//\n// But wait, looking at check_security_level:\n// if(vault.security_level > required_level) { abort }\n// This aborts when security_level > required_level\n// So check_security_level(1) aborts when level > 1 (level 2 aborts)\n// And check_security_level(2) aborts when level > 2 (never aborts)\n//\n// So the if-else logic:\n// if deposit_amount > 0: check level 1 (allows 0,1 | blocks 2) → But all operations execute!\n// else: check level 2 (allows 0,1,2 | blocks nothing) → But all operations execute!\n//\n// The vulnerability: The if-else gate is skipped by including deposit_amount\n// Attacker can:\n// 1. Set deposit_amount = 1 (any positive value)\n// 2. Set withdraw_amount = large value\n// 3. Call update_position()\n// 4. if-else takes deposit branch: check_security_level(1) is called\n// 5. After if-else, ALL operations execute including withdrawal\n// 6. Even though level 2 should block withdrawal, the if-else structure allows it\n//\n// The fix: Check security level for EACH operation independently\n",
      "relevance": "Detailed explanation of security level semantics and how the if-else vulnerability works in context of emergency mode"
    }
  ],
  "call_flow": "User calls update_position(vault, request{deposit_amount: 1, withdraw_amount: 1000000, ...}) → if(deposit_amount > 0) branch executes → check_security_level(1) is called → passes at all levels including level 2 → Execution continues to operation processing → All four operations execute (deposit, withdraw, repay, borrow) despite level 2 restrictions → User withdraws collateral during emergency",
  "context_hint": "The vulnerability stems from using a single if-else conditional to gate the security level check, when operations should be validated independently. The check_security_level function correctly implements level-based access control, but the if-else structure allows users to choose which check runs by controlling whether deposit_amount is 0 or positive. This is a logic flaw where the security gate doesn't cover all code paths that perform restricted operations. The root cause is assumption that users will either deposit OR do other operations, not both in one call, and that the security check would prevent all restricted operations. But operations execute regardless of which if-else branch was taken.",
  "is_vulnerable": true,
  "expert_notes": "This is a classic case of 'gate escaping' where a security check doesn't guard all execution paths. The if-else structure creates two code paths (deposit-focused vs non-deposit-focused) but both paths eventually reach the operation-processing code. The security check only runs once in the gate, but doesn't prevent the other operations from executing. The Quantstamp auditors correctly identified that each operation type needs its own independent security level validation. This is particularly critical in emergency scenarios where a protocol wants to freeze most functionality but allow deposits for recovery. The fix is straightforward: move security checks to each operation branch or call check_security_level for each operation type independently before execution."
}
