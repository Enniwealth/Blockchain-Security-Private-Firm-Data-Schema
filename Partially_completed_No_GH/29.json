//Marked
[
  {
    "id": "gs_cantina_panoptic_merkle_distributor_001",
    "report_url": "https://cantina.xyz/portfolio/e3bd3b17-f13a-4b0d-b929-19bf3266c9ce",
    "project_name": "Panoptic: MultiToken Merkle Distributor",
    "github_url": "https://github.com/panoptic-labs/multitoken-merkle-distributor",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-09-16",
    "vulnerability_type": "missing_access_control",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "merkle_distribution",
    "is_vulnerable": true,
    "title": "Anyone Can Claim Tokens for Any Account - Claim Authorization Bypass",
    "description": "The claim() function allows any third party to execute token claims on behalf of any account without verification. While tokens are sent to the account encoded in the Merkle leaf, this creates a critical issue: if a leaf contains an incorrect account address (due to off-chain data corruption, typo, or malicious inclusion), a third party can preemptively claim those tokens to the wrong address, permanently preventing the legitimate recipient from recovering their allocation through the admin's withdrawUnclaimed mechanism. This is a classic authorization bypass that violates the principle that only the rightful owner should be able to claim their tokens.",
    "primary_file": {
      "name": "MultiTokenMerkleDistributor.sol",
      "path": "src/MultiTokenMerkleDistributor.sol",
      "lines": "120-145",
      "content": "// VULNERABLE: Anyone can claim for any account\nfunction claim(\n    address account,\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    bytes32[] calldata merkleProof\n) external nonReentrant {\n    // @audit NO ACCESS CONTROL: msg.sender is not validated\n    // The function accepts arbitrary 'account' parameter\n    // Any third party can call this function\n    \n    // Verify the claim is valid according to Merkle proof\n    bytes32 node = keccak256(\n        abi.encode(account, tokens, amounts)\n    );\n    require(\n        MerkleProof.verify(merkleProof, merkleRoot, node),\n        \"Invalid Merkle proof\"\n    );\n    \n    // Verify claim hasn't been made already\n    require(\n        !hasClaimed[node],\n        \"Already claimed\"\n    );\n    \n    // Mark as claimed\n    hasClaimed[node] = true;\n    \n    // @audit CRITICAL: Tokens sent to 'account' parameter\n    // If 'account' is wrong (typo, data corruption, attack),\n    // any third party can claim to that wrong address\n    // The legitimate owner cannot recover their tokens\n    for (uint256 i = 0; i < tokens.length; ++i) {\n        IERC20(tokens[i]).safeTransfer(\n            account,  // @audit Tokens go to whoever is in the leaf\n            amounts[i]\n        );\n    }\n    \n    emit Claimed(account, tokens, amounts);\n}"
    },
    "context_files": [
      
    ],
    "call_flow": [
      "1. Merkle tree is created off-chain with claim data",
      "2. Merkle root deployed to contract",
      "3. Tokens transferred to contract for distribution",
      "4. Scenario A (Data Corruption):",
      "   - Off-chain process has typo/error in account address",
      "   - Merkle leaf encodes wrong account",
      "5. Scenario B (Malicious Merkle Tree):",
      "   - Attacker influences off-chain data",
      "   - Intentionally includes wrong account in Merkle tree",
      "6. Third party discovers the claim opportunity",
      "7. Third party calls claim(wrongAccount, tokens, amounts, proof)",
      "8. No require() check validates msg.sender == account",
      "9. Merkle proof verified successfully (proof is valid for the leaf)",
      "10. hasClaimed[node] = true (marked as claimed)",
      "11. Tokens transferred to wrongAccount (not the legitimate owner)",
      "12. Legitimate owner cannot recover tokens",
      "13. Admin cannot recover because hasClaimed is true",
      "14. Tokens permanently sent to wrong address"
    ],
    "context_hint": "This is an authorization bypass vulnerability where the claim function lacks access control. Any caller can claim on behalf of any account. While the Merkle proof ensures the claim is valid per the tree, the tree itself may contain errors or be compromised. The function should require that either msg.sender == account or the claim is signed by the account.",
    "expert_notes": "Cantina identified this through access control analysis of the claim function. The vulnerability assumes the Merkle tree is 100% accurate, but off-chain data generation is error-prone. If the tree contains a wrong account (due to typo, data corruption, or compromise), the tokens cannot be recovered. The fix is simple: either require msg.sender == account or add a signature from the account to authorize the claim.",
    "fix_description": "Add access control to ensure only the intended recipient (msg.sender) or an authorized party (via signature) can claim tokens. The most straightforward fix is to require msg.sender == account, or use a signature-based approach where the account must authorize the claim.",
    "fix_code": "// FIXED: Require caller is the intended recipient\nfunction claim(\n    address account,\n    address[] calldata tokens,\n    uint256[] calldata amounts,\n    bytes32[] calldata merkleProof\n) external nonReentrant {\n    // FIX: Only the account can claim their own tokens\n    require(msg.sender == account, \"Unauthorized: Only recipient can claim\");\n    \n    bytes32 node = keccak256(\n        abi.encode(account, tokens, amounts)\n    );\n    require(\n        MerkleProof.verify(merkleProof, merkleRoot, node),\n        \"Invalid Merkle proof\"\n    );\n    \n    require(\n        !hasClaimed[node],\n        \"Already claimed\"\n    );\n    \n    hasClaimed[node] = true;\n    \n    for (uint256 i = 0; i < tokens.length; ++i) {\n        IERC20(tokens[i]).safeTransfer(account, amounts[i]);\n    }\n    \n    emit Claimed(account, tokens, amounts);\n}\n\n// RESULT:\n// - Only the intended recipient can claim their tokens\n// - Third parties cannot claim to wrong addresses\n// - If account in Merkle tree is wrong, legitimate owner knows\n// - Admin can still use withdrawUnclaimed for truly unclaimed tokens\n// - Recovery mechanism works correctly"
  }
]