//Marked

[
  {
    "id": "gs_cantina_infinifi_pr233_001",
    "report_url": "https://cantina.xyz/portfolio/9d70cee6-2412-4f2a-80aa-c013bd11c036",
    "project_name": "infiniFi PR 233",
    "github_url": "https://github.com/InfiniFi-Labs/infinifi-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-11-02",
    "vulnerability_type": "fund_sweep",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Merkl Claim Sweeps Entire Farm Balance Instead of Just Rewards",
    "description": "MerklRewardsClaimer.claimRewards pulls rewards via emergencyAction but then transfers the entire token balance from the farm without accounting for pre-existing funds. If the reward token matches the farm's asset token or if idle liquidity accumulates, claimRewards sweeps all farmheld assets to the recipient, collapsing reported totalAssets.",
    "primary_file": {
      "name": "MerklRewardsClaimer.sol",
      "path": "src/MerklRewardsClaimer.sol",
      "lines": "45-75",
      "content": "function claimRewards(\n    address _farm,\n    address _rewardToken,\n    bytes calldata _proof\n) external returns (uint256 claimed) {\n    // Validate reward token is enabled\n    require(enabledRewards[_rewardToken], \"UnsupportedToken\");\n    \n    // BUG: No balance check before emergencyAction\n    // If farm already holds _rewardToken, it will be swept\n    \n    // Call emergencyAction to pull rewards from Merkl\n    CoreControlled(_farm).emergencyAction(\n        MERKL_CLAIM_ACTION,\n        _proof\n    );\n    \n    // BUG: Transfers entire balance, not just newly claimed rewards\n    uint256 farmBalance = IERC20(_rewardToken).balanceOf(_farm);\n    \n    // SHOULD be:\n    // uint256 balanceBefore = <snapshot from before emergencyAction>\n    // uint256 claimed = farmBalance - balanceBefore\n    \n    IERC20(_rewardToken).transferFrom(_farm, msg.sender, farmBalance);\n    \n    // If _rewardToken == farm's asset token, this drains principal!\n    // If farm had idle liquidity in _rewardToken, this sweeps it too!\n    \n    return farmBalance;\n}"
    },
    "context_files": [
      {
        "name": "Farm Asset Structure",
        "path": "src/Farm.sol",
        "relevance": "Shows how farm holds assets and how claimRewards can drain them",
        "content": "contract Farm is ERC4626 {\n    address public immutable asset;\n    \n    function totalAssets() public view override returns (uint256) {\n        return IERC20(asset).balanceOf(address(this));\n    }\n    \n    // Example scenario:\n    // Farm asset = USDC\n    // Merkl reward = USDC (same token!)\n    // Farm.totalAssets() = 1000 USDC (principal + idle liquidity)\n    //\n    // When claimRewards(farm, USDC) is called:\n    // 1. emergencyAction pulls 10 USDC from Merkl\n    // 2. balanceOf(farm, USDC) = 1010 USDC\n    // 3. claimRewards transfers 1010 USDC to recipient\n    // 4. Farm.totalAssets() drops from 1000 to 0\n    // 5. Users cannot redeem because principal is gone\n}\n\ncontract MerklRewardsClaimer {\n    function claimRewards(\n        address _farm,\n        address _rewardToken,\n        bytes calldata _proof\n    ) external returns (uint256 claimed) {\n        // Current vulnerable flow\n        CoreControlled(_farm).emergencyAction(MERKL_CLAIM_ACTION, _proof);\n        \n        uint256 farmBalance = IERC20(_rewardToken).balanceOf(_farm);\n        IERC20(_rewardToken).transferFrom(_farm, msg.sender, farmBalance);\n        \n        // If _rewardToken == farm.asset() or farm had idle balance:\n        // ENTIRE BALANCE SWEPT!\n        return farmBalance;\n    }\n}"
      },
      {
        "name": "Risk Scenarios",
        "path": "reference/merkl_scenarios.md",
        "relevance": "Documents scenarios where fund sweep occurs",
        "content": "SCENARIO 1: Reward token = farm asset token\n\nInitial state:\n- Farm asset: USDC\n- Farm totalAssets: 1,000,000 USDC\n- User deposits: 100,000 USDC\n- Farm shares: 100,000\n\nMerkl Setup:\n- Reward token: USDC (SAME!)\n- Merkl owes: 10,000 USDC in rewards\n\nClaimRewards call:\n1. emergencyAction triggers Merkl claim\n2. Merkl sends 10,000 USDC to farm\n3. Farm balance: 1,000,000 + 10,000 = 1,010,000 USDC\n4. claimRewards transfers 1,010,000 USDC to caller\n5. Farm balance: 0 USDC\n6. Farm.totalAssets(): 0\n7. User cannot redeem: total assets gone\n\nLOSS:\n- Farm principal: 1,000,000 USDC\n- Intended rewards: 10,000 USDC\n- Actual sweep: 1,010,000 USDC\n- Loss to users: 1,000,000 USDC\n\nSCENARIO 2: Farm has idle liquidity\n\nInitial state:\n- Farm asset: DAI\n- Deposited funds: 500,000 DAI\n- Withdrawn but not deployed: 50,000 DAI (pending deployment)\n- Farm balance: 550,000 DAI\n\nMerkl Setup:\n- Reward token: DAI\n- Merkl reward: 5,000 DAI\n\nClaimRewards call:\n1. emergencyAction pulls 5,000 DAI\n2. Farm balance: 555,000 DAI\n3. claimRewards sweeps 555,000 DAI\n4. Farm balance: 0\n5. Pending deployment amount is lost\n6. 50,000 DAI that was meant to be deployed is gone"
      }
    ],
    "call_flow": [
      "1. Farm holds USDC (asset) + some USDC idle liquidity",
      "2. Merkl protocol agrees to pay USDC rewards",
      "3. claimRewards(farm, USDC, proof) called",
      "4. enabledRewards[USDC] check passes",
      "5. emergencyAction called to trigger Merkl claim",
      "6. Merkl contract sends reward USDC to farm",
      "7. Farm.balanceOf(USDC) increases",
      "8. BUG: claimRewards transfers entire farm balance",
      "9. All USDC swept away, including principal",
      "10. Farm.totalAssets() becomes 0",
      "11. User redemptions fail: insufficient assets",
      "12. Principal lost due to reward token sweep"
    ],
    "context_hint": "The vulnerability is a classic accounting error: the function assumes claiming rewards and transferring them are atomic, so the post-claim balance equals the claimed amount. However, the farm may already hold tokens with that address (either as principal if it's the asset token, or as idle liquidity waiting to be deployed). By not capturing the balance before the claim, the function sweeps all accumulated funds.",
    "expert_notes": "This is a dangerous edge case that occurs when reward tokens overlap with farm assets. The immediate cause is missing pre/post balance comparison. The deeper issue is insufficient validation: the code should forbid reward tokens from being the farm's primary asset unless explicitly intended. InfiniFi fixed this in PR #a5d8595 by recording pre-claim balance and only transferring the delta.",
    "fix_description": "Capture the farm's reward token balance before claiming, then only transfer the difference between post-claim and pre-claim balance.",
    "fix_code": "function claimRewards(\n    address _farm,\n    address _rewardToken,\n    bytes calldata _proof\n) external returns (uint256 claimed) {\n    require(enabledRewards[_rewardToken], \"UnsupportedToken\");\n    \n    // Forbid claiming farm's primary asset to prevent sweep\n    address farmAsset = ERC4626(_farm).asset();\n    require(\n        _rewardToken != farmAsset,\n        \"RewardTokenIsAsset\"\n    );\n    \n    // FIXED: Snapshot balance before claim\n    uint256 balanceBefore = IERC20(_rewardToken).balanceOf(_farm);\n    \n    // Trigger reward claim\n    CoreControlled(_farm).emergencyAction(\n        MERKL_CLAIM_ACTION,\n        _proof\n    );\n    \n    // Calculate incremental amount (newly claimed)\n    uint256 balanceAfter = IERC20(_rewardToken).balanceOf(_farm);\n    claimed = balanceAfter - balanceBefore;\n    \n    // Only transfer newly claimed rewards\n    require(claimed > 0, \"NoRewardsClaimed\");\n    IERC20(_rewardToken).transferFrom(_farm, msg.sender, claimed);\n    \n    emit RewardsClaimed(_rewardToken, claimed);\n    return claimed;\n}"
  },
  {
    "id": "gs_cantina_infinifi_pr233_002",
    "report_url": "https://cantina.xyz/portfolio/9d70cee6-2412-4f2a-80aa-c013bd11c036",
    "project_name": "infiniFi PR 233",
    "github_url": "https://github.com/InfiniFi-Labs/infinifi-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-11-02",
    "vulnerability_type": "slippage_validation",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Withdraw Slippage Guard Misapplied - Checks Requested Amount Not Actual Output",
    "description": "Farm.withdraw records value spent as the farm's asset decrease (assetsSpent = assetsBefore - assetsAfter), but slippage guard compares the original requested amount to the tolerance. If downstream venue returns less than requested due to fees, assetsSpent still reads the full requested amount because the farm balance dropped by that figure. The guard then passes even though the recipient received significantly less, bypassing maximum slippage protection.",
    "primary_file": {
      "name": "Farm.sol",
      "path": "src/Farm.sol",
      "lines": "180-210",
      "content": "function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n) public override returns (uint256 shares) {\n    uint256 assetsBefore = IERC20(asset).balanceOf(address(this));\n    \n    // Record what the caller is requesting\n    uint256 requestedAmount = assets;\n    \n    // Forward to vault (may have fees/slippage)\n    shares = ERC4626(vault).withdraw(\n        requestedAmount,\n        receiver,\n        address(this)\n    );\n    \n    uint256 assetsAfter = IERC20(asset).balanceOf(address(this));\n    uint256 assetsSpent = assetsBefore - assetsAfter;  // e.g., 100\n    \n    // BUG: Check compares REQUESTED amount to tolerance\n    // Not the amount ACTUALLY delivered to receiver\n    uint256 minAssetsOut = assets.mulWadDown(maxSlippage);\n    // minAssetsOut = 100 * 0.999 = 99.9\n    \n    require(assetsSpent >= minAssetsOut, \"ExcessiveSlippage\");\n    // 100 >= 99.9 → PASSES\n    // But receiver only got 50 due to venue fees!\n    \n    emit Withdraw(owner, receiver, assetsSpent);\n}"
    },
    "context_files": [
      {
        "name": "Attack Scenario",
        "path": "reference/slippage_scenario.md",
        "relevance": "Demonstrates how slippage guard fails with venue fees",
        "content": "SCENARIO: Withdrawal with venue fee spike\n\nFarm setup:\n- asset: USDC\n- vault: Uniswap LiquidityPool\n- maxSlippage: 0.999e18 (0.1% tolerance)\n- User wants: 100 USDC\n\nNormal conditions:\n1. Farm balance: 1000 USDC\n2. withdraw(100) called\n3. Vault removes 100 USDC liquidity\n4. Fee: 0.1% of 100 = 0.1 USDC\n5. User receives: 99.9 USDC\n6. Farm balance drops to 900 USDC\n7. assetsSpent = 1000 - 900 = 100\n8. minAssetsOut = 100 * 0.999 = 99.9\n9. Check: 100 >= 99.9 ✓ PASS\n10. Correct behavior: slippage of 0.1% is within tolerance\n\nFEE SPIKE scenario:\n1. Farm balance: 1000 USDC\n2. withdraw(100) called\n3. Uniswap fees temporarily spike to 5%\n4. Vault deducts 5% of 100 = 5 USDC\n5. User receives: 95 USDC (5% loss)\n6. Farm balance drops to 900 USDC\n7. assetsSpent = 1000 - 900 = 100 (RECORDED AS FULL AMOUNT)\n8. minAssetsOut = 100 * 0.999 = 99.9\n9. Check: 100 >= 99.9 ✓ PASS (INCORRECTLY)\n10. PROBLEM: User suffered 5% loss but guard says 0% slippage!\n\nROOT CAUSE:\n- assetsSpent measures farm balance decrease (100 USDC left farm)\n- But doesn't measure what recipient ACTUALLY got (only 95)\n- User lost 5 USDC but slippage check never detects it"
      },
      {
        "name": "Correct Implementation",
        "path": "reference/correct_slippage.sol",
        "relevance": "Shows how to properly validate output slippage",
        "content": "// CORRECT: Track actual recipient balance change\n\nfunction withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n) public override returns (uint256 shares) {\n    // Snapshot recipient balance before\n    uint256 recipientBefore = IERC20(asset).balanceOf(receiver);\n    \n    // Perform withdrawal\n    shares = ERC4626(vault).withdraw(\n        assets,\n        receiver,\n        address(this)\n    );\n    \n    // Measure actual amount received by recipient\n    uint256 recipientAfter = IERC20(asset).balanceOf(receiver);\n    uint256 actualAmountReceived = recipientAfter - recipientBefore;\n    \n    // Enforce slippage on ACTUAL output, not requested amount\n    uint256 minAssetsOut = assets.mulWadDown(maxSlippage);\n    require(\n        actualAmountReceived >= minAssetsOut,\n        \"ExcessiveSlippage\"\n    );\n}"
      }
    ],
    "call_flow": [
      "1. User calls withdraw(100 USDC)",
      "2. Farm balance before: 1000 USDC",
      "3. Farm calls vault.withdraw(100)",
      "4. Vault has DEX fee spike: 5% instead of 0.1%",
      "5. Vault deducts 5 USDC fee from user's 100",
      "6. User (receiver) gets 95 USDC",
      "7. Farm balance after: 900 USDC",
      "8. assetsSpent = 1000 - 900 = 100 USDC",
      "9. minAssetsOut = 100 * 0.999 = 99.9 USDC",
      "10. Check: assetsSpent (100) >= minAssetsOut (99.9) = TRUE",
      "11. Slippage guard PASSES",
      "12. But receiver only got 95 USDC (5% loss)",
      "13. User lost 5% but slippage validation failed to catch it"
    ],
    "context_hint": "The fundamental issue is confusing 'farm asset balance change' with 'user received amount'. The farm's balance decreases by the full requested amount (the vault pulls it), but the recipient may receive less if fees are deducted by the venue. The current check validates the request was honored, not that the user wasn't slipped.",
    "expert_notes": "This is a subtle but critical logic error in slippage validation. The code measures the right thing (farm balance change) but compares it to the wrong baseline (requested amount vs. delivered amount). The fix requires tracking the recipient's balance before and after to measure actual output. InfiniFi fixed this in PR #edcac03 by comparing actual delivered amount to the tolerance.",
    "fix_description": "Track the recipient's actual balance change and enforce slippage tolerance against the amount actually delivered, not the requested amount.",
    "fix_code": "function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n) public override returns (uint256 shares) {\n    // FIXED: Snapshot recipient balance before\n    uint256 recipientBalanceBefore = IERC20(asset).balanceOf(receiver);\n    \n    // Perform withdrawal\n    shares = ERC4626(vault).withdraw(\n        assets,\n        receiver,\n        address(this)\n    );\n    \n    // FIXED: Measure actual amount delivered to recipient\n    uint256 recipientBalanceAfter = IERC20(asset).balanceOf(receiver);\n    uint256 actualAmountDelivered = recipientBalanceAfter - recipientBalanceBefore;\n    \n    // FIXED: Enforce slippage on actual output, not requested\n    uint256 minAssetsOut = assets.mulWadDown(maxSlippage);\n    require(\n        actualAmountDelivered >= minAssetsOut,\n        \"ExcessiveSlippage: actual < min\"\n    );\n    \n    emit Withdraw(owner, receiver, actualAmountDelivered);\n    return shares;\n}"
  },
  {
    "id": "gs_cantina_infinifi_pr233_003",
    "report_url": "https://cantina.xyz/portfolio/9d70cee6-2412-4f2a-80aa-c013bd11c036",
    "project_name": "infiniFi PR 233",
    "github_url": "https://github.com/InfiniFi-Labs/infinifi-contracts",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-11-02",
    "vulnerability_type": "accounting_gap",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "cross_contract",
    "is_vulnerable": true,
    "title": "assets() Undercounts NAV When ERC-7540 Requests Transition to Claimable State",
    "description": "ERC7540Farm.assets() includes pending deposit/redeem requests but omits claimable amounts that have already settled. When a requestId becomes <= lastSettledEpochId, pendingRequest returns 0 while the value sits in claimable state. This causes NAV to undercount after settlement but before claim, creating inconsistent reporting and incorrect share pricing.",
    "primary_file": {
      "name": "ERC7540Farm.sol",
      "path": "src/ERC7540Farm.sol",
      "lines": "95-125",
      "content": "function assets() public view override returns (uint256) {\n    // Get live share position\n    uint256 balance = balanceOf(address(this));\n    uint256 sharePrice = getSharePrice();\n    uint256 liveAssets = balance.mulWad(sharePrice);\n    \n    // Get pending deposits\n    uint256 pendingDeposits = 0;\n    if (pendingDepositRequestId != 0) {\n        // IERC7540.pendingDepositRequest returns 0 if request is SETTLED\n        pendingDeposits = IERC7540(vault).pendingDepositRequest(\n            pendingDepositRequestId,\n            address(this)\n        );\n    }\n    \n    // Get pending redeems\n    uint256 pendingRedeems = 0;\n    if (pendingRedeemRequestId != 0) {\n        // IERC7540.pendingRedeemRequest returns 0 if request is SETTLED\n        pendingRedeems = IERC7540(vault).pendingRedeemRequest(\n            pendingRedeemRequestId,\n            address(this)\n        );\n    }\n    \n    // BUG: Missing claimable amounts\n    // After settlement, pending* returns 0\n    // But claimable* has the value (settled but unclaimed)\n    \n    return liveAssets + pendingDeposits + pendingRedeems;\n    // NAV is UNDERSTATED after settlement until claim occurs\n}"
    },
    "context_files": [
      {
        "name": "ERC-7540 State Machine",
        "path": "reference/erc7540_lifecycle.md",
        "relevance": "Shows request state transitions in ERC-7540",
        "content": "ERC-7540 Request Lifecycle:\n\n1. PENDING STATE (before epoch settlement):\n   - User calls requestDeposit(assets)\n   - Request queued, not yet executed\n   - pendingDepositRequest() returns assets\n   - claimableDepositRequest() returns 0\n   - Farm should count in pending deposits\n\n2. SETTLING (epoch boundary):\n   - Vault processes all pending requests\n   - Executes swaps, reinvests, etc.\n   - Deposits are converted to shares\n\n3. CLAIMABLE STATE (after epoch settlement):\n   - requestId <= lastDepositEpochIdSettled\n   - pendingDepositRequest() returns 0 (no longer pending)\n   - claimableDepositRequest() returns shares (now claimable)\n   - Farm should count in assets, NOT as pending\n\n4. CLAIMED STATE (after user claims):\n   - Farm calls claim(requestId)\n   - Shares transferred to farm\n   - claimableDepositRequest() returns 0 (claimed)\n   - Shares now in live balance (balanceOf)\n\nBUG TIMELINE:\n\nEpoch N (pending):\n- pendingDepositRequestId = 100\n- pendingDepositRequest(100) = 1000 USD\n- claimableDepositRequest(100) = 0\n- assets() = 5000 live + 1000 pending = 6000 ✓ CORRECT\n\nEpoch N+1 (settled, unclaimed):\n- lastDepositEpochIdSettled = N (or higher)\n- requestId 100 is now <= lastSettled\n- pendingDepositRequest(100) = 0 (no longer pending)\n- claimableDepositRequest(100) = 50 shares (settled into 50 shares)\n- assets() = 5000 live + 0 pending + 0 claimable = 5000 ✗ UNDERCOUNTS by 50 shares\n\nEpoch N+2 (claimed):\n- Farm calls claim(100)\n- claimableDepositRequest(100) = 0\n- balanceOf(farm) increases by 50 shares\n- assets() = 5000 live + 50 = 5050 ✓ CORRECT AGAIN"
      },
      {
        "name": "Plasma fxSave Integration",
        "path": "reference/plasma_fsave.md",
        "relevance": "Shows how Plasma ERC-7540 vault exhibits this behavior",
        "content": "Plasma fxSave Vault (ERC-7540 implementation):\n\nState variables:\n- lastDepositEpochIdSettled: uint256\n- lastRedeemEpochIdSettled: uint256\n\nRequest functions:\n- requestDeposit(assets, owner, receiver) → requestId\n- pendingDepositRequest(requestId, owner) → assets (if requestId > lastDepositEpochIdSettled)\n- claimableDepositRequest(requestId, owner) → shares (if requestId <= lastDepositEpochIdSettled)\n- claimDeposit(requestId, receiver)\n\nBehavior:\n- Epoch N: User calls requestDeposit(1000)\n  - Stored in pendingSilo\n  - pendingDepositRequest returns 1000\n  \n- Epoch N settlement occurs\n  - Deposits processed\n  - lastDepositEpochIdSettled incremented\n  - Shares minted, stored separately\n  \n- After settlement:\n  - pendingDepositRequest returns 0 (deposit has moved)\n  - claimableDepositRequest returns shares (now claimable)\n  \nFarm NAV bug: Doesn't query claimableDepositRequest,\nso undercounts after settlement but before claim"
      }
    ],
    "call_flow": [
      "1. Farm calls requestDeposit(1000 USD) on ERC-7540 vault",
      "2. Vault queues request, stores pendingDepositRequestId = 100",
      "3. assets() called: includes pending 1000 USD",
      "4. Epoch boundary passes",
      "5. Vault processes all pending requests",
      "6. 1000 USD deposited = 50 shares minted",
      "7. Vault sets lastDepositEpochIdSettled to include epoch of request 100",
      "8. assets() called AFTER settlement:",
      "9.   pendingDepositRequest(100) returns 0 (no longer pending)",
      "10.  assets() = liveAssets + 0 + 0",
      "11.  NAV DROPS because claimable 50 shares not counted",
      "12. Farm share price goes down until claim() is called",
      "13. claim() executed, shares transferred to farm",
      "14. assets() now includes the 50 shares in liveAssets",
      "15. NAV jumps back up"
    ],
    "context_hint": "The ERC-7540 standard uses multiple request states (pending → claimable → claimed). The farm tracks pending requests for NAV computation but misses the claimable state that occurs after settlement. This creates an accounting gap where NAV dips immediately after settlement (when requests are no longer pending but not yet claimed), violating the expectation that NAV is monotonically increasing with compound yields.",
    "expert_notes": "This is a state machine tracking bug specific to ERC-7540 integrations. The issue manifests as NAV inconsistency around epoch boundaries: NAV can decrease after settlement (when pending moves to claimable but unclaimed). The fix requires querying both pendingRequest and claimableRequest functions and including both in NAV computation. InfiniFi fixed this in PR #c536d9e by adding claimable amount tracking.",
    "fix_description": "Include claimable deposit/redeem amounts in NAV computation alongside pending amounts, accounting for requests that have settled but not yet been claimed.",
    "fix_code": "function assets() public view override returns (uint256) {\n    // Get live share position\n    uint256 balance = balanceOf(address(this));\n    uint256 sharePrice = getSharePrice();\n    uint256 liveAssets = balance.mulWad(sharePrice);\n    \n    // Get pending deposits (not yet settled)\n    uint256 pendingDeposits = 0;\n    if (pendingDepositRequestId != 0) {\n        pendingDeposits = IERC7540(vault).pendingDepositRequest(\n            pendingDepositRequestId,\n            address(this)\n        );\n    }\n    \n    // FIXED: Also check claimable deposits (settled but unclaimed)\n    uint256 claimableDeposits = 0;\n    if (pendingDepositRequestId != 0) {\n        claimableDeposits = IERC7540(vault).claimableDepositRequest(\n            pendingDepositRequestId,\n            address(this)\n        );\n    }\n    \n    // Get pending redeems (not yet settled)\n    uint256 pendingRedeems = 0;\n    if (pendingRedeemRequestId != 0) {\n        pendingRedeems = IERC7540(vault).pendingRedeemRequest(\n            pendingRedeemRequestId,\n            address(this)\n        );\n    }\n    \n    // FIXED: Also check claimable redeems (settled but unclaimed)\n    uint256 claimableRedeems = 0;\n    if (pendingRedeemRequestId != 0) {\n        claimableRedeems = IERC7540(vault).claimableRedeemRequest(\n            pendingRedeemRequestId,\n            address(this)\n        );\n        // Redeems are in asset value, claimableRedeems is in asset amount\n    }\n    \n    // FIXED: Include both pending and claimable amounts\n    // Convert claimable shares to asset value\n    uint256 claimableDepositValue = claimableDeposits.mulWad(sharePrice);\n    \n    return liveAssets + pendingDeposits + claimableDepositValue + pendingRedeems + claimableRedeems;\n    // NAV now consistent across settlement boundary\n}"
  }
]