[
  {
    "id": "gs_cantina_beets_001",
    "report_url": "https://cantina.xyz/portfolio/88cba69f-63c6-4044-8556-1f320fe96122",
    "project_name": "Beets Looped Sonic",
    "github_url": "https://github.com/beethovenxfi/looped-sonic",
    "language": "solidity",
    "chain": "sonic",
    "contest_date": "2025-09-21",
    "vulnerability_type": "repeated_arbitrage_extraction",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "UNWIND_ROLE Can Extract Profit via Repeated allowedUnwindSlippagePercent Arbitrage",
    "description": "The unwind function is used when the protocol leverage in the underlying AAVE pool needs to be reduced when it is no longer profitable. An actor with UNWIND_ROLE exchanges LST for WETH and repays the protocol to lower leverage. The role can act freely and unwind beyond the target healthFactor up until the underlying AAVE pool allows, then repay WETH. The vault uses the LST's convertToAsset ratio as a reference price and applies allowedUnwindSlippagePercent, which permits the UNWIND_ROLE to return slightly less WETH when exchanging LST in external markets.",
    "primary_file": {
      "name": "LoopedSonicVault.sol",
      "path": "src/LoopedSonicVault.sol",
      "lines": "346-406",
      
  "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {ISonicStaking} from \"./interfaces/ISonicStaking.sol\";\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {VaultSnapshot} from \"./libraries/VaultSnapshot.sol\";\nimport {VaultSnapshotComparison} from \"./libraries/VaultSnapshotComparison.sol\";\nimport {ILoopedSonicVault} from \"./interfaces/ILoopedSonicVault.sol\";\nimport {IAaveCapoRateProvider} from \"./interfaces/IAaveCapoRateProvider.sol\";\nimport {IPool} from \"aave-v3-origin/interfaces/IPool.sol\";\nimport {IPoolDataProvider} from \"aave-v3-origin/interfaces/IPoolDataProvider.sol\";\nimport {DataTypes} from \"aave-v3-origin/protocol/libraries/types/DataTypes.sol\";\nimport {IScaledBalanceToken} from \"aave-v3-origin/interfaces/IScaledBalanceToken.sol\";\n\ncontract LoopedSonicVault is ERC20, AccessControl, ILoopedSonicVault {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using VaultSnapshot for VaultSnapshot.Data;\n    using VaultSnapshotComparison for VaultSnapshotComparison.Data;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    bytes32 public constant UNWIND_ROLE = keccak256(\"UNWIND_ROLE\");\n\n    uint256 public constant AAVE_VARIABLE_INTEREST_RATE = 2;\n    uint256 public constant MIN_LST_DEPOSIT = 0.01e18;\n    uint256 public constant MIN_DEPOSIT_AMOUNT = 0.01e18;\n    uint256 public constant MIN_UNWIND_AMOUNT = 0.01e18;\n    uint256 public constant UNWIND_HF_MARGIN = 0.01e18;\n    uint256 public constant MAX_UNWIND_SLIPPAGE_PERCENT = 0.02e18;\n    uint256 public constant MIN_NAV_INCREASE_ETH = 0.01e18;\n    uint256 public constant MIN_TARGET_HEALTH_FACTOR = 1.05e18;\n    uint256 public constant MIN_SHARES_TO_REDEEM = 0.01e18;\n    uint256 public constant INIT_AMOUNT = 1e18;\n    uint256 public constant MAX_PROTOCOL_FEE_PERCENT = 0.5e18;\n\n    IWETH public immutable WETH;\n    ISonicStaking public immutable LST;\n    IPool public immutable AAVE_POOL;\n    IERC20 public immutable LST_A_TOKEN;\n    IERC20 public immutable WETH_VARIABLE_DEBT_TOKEN;\n    uint8 public immutable AAVE_E_MODE_CATEGORY_ID;\n\n    bool public isInitialized;\n    uint256 public targetHealthFactor;\n    uint256 public allowedUnwindSlippagePercent;\n    uint256 public protocolFeePercent;\n    address public treasuryAddress;\n    uint256 public athRate;\n\n    bool public depositsPaused;\n    bool public withdrawsPaused;\n    bool public unwindsPaused;\n\n    IAaveCapoRateProvider public aaveCapoRateProvider;\n\n    mapping(address => bool) public trustedRouters;\n\n    bool private transient locked;\n    address private transient allowedCaller;\n    uint256 private transient _wethSessionBalance;\n    uint256 private transient _lstSessionBalance;\n\n    constructor(\n        address _weth,\n        address _lst,\n        address _aavePool,\n        uint8 _eModeCategoryId,\n        address _aaveCapoRateProvider,\n        uint256 _targetHealthFactor,\n        uint256 _allowedUnwindSlippagePercent,\n        address _admin,\n        address _treasuryAddress\n    ) ERC20(\"Beets Looped Sonic\", \"loopS\") {\n        require(\n            _weth != address(0) && _lst != address(0) && _aavePool != address(0) && _admin != address(0)\n                && _aaveCapoRateProvider != address(0) && _treasuryAddress != address(0),\n            ZeroAddress()\n        );\n        require(_targetHealthFactor >= MIN_TARGET_HEALTH_FACTOR, TargetHealthFactorTooLow());\n\n        targetHealthFactor = _targetHealthFactor;\n        _setAllowedUnwindSlippagePercent(_allowedUnwindSlippagePercent);\n\n        WETH = IWETH(_weth);\n        LST = ISonicStaking(_lst);\n        AAVE_POOL = IPool(_aavePool);\n        LST_A_TOKEN = IERC20(AAVE_POOL.getReserveAToken(address(LST)));\n\n        (,, address wethVariableDebtToken) =\n            IPoolDataProvider(AAVE_POOL.ADDRESSES_PROVIDER().getPoolDataProvider()).getReserveTokensAddresses(_weth);\n        WETH_VARIABLE_DEBT_TOKEN = IERC20(wethVariableDebtToken);\n\n        AAVE_E_MODE_CATEGORY_ID = _eModeCategoryId;\n        aaveCapoRateProvider = IAaveCapoRateProvider(_aaveCapoRateProvider);\n\n        IERC20(_weth).approve(_aavePool, type(uint256).max);\n        IERC20(_lst).approve(_aavePool, type(uint256).max);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n        treasuryAddress = _treasuryAddress;\n\n        protocolFeePercent = 0;\n        depositsPaused = false;\n        withdrawsPaused = false;\n        unwindsPaused = false;\n        isInitialized = false;\n    }\n\n    receive() external payable {\n        require(msg.sender == address(WETH), SenderNotWethContract());\n    }\n}\n"

    },
    "context_files": [
      {
        "name": "VaultSnapshot.sol",
        "path": "src/libraries/VaultSnapshot.sol",
        "relevance": "Calculates healthFactor and manages leverage calculations",
        "content": "function healthFactor(Data memory data) internal pure returns (uint256) {\n    uint256 liquidationThreshold = data.lstCollateralAmountInEth * data.liquidationThreshold / 10_000;\n    if (data.wethDebtAmount == 0) return type(uint256).max;\n    return liquidationThreshold * 1e18 / data.wethDebtAmount;\n}\n\nfunction borrowAmountForLoopInEth(Data memory data) internal pure returns (uint256) {\n    uint256 maxBorrowAmount = data.lstCollateralAmountInEth * data.ltv / 10_000;\n    if (maxBorrowAmount <= data.wethDebtAmount) return 0;\n    \n    uint256 targetAmount = data.lstCollateralAmountInEth * data.liquidationThreshold / 10_000 / data.targetHealthFactor;\n    uint256 amount = targetAmount > data.wethDebtAmount ? targetAmount - data.wethDebtAmount : 0;\n    \n    return amount > maxBorrowAmount - data.wethDebtAmount ? maxBorrowAmount - data.wethDebtAmount : amount;\n}"
      }
     
    ],
    "call_flow": [
      "1. UNWIND_ROLE observes LST market price > vault convertToAssets price + allowedUnwindSlippagePercent",
      "2. Attacker receives LST via unwind(lstAmount, minWethOut)",
      "3. Attacker exchanges LST on external market at premium rate (above vault pricing)",
      "4. Attacker returns WETH at minimum amount allowed by slippage tolerance",
      "5. Difference between actual exchange rate and minimum allowed becomes attacker profit",
      "6. Vault debt reduced, but healthFactor not required to reach target",
      "7. Attacker (or external user) deposits WETH back into vault",
      "8. Deposit callback rebalances vault, increasing healthFactor",
      "9. Deposits reset vault to enable another unwind with fresh LST collateral",
      "10. Loop repeats: unwind → exchange at premium → deposit → withdraw",
      "11. Process continues until external market rate collapses or vault is depleted",
      "12. PoC demonstrates 17 ETH extraction from 100 ETH vault (17% loss) over 300 iterations"
    ],
    "context_hint": "The vulnerability exploits the slippage tolerance mechanism designed for legitimate market execution. The allowedUnwindSlippagePercent is meant to permit reasonable price differences during exchange, but if external markets price LST higher than the vault's convertToAssets reference price, the margin becomes an arbitrage opportunity. The critical issue is that unwind has no hard requirement to reduce leverage to a target healthFactor—the UNWIND_ROLE can unwind freely as long as AAVE's pool constraints allow, then deposits reset the vault for another loop.",
    "expert_notes": "This is a profitable extraction attack enabled by access control and economic incentive misalignment. Key observations: (1) The UNWIND_ROLE is trusted with unilateral leverage control but not trusted with profit extraction—yet the design allows both, (2) The slippage tolerance is calibrated for a single execution, not repeated loops, (3) The unwind→deposit→withdraw cycle allows resetting vault state indefinitely, (4) Market dependence: if external LST price remains > (vault_price * (1 - slippage)), the attack is infinitely repeatable. Beets' fix adds health factor margin requirements (unwind can only occur if HF <= target - MARGIN, and cannot end with HF > target), capping damage to the margin delta rather than blocking arbitrage entirely.",
    "fix_description": "Implement health factor margin constraints on unwind operations to cap the leverage reduction that can be performed and prevent the unwind result from exceeding the target health factor.",
    "fix_code": "// Add constant for health factor margin\nuint256 private constant HEALTH_FACTOR_MARGIN = 0.01e18; // 1% margin\n\nfunction unwind(uint256 lstAmount, uint256 minWethOut) external onlyRole(UNWIND_ROLE) {\n    VaultSnapshot.Data memory snapshot = getVaultSnapshot();\n    \n    // CONSTRAINT 1: Can only unwind if current HF <= target - MARGIN\n    // Prevents unwinding when vault is already healthy\n    uint256 targetWithMargin = targetHealthFactor - HEALTH_FACTOR_MARGIN;\n    require(snapshot.healthFactor <= targetWithMargin, \"HF above threshold\");\n    \n    require(lstAmount > 0, \"Invalid amount\");\n    uint256 redemptionAmount = LST.convertToAssets(lstAmount);\n    uint256 minimumWethRequired = redemptionAmount * (1e18 - allowedUnwindSlippagePercent) / 1e18;\n    require(minWethOut >= minimumWethRequired, \"Slippage too high\");\n    \n    LST.transfer(msg.sender, lstAmount);\n    WETH.transferFrom(msg.sender, address(this), minWethOut);\n    aavePool.repay(address(WETH), minWethOut, 2, address(this));\n    \n    // CONSTRAINT 2: After unwind, HF must not exceed target\n    // Prevents resetting vault state via debt reduction\n    VaultSnapshot.Data memory snapshotAfter = getVaultSnapshot();\n    require(snapshotAfter.healthFactor <= targetHealthFactor, \"HF exceeds target after unwind\");\n    \n    emit Unwound(lstAmount, minWethOut);\n}"
  }
]