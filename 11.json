[
  {
    "id": "gs_cantina_beets_001",
    "report_url": "https://cantina.xyz/portfolio/88cba69f-63c6-4044-8556-1f320fe96122",
    "project_name": "Beets Looped Sonic",
    "github_url": "https://github.com/beethovenxfi/looped-sonic",
    "language": "solidity",
    "chain": "sonic",
    "contest_date": "2025-09-21",
    "vulnerability_type": "repeated_arbitrage_extraction",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "UNWIND_ROLE Can Extract Profit via Repeated allowedUnwindSlippagePercent Arbitrage",
    "description": "The UNWIND_ROLE can repeatedly exploit the allowedUnwindSlippagePercent margin to profit from the difference between the LST's convertToAsset reference price and external market rates. By unwinding LST for WETH at a slippage-adjusted rate, redepositing, and withdrawing, the attacker can loop this process multiple times to extract arbitrary value from the vault until external market prices fall sufficiently or vault liquidity is exhausted.",
    "primary_file": {
      "name": "LoopedSonicVault.sol",
      "path": "src/LoopedSonicVault.sol",
      "lines": "332-350",
      "content": "function unwind(uint256 lstAmount, uint256 minWethOut) external onlyRole(UNWIND_ROLE) {\n    require(lstAmount > 0, \"Invalid amount\");\n    \n    // Calculate minimum WETH output using vault's LST pricing + slippage tolerance\n    uint256 redemptionAmount = LST.convertToAssets(lstAmount);\n    uint256 minimumWethRequired = redemptionAmount * (1e18 - allowedUnwindSlippagePercent) / 1e18;\n    \n    require(minWethOut >= minimumWethRequired, \"Slippage too high\");\n    \n    // Transfer LST from vault to UNWIND_ROLE to exchange for WETH\n    // UNWIND_ROLE exchanges on external market at better-than-allowed rate\n    // If market rate > allowedUnwindSlippagePercent above vault rate, profit = difference\n    LST.transfer(msg.sender, lstAmount);\n    \n    // Receive WETH from UNWIND_ROLE\n    WETH.transferFrom(msg.sender, address(this), minWethOut);\n    \n    // Repay protocol debt (no requirement to unwind to target healthFactor)\n    aavePool.repay(address(WETH), minWethOut, 2, address(this));\n    \n    emit Unwound(lstAmount, minWethOut);\n}\n\n// After unwind, can redeposit to reset healthFactor and loop\nfunction deposit(uint256 assets, address receiver) public override returns (uint256) {\n    // Deposits raise the healthFactor back up\n    // Allows unwind to be called again with more LST available\n    return super.deposit(assets, receiver);\n}"
    },
    "context_files": [
      {
        "name": "VaultSnapshot.sol",
        "path": "src/libraries/VaultSnapshot.sol",
        "relevance": "Calculates healthFactor and manages leverage calculations",
        "content": "function healthFactor(Data memory data) internal pure returns (uint256) {\n    uint256 liquidationThreshold = data.lstCollateralAmountInEth * data.liquidationThreshold / 10_000;\n    if (data.wethDebtAmount == 0) return type(uint256).max;\n    return liquidationThreshold * 1e18 / data.wethDebtAmount;\n}\n\nfunction borrowAmountForLoopInEth(Data memory data) internal pure returns (uint256) {\n    uint256 maxBorrowAmount = data.lstCollateralAmountInEth * data.ltv / 10_000;\n    if (maxBorrowAmount <= data.wethDebtAmount) return 0;\n    \n    uint256 targetAmount = data.lstCollateralAmountInEth * data.liquidationThreshold / 10_000 / data.targetHealthFactor;\n    uint256 amount = targetAmount > data.wethDebtAmount ? targetAmount - data.wethDebtAmount : 0;\n    \n    return amount > maxBorrowAmount - data.wethDebtAmount ? maxBorrowAmount - data.wethDebtAmount : amount;\n}"
      },
      {
        "name": "Router.sol",
        "path": "src/Router.sol",
        "relevance": "Provides deposit and withdraw entry points that can be looped after unwind",
        "content": "function deposit(uint256 assets) external payable returns (uint256 shares) {\n    require(msg.value == assets, \"Value mismatch\");\n    WETH.deposit{value: assets}();\n    \n    shares = vault.deposit(assets, msg.sender);\n    \n    // Callback to rebalance vault via AAVE\n    IVaultCallback(address(vault)).onDeposit(assets);\n    \n    return shares;\n}\n\nfunction withdraw(uint256 shares) external returns (uint256 assets) {\n    assets = vault.withdraw(shares, msg.sender, msg.sender);\n    \n    // Callback to rebalance vault via AAVE\n    IVaultCallback(address(vault)).onWithdraw(assets);\n    \n    WETH.withdraw(assets);\n    return assets;\n}"
      }
    ],
    "call_flow": [
      "1. UNWIND_ROLE observes LST market price > vault convertToAssets price + allowedUnwindSlippagePercent",
      "2. Attacker receives LST via unwind(lstAmount, minWethOut)",
      "3. Attacker exchanges LST on external market at premium rate (above vault pricing)",
      "4. Attacker returns WETH at minimum amount allowed by slippage tolerance",
      "5. Difference between actual exchange rate and minimum allowed becomes attacker profit",
      "6. Vault debt reduced, but healthFactor not required to reach target",
      "7. Attacker (or external user) deposits WETH back into vault",
      "8. Deposit callback rebalances vault, increasing healthFactor",
      "9. Deposits reset vault to enable another unwind with fresh LST collateral",
      "10. Loop repeats: unwind → exchange at premium → deposit → withdraw",
      "11. Process continues until external market rate collapses or vault is depleted",
      "12. PoC demonstrates 17 ETH extraction from 100 ETH vault (17% loss) over 300 iterations"
    ],
    "context_hint": "The vulnerability exploits the slippage tolerance mechanism designed for legitimate market execution. The allowedUnwindSlippagePercent is meant to permit reasonable price differences during exchange, but if external markets price LST higher than the vault's convertToAssets reference price, the margin becomes an arbitrage opportunity. The critical issue is that unwind has no hard requirement to reduce leverage to a target healthFactor—the UNWIND_ROLE can unwind freely as long as AAVE's pool constraints allow, then deposits reset the vault for another loop.",
    "expert_notes": "This is a profitable extraction attack enabled by access control and economic incentive misalignment. Key observations: (1) The UNWIND_ROLE is trusted with unilateral leverage control but not trusted with profit extraction—yet the design allows both, (2) The slippage tolerance is calibrated for a single execution, not repeated loops, (3) The unwind→deposit→withdraw cycle allows resetting vault state indefinitely, (4) Market dependence: if external LST price remains > (vault_price * (1 - slippage)), the attack is infinitely repeatable. Beets' fix adds health factor margin requirements (unwind can only occur if HF <= target - MARGIN, and cannot end with HF > target), capping damage to the margin delta rather than blocking arbitrage entirely.",
    "fix_description": "Implement health factor margin constraints on unwind operations to cap the leverage reduction that can be performed and prevent the unwind result from exceeding the target health factor.",
    "fix_code": "// Add constant for health factor margin\nuint256 private constant HEALTH_FACTOR_MARGIN = 0.01e18; // 1% margin\n\nfunction unwind(uint256 lstAmount, uint256 minWethOut) external onlyRole(UNWIND_ROLE) {\n    VaultSnapshot.Data memory snapshot = getVaultSnapshot();\n    \n    // CONSTRAINT 1: Can only unwind if current HF <= target - MARGIN\n    // Prevents unwinding when vault is already healthy\n    uint256 targetWithMargin = targetHealthFactor - HEALTH_FACTOR_MARGIN;\n    require(snapshot.healthFactor <= targetWithMargin, \"HF above threshold\");\n    \n    require(lstAmount > 0, \"Invalid amount\");\n    uint256 redemptionAmount = LST.convertToAssets(lstAmount);\n    uint256 minimumWethRequired = redemptionAmount * (1e18 - allowedUnwindSlippagePercent) / 1e18;\n    require(minWethOut >= minimumWethRequired, \"Slippage too high\");\n    \n    LST.transfer(msg.sender, lstAmount);\n    WETH.transferFrom(msg.sender, address(this), minWethOut);\n    aavePool.repay(address(WETH), minWethOut, 2, address(this));\n    \n    // CONSTRAINT 2: After unwind, HF must not exceed target\n    // Prevents resetting vault state via debt reduction\n    VaultSnapshot.Data memory snapshotAfter = getVaultSnapshot();\n    require(snapshotAfter.healthFactor <= targetHealthFactor, \"HF exceeds target after unwind\");\n    \n    emit Unwound(lstAmount, minWethOut);\n}"
  }
]