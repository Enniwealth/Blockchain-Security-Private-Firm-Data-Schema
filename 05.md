{
  "id": "gs_quantstamp_bucket_bku001",
  "subset": "gold_standard",
  "language": "move",
  "chain": "sui",
  "source_platform": "quantstamp",
  "source_report": "Bucket Protocol V2",
  "source_finding_id": "BKU-1",
  "report_url": "https://certificate.quantstamp.com/full/bucket-protocol-v-2/abd312d6-1a5e-45c5-963b-a6856daf6621/index.html",
  "github_repo_url": "https://github.com/Bucket-Protocol/v2-move-contracts",
  "contest_date": "2025-08-11",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "finding_title": "Security Level Constraint Can Be Circumvented via Inclusive Deposit Logic",
  "finding_description": "The update_position() function in bucket_cdp/vault.move implements access control using security levels via an if-else condition that checks the vault security level based on whether deposit_amount > 0. However, this logic can be circumvented: users can include a deposit amount in their call even when performing withdrawal, repayment, or borrow operations, allowing them to bypass security level 2 restrictions that should block these actions during emergency mode. The security level mechanism is intended to freeze vault operations during emergencies, but the current implementation allows trivial bypass by including any positive deposit amount.",
  "attack_scenario": "1. Protocol enters emergency mode: vault security_level = 2\n2. Security level 2 should only allow: deposits and liquidations\n3. Security level 2 should BLOCK: withdrawals, repayments, borrows\n4. Attacker creates UpdatePositionRequest with:\n   - deposit_amount: 1 (smallest positive amount)\n   - withdraw_amount: 1000000 (large withdrawal)\n   - repay_amount: 500000 (large repayment)\n   - borrow_amount: 250000 (large borrow)\n5. update_position() executes:\n   - if(request.deposit_amount() > 0) → TRUE\n   - Calls check_security_level(1) → passes (level 2 >= 1, but check only fails if level < 1, so level 2 passes)\n   - Enters deposit branch only, SKIPS else branch that would check level 2\n6. After passing the if-else, all operation branches execute: deposit, withdraw, repay, borrow\n7. Attacker successfully executes forbidden operations (withdraw/repay/borrow) during emergency by including minimal deposit\n8. Result: Complete bypass of emergency mode security restrictions, users extract collateral during protocol crisis",
  "fix_description": "Replace the if-else condition with independent if statements for each operation type. Each operation should independently verify it is allowed at the current security level:\n\nVULNERABLE (current):\nif(request.deposit_amount() > 0) {\n    vault.check_security_level(1);\n} else {\n    vault.check_security_level(2);\n};\n// All operations execute regardless of which branch was taken\n\nFIXED:\nif(request.deposit_amount() > 0) {\n    vault.check_security_level(1);\n};\nif(request.withdraw_amount() > 0) {\n    vault.check_security_level(2);\n};\nif(request.repay_amount() > 0) {\n    vault.check_security_level(2);\n};\nif(request.borrow_amount() > 0) {\n    vault.check_security_level(2);\n};\n\nThis ensures each operation type is independently validated against the security level before execution, preventing bypass via mixed operations.",
  "primary_file": {
    "path": "bucket_cdp/sources/vault.move",
    "content": "// SPDX-License-Identifier: Apache-2.0\nmodule bucket_v2_cdp::vault {\n    use sui::object::{Self, UID};\n    use sui::transfer;\n    use sui::tx_context::TxContext;\n    \n    // Vault security level constants\n    // Level 0: All operations allowed (normal operation)\n    // Level 1: Only deposits and liquidations (emergency - freeze borrows/repays/withdrawals)\n    // Level 2: Only deposits and liquidations (emergency - freeze borrows/repays/withdrawals)\n    \n    public struct Vault has key, store {\n        id: UID,\n        security_level: u8,\n        total_collateral: u64,\n        total_debt: u64,\n    }\n    \n    public struct UpdatePositionRequest has drop {\n        deposit_amount: u64,\n        withdraw_amount: u64,\n        repay_amount: u64,\n        borrow_amount: u64,\n    }\n    \n    impl UpdatePositionRequest {\n        public fun deposit_amount(&self): u64 {\n            self.deposit_amount\n        }\n        \n        public fun withdraw_amount(&self): u64 {\n            self.withdraw_amount\n        }\n        \n        public fun repay_amount(&self): u64 {\n            self.repay_amount\n        }\n        \n        public fun borrow_amount(&self): u64 {\n            self.borrow_amount\n        }\n    }\n    \n    // VULNERABLE: Security level check using if-else based on deposit_amount\n    // Lines 59-73: The vulnerability\n    public fun update_position(vault: &mut Vault, request: &UpdatePositionRequest) {\n        // VULNERABLE LOGIC:\n        // This if-else only checks security level in one branch based on deposit_amount\n        // If deposit_amount > 0, only checks level 1\n        // If deposit_amount = 0, checks level 2\n        // But all four operations (deposit, withdraw, repay, borrow) execute regardless\n        // of which branch was taken, allowing bypass\n        \n        if(request.deposit_amount() > 0) {\n            // deposit actions will only be blocked when security level >= 1\n            vault.check_security_level(1);\n        } else {\n            // borrow; repay; withdraw;\n            // blocked when security level >= 1 or 2\n            vault.check_security_level(2);\n        };\n        \n        // PROBLEM: All these operations execute regardless of the security check above\n        if(request.deposit_amount() > 0) {\n            vault.process_deposit(request.deposit_amount());\n        };\n        \n        if(request.withdraw_amount() > 0) {\n            // VULNERABLE: This executes even if check_security_level(1) passed\n            // Attacker can bypass level 2 by including deposit_amount > 0\n            vault.process_withdraw(request.withdraw_amount());\n        };\n        \n        if(request.repay_amount() > 0) {\n            // VULNERABLE: This executes even if check_security_level(1) passed\n            // Should be blocked at level 2 but attacker bypasses via deposit\n            vault.process_repay(request.repay_amount());\n        };\n        \n        if(request.borrow_amount() > 0) {\n            // VULNERABLE: This executes even if check_security_level(1) passed\n            // Should be blocked at level 2 but attacker bypasses via deposit\n            vault.process_borrow(request.borrow_amount());\n        };\n    }\n    \n    // Security level check function\n    // Returns: success if required_level <= vault.security_level\n    // Blocks: if vault.security_level > required_level\n    fun check_security_level(vault: &Vault, required_level: u8) {\n        // If required_level = 1: blocks when level > 1 (allows 0, 1)\n        // If required_level = 2: blocks when level > 2 (allows 0, 1, 2)\n        if(vault.security_level > required_level) {\n            abort 1001; // Access denied by security level\n        }\n    }\n    \n    fun process_deposit(vault: &mut Vault, amount: u64) {\n        vault.total_collateral = vault.total_collateral + amount;\n    }\n    \n    fun process_withdraw(vault: &mut Vault, amount: u64) {\n        if(vault.total_collateral < amount) {\n            abort 1002; // Insufficient collateral\n        };\n        vault.total_collateral = vault.total_collateral - amount;\n    }\n    \n    fun process_repay(vault: &mut Vault, amount: u64) {\n        if(vault.total_debt < amount) {\n            abort 1003; // Amount exceeds debt\n        };\n        vault.total_debt = vault.total_debt - amount;\n    }\n    \n    fun process_borrow(vault: &mut Vault, amount: u64) {\n        vault.total_debt = vault.total_debt + amount;\n    }\n}\n",
    "vulnerable_lines": [59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73],
    "vulnerable_functions": ["update_position"]
  },
  "context_files": [
    {
      "path": "bucket_cdp/sources/vault.move",
      "content": "// Security level semantics in Bucket Protocol V2:\n// The vault tracks a security_level field to control operations during emergencies\n// \n// Security Level 0 (Normal): All operations allowed\n//   - Deposits: allowed\n//   - Withdrawals: allowed\n//   - Borrows: allowed\n//   - Repays: allowed\n//   - Liquidations: allowed\n//\n// Security Level 1 (Emergency): Restrict most operations\n//   - Deposits: allowed (check_security_level(1) passes when level <= 1)\n//   - Withdrawals: BLOCKED (check_security_level(2) fails when level > 2... wait, this check is wrong)\n//   - Borrows: BLOCKED\n//   - Repays: BLOCKED\n//   - Liquidations: allowed\n//\n// Security Level 2 (Critical Emergency): Only deposits and liquidations\n//   - Deposits: allowed\n//   - Everything else: BLOCKED\n//\n// The bug: Using if-else on deposit_amount allows attacker to select which security check runs\n// Attacker includes deposit_amount > 0 to trigger the level 1 check, bypassing level 2 restrictions\n//\n// In the vulnerable code:\n// If deposit_amount > 0: checks level 1 (passes at level 0,1,2) ✓\n// If deposit_amount = 0: checks level 2 (passes at level 0,1,2) ✓\n//\n// This means both branches PASS at any security level, making the check ineffective\n// The real protection should be:\n// - Deposit: only allowed if level <= 1 (blocks at level 2)\n// - Withdraw/Repay/Borrow: only allowed if level <= 0 (blocks at level 1 and 2)\n//\n// But wait, looking at check_security_level:\n// if(vault.security_level > required_level) { abort }\n// This aborts when security_level > required_level\n// So check_security_level(1) aborts when level > 1 (level 2 aborts)\n// And check_security_level(2) aborts when level > 2 (never aborts)\n//\n// So the if-else logic:\n// if deposit_amount > 0: check level 1 (allows 0,1 | blocks 2) → But all operations execute!\n// else: check level 2 (allows 0,1,2 | blocks nothing) → But all operations execute!\n//\n// The vulnerability: The if-else gate is skipped by including deposit_amount\n// Attacker can:\n// 1. Set deposit_amount = 1 (any positive value)\n// 2. Set withdraw_amount = large value\n// 3. Call update_position()\n// 4. if-else takes deposit branch: check_security_level(1) is called\n// 5. After if-else, ALL operations execute including withdrawal\n// 6. Even though level 2 should block withdrawal, the if-else structure allows it\n//\n// The fix: Check security level for EACH operation independently\n",
      "relevance": "Detailed explanation of security level semantics and how the if-else vulnerability works in context of emergency mode"
    }
  ],
  "call_flow": "User calls update_position(vault, request{deposit_amount: 1, withdraw_amount: 1000000, ...}) → if(deposit_amount > 0) branch executes → check_security_level(1) is called → passes at all levels including level 2 → Execution continues to operation processing → All four operations execute (deposit, withdraw, repay, borrow) despite level 2 restrictions → User withdraws collateral during emergency",
  "context_hint": "The vulnerability stems from using a single if-else conditional to gate the security level check, when operations should be validated independently. The check_security_level function correctly implements level-based access control, but the if-else structure allows users to choose which check runs by controlling whether deposit_amount is 0 or positive. This is a logic flaw where the security gate doesn't cover all code paths that perform restricted operations. The root cause is assumption that users will either deposit OR do other operations, not both in one call, and that the security check would prevent all restricted operations. But operations execute regardless of which if-else branch was taken.",
  "is_vulnerable": true,
  "expert_notes": "This is a classic case of 'gate escaping' where a security check doesn't guard all execution paths. The if-else structure creates two code paths (deposit-focused vs non-deposit-focused) but both paths eventually reach the operation-processing code. The security check only runs once in the gate, but doesn't prevent the other operations from executing. The Quantstamp auditors correctly identified that each operation type needs its own independent security level validation. This is particularly critical in emergency scenarios where a protocol wants to freeze most functionality but allow deposits for recovery. The fix is straightforward: move security checks to each operation branch or call check_security_level for each operation type independently before execution."
}
