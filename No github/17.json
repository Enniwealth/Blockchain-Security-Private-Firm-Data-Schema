//Marked
[
  {
    "id": "gs_cantina_coinbase_vp2_001",
    "report_url": "https://cantina.xyz/portfolio/d3950206-883f-4308-86b7-c835afd37556",
    "project_name": "Coinbase Verified Pools v2",
    "github_url": "https://github.com/coinbase/verified-pools-contracts-audit",
    "language": "solidity",
    "chain": "base",
    "contest_date": "2025-10-26",
    "vulnerability_type": "price_limit_fee_overcharge",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "swap_routing",
    "is_vulnerable": true,
    "title": "Price Limit in Swaps Causes Excessive Hook Fee Deduction",
    "description": "When a swap specifies a price limit and the amount is in the preferred currency, the hook fee is calculated based on the requested amount in beforeSwap(). However, if the price limit is hit during execution, the actual swapped amount is less than requested. The fee is deducted upfront based on the full requested amount, resulting in the user paying a higher fee than intended—potentially exceeding HOOK_FEE_CAP. The afterSwap handling then compounds the issue by charging the user rather than refunding.",
    "primary_file": {
      "name": "VerifiedPoolsBasicHookV2.sol",
      "path": "src/VerifiedPoolsBasicHookV2.sol",
      "lines": "145-180",
      "content": "function beforeSwap(\n    address sender,\n    IPoolManager.SwapParams calldata params,\n    bytes calldata hookData\n) external view override returns (bytes4, int128, uint128) {\n    // Fee calculation based on REQUESTED amount (may not be actual amount if price limit hit)\n    uint128 fee = 0;\n    \n    if (params.amountSpecified > 0 && isPreferredCurrency(params)) {\n        // Input is preferred currency: must calculate fee upfront\n        // BUG: Uses requested amount, not actual amount that will be swapped\n        fee = _calculateFeeForExactInput(\n            uint128(params.amountSpecified),\n            hookFeePercentage\n        );\n        // Fee is deducted from the requested amount\n        // But if price limit is reached, actual swap amount < requested\n        // User still pays full fee based on requested amount!\n    }\n    \n    return (this.beforeSwap.selector, -int128(fee), 0);\n}\n\n// Hook fee calculation\nfunction _calculateFeeForExactInput(\n    uint128 inputAmount,\n    uint128 feePercentage\n) internal pure returns (uint128) {\n    // fee = (inputAmount * feePercentage) / 10_000\n    // BUG: Doesn't account for price limit scenario\n    uint256 feeAmount = (uint256(inputAmount) * uint256(feePercentage)) / 10_000;\n    return uint128(feeAmount);\n}\n\n// ATTACK SCENARIO WITH PRICE LIMIT:\n// 1. User wants to swap 1000 USDC (preferred) for ETH\n// 2. Fee rate: 1% (100 basis points)\n// 3. Price limit: sqrtPriceX96 - 100 (slightly lower, limits execution)\n// 4. beforeSwap calculates: fee = 1000 * 1% = 10 USDC\n// 5. 10 USDC deducted, 990 USDC actually swapped\n// 6. Price limit hit: only 100 wei of ETH received (extremely bad swap)\n// 7. User paid 10 USDC fee but effectively swapped only 990 USDC for near-zero ETH\n// 8. Fee as percentage of actual swap: 10 / 990 = 1.01% (acceptable)\n// 9. But user lost most of their value to bad pricing at limit"
    },
    "context_files": [
      {
        "name": "Swap Parameter Flow",
        "path": "src/VerifiedPoolsBasicHookV2.sol",
        "relevance": "Shows how swapParams including price limit flow through the hook",
        "content": "interface IPoolManager {\n    struct SwapParams {\n        bool zeroForOne;           // Swap direction\n        int256 amountSpecified;    // Amount to swap\n        uint160 sqrtPriceLimitX96;  // BUG: Price limit can cause actual amount < requested\n    }\n}\n\ncontract VerifiedPoolsBasicHookV2 {\n    function beforeSwap(\n        address sender,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external view override returns (bytes4, int128, uint128) {\n        // params.amountSpecified: requested amount (may not be actual)\n        // params.sqrtPriceLimitX96: price limit (if hit, swap completes partially)\n        \n        // Current implementation:\n        // 1. Calculates fee based on params.amountSpecified\n        // 2. Deducts full fee upfront\n        // 3. If sqrtPriceLimitX96 hit during execution:\n        //    - Pool returns less than amountSpecified\n        //    - User still paid full fee\n        //    - Effective fee percentage is much higher\n        \n        uint128 fee = _calculateFeeForExactInput(\n            uint128(Math.abs(params.amountSpecified)),\n            hookFeePercentage\n        );\n        \n        // Returns negative to deduct from input\n        return (this.beforeSwap.selector, -int128(fee), 0);\n    }\n    \n    function afterSwap(\n        address,\n        IPoolManager.SwapParams calldata params,\n        BalanceDelta delta,\n        bytes calldata\n    ) external override returns (bytes4, int128) {\n        // delta: actual amounts from pool\n        // If price limit caused partial execution:\n        // - delta.amount0 < abs(params.amountSpecified) if token0\n        // - delta.amount1 > abs(params.amountSpecified) if token1 (unexpected)\n        \n        // This mismatch can cause afterSwap to charge user instead of refund\n        // See separate finding 1.2 on unspecifiedDelta truncation\n        \n        return (this.afterSwap.selector, 0);\n    }\n}"
      },
      {
        "name": "Fee Overcharge Scenario",
        "path": "reference/price_limit_fee_scenario.md",
        "relevance": "Documents the fee overcharge scenario with actual numbers",
        "content": "SCENARIO: Excessive Fee Due to Price Limit\n\nSetup:\n- Swap router supports price limits (some do, Uniswap universal router doesn't)\n- Hook fee: 1% = 100 basis points\n- User wants to swap exactly 1000 USDC for ETH\n- Price limit set to slightly worse than current price (protection)\n\nCurrent Flow (VULNERABLE):\n\n1. User calls swap:\n   - amountSpecified: -1000 USDC (exact input)\n   - sqrtPriceLimitX96: currentPrice - margin (e.g., 1% below)\n   - Output: ETH (unspecified)\n\n2. beforeSwap executes:\n   - fee = 1000 * 100 / 10_000 = 10 USDC\n   - Returns -10 (deduct 10 from input)\n   - User balance: -10 USDC (fee)\n\n3. Pool executes swap:\n   - Input available: 1000 - 10 = 990 USDC\n   - Price deteriorates during execution\n   - sqrtPriceLimitX96 hit with only 100 wei of ETH returned\n   - Swap completes with: 990 USDC → 100 wei ETH\n\n4. afterSwap processes:\n   - delta0: 990 USDC (actual input)\n   - delta1: 100 wei ETH (actual output)\n   - No refund/correction happens\n\n5. Final result:\n   - User paid 10 USDC fee\n   - User received 100 wei ETH for 990 USDC\n   - Effective value: fee = 10 USDC / 990 = 1.01%\n   - But user got extreme slippage (100 wei ETH for 990 USDC)\n   - Fee was designed for normal execution, not for price limit scenario\n\nPROBLEM:\n- Fee was calculated assuming full 1000 USDC would be swapped\n- Price limit prevented that, user suffered massive slippage\n- Fee structure breaks when price limit is triggered\n- User pays 1% on the \"intended\" amount, not the \"actual\" amount\n\nIF HOOK_FEE_CAP = 0.5%:\n- Calculated fee: 1% (10 USDC) EXCEEDS CAP\n- Yet it was deducted anyway\n- Cap enforcement is bypassed when price limits hit"
      }
    ],
    "call_flow": [
      "1. Swap router calls swap with price limit parameter",
      "2. Router specifies amountSpecified and sqrtPriceLimitX96",
      "3. beforeSwap hook called BEFORE pool execution",
      "4. Hook calculates fee based on amountSpecified (assumed to be swapped)",
      "5. Hook returns negative deltaAmount0 (fee deduction)",
      "6. Pool begins swap execution",
      "7. During execution, pool hits sqrtPriceLimitX96",
      "8. Swap stops early: actual output < expected",
      "9. Actual swapped amount < amountSpecified",
      "10. But beforeSwap already deducted fee based on amountSpecified",
      "11. User overpaid fees because actual swap was smaller",
      "12. afterSwap receives delta with actual (smaller) amounts",
      "13. Mismatch: fee was calculated for larger amount than executed",
      "14. No correction mechanism in afterSwap for price limit scenarios"
    ],
    "context_hint": "The core issue is that beforeSwap deducts fees before execution, assuming the full requested amount will be swapped. However, price limits in the swap parameters can cause the actual execution to be smaller. The fee should be recalculated based on the actual amount swapped, which can only be determined after the swap completes (in afterSwap). The hook needs to deduct excess fees or refund overpaid amounts.",
    "expert_notes": "This is a complex hook design issue at the intersection of Uniswap V4 hook semantics and fee calculation logic. The beforeSwap/afterSwap pattern works well for standard swaps but breaks when the execution amount differs from the requested amount. The fix requires either: (1) recalculating and refunding/deducting fees in afterSwap based on actual amounts, or (2) forbidding swaps with price limits when using the dynamic fee hook. Coinbase implemented solution (1) in PR #11 by refunding overcharged fees.",
    "fix_description": "Recalculate the fee based on actual swap amount in afterSwap and refund any excess fee that was deducted in beforeSwap due to the price limit causing smaller actual execution.",
    "fix_code": "function afterSwap(\n    address sender,\n    IPoolManager.SwapParams calldata params,\n    BalanceDelta delta,\n    bytes calldata hookData\n) external override returns (bytes4, int128) {\n    // delta represents ACTUAL amounts from pool execution\n    // params.amountSpecified is the REQUESTED amount\n    \n    // FIXED: Recalculate fee based on ACTUAL amounts\n    if (params.amountSpecified > 0 && isPreferredCurrency(params)) {\n        // Input currency is preferred: fee was taken from input\n        \n        // Actual input used (from delta)\n        uint128 actualInput = uint128(Math.abs(delta.amount0)); // or amount1\n        \n        // Fee that should have been deducted (based on actual)\n        uint128 correctFee = _calculateFeeForExactInput(\n            actualInput,\n            hookFeePercentage\n        );\n        \n        // Fee that was deducted (based on requested)\n        uint128 deductedFee = uint128(Math.abs(params.amountSpecified)) * hookFeePercentage / 10_000;\n        \n        // If deducted fee > correct fee, refund the difference\n        if (deductedFee > correctFee) {\n            int128 refund = int128(uint128(deductedFee - correctFee));\n            // Return positive to add back to sender's balance\n            return (this.afterSwap.selector, refund);\n        }\n    }\n    \n    return (this.afterSwap.selector, 0);\n}"
  },
  {
    "id": "gs_cantina_coinbase_vp2_002",
    "report_url": "https://cantina.xyz/portfolio/d3950206-883f-4308-86b7-c835afd37556",
    "project_name": "Coinbase Verified Pools v2",
    "github_url": "https://github.com/coinbase/verified-pools-contracts-audit",
    "language": "solidity",
    "chain": "base",
    "contest_date": "2025-10-26",
    "vulnerability_type": "truncation_loss",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "arithmetic",
    "is_vulnerable": true,
    "title": "Truncation on unspecifiedDelta Breaks Fee Invariant, User Receives More Than Intended",
    "description": "The unspecifiedDelta calculation in swap fee handling (cases 3 and 4) truncates the total fee downward. This breaks the intended invariant that `denominator = numerator/feeAmt` and `feeAmt = numerator/denominator` should hold. As a result, users receive slightly more funds than intended—the dust from precision loss. The pool manager receives less fee than it should, losing funds to rounding.",
    "primary_file": {
      "name": "VerifiedPoolsBasicHookV2.sol",
      "path": "src/VerifiedPoolsBasicHookV2.sol",
      "lines": "210-250",
      "content": "function _calculateUnspecifiedDelta(\n    int256 specifiedDelta,\n    uint128 hookFee\n) internal pure returns (int256) {\n    // When one side is specified (e.g., exact input USDC)\n    // The other side is unspecified (e.g., output ETH)\n    // Fee must be calculated and applied to unspecified side\n    \n    // Formula: unspecified = numerator / (denominator)\n    // Where: denominator = 10_000 + hookFee (for output fees)\n    //        denominator = 10_000 - hookFee (for input fees)\n    \n    uint256 numerator = uint256(-specifiedDelta); // The specified amount\n    \n    // CASE 3: Output is preferred, fee taken from output\n    // unspecifiedFee = (numerator * hookFee) / (10_000 - hookFee)\n    uint256 denominator = 10_000 - hookFee;\n    int256 unspecifiedDelta = int256(numerator / denominator);\n    \n    // BUG: Integer division truncates downward\n    // Example: numerator = 679999967459348139995\n    //          hookFee = 67999996745934813\n    //          denominator = 10000\n    //          Expected: 67999996745934813.9995\n    //          Actual: 67999996745934813 (truncated)\n    //          Difference: 0.9995 wei\n    \n    // Pool manager receives 0.9995 wei LESS than expected\n    // User effectively receives 0.9995 wei MORE than should\n    \n    return unspecifiedDelta;\n    // BUG: No rounding up, precision loss to user's benefit\n}\n\n// INVARIANT VIOLATION:\n// Intended: feeAmt = numerator / denominator\n//           If you reconstruct: denominator = numerator / feeAmt\n//           Should hold perfectly\n// \n// With truncation: feeAmt is too small\n//                 denominator * feeAmt < numerator (off by dust)\n//                 Invariant broken"
    },
    "context_files": [
      {
        "name": "Fee Calculation Cases",
        "path": "src/VerifiedPoolsBasicHookV2.sol",
        "relevance": "Shows all four fee calculation cases and where truncation occurs",
        "content": "// Hook fee can be applied to input (specified) or output (unspecified)\n// Depending on which currency is preferred\n\n// CASE 1: Exact Input, Output is Preferred (fee from output)\n// Input: USDC (not preferred) - fully specified\n// Output: ETH (preferred) - unspecified\n// Fee location: deducted from ETH output\n// Calculation: expectedFee = inputDelta * hookFee / (10_000 + hookFee)\n// VULNERABLE: Uses division, truncates down\n\n// CASE 2: Exact Output, Input is Preferred (fee from input)  \n// Input: USDC (preferred) - unspecified\n// Output: ETH (not preferred) - fully specified\n// Fee location: deducted from USDC input\n// Calculation: expectedFee = outputDelta * hookFee / (10_000 - hookFee)\n// VULNERABLE: Uses division, truncates down\n\n// CASE 3: Exact Input, Input is Preferred (fee from input)\n// Input: USDC (preferred) - specified\n// Output: ETH (not preferred) - unspecified\n// Fee location: deducted from input\n// Calculation: expectedFee = inputDelta * hookFee / 10_000\n// Can be vulnerable depending on implementation\n\n// CASE 4: Exact Output, Output is Preferred (fee from output)\n// Input: USDC (not preferred) - unspecified\n// Output: ETH (preferred) - specified\n// Fee location: deducted from output\n// Calculation: expectedFee = outputDelta * hookFee / 10_000\n// Can be vulnerable depending on implementation\n\n// Fuzzing found: (numerator / denominator) truncation causes invariant break"
      },
      {
        "name": "Fuzzer Proof of Concept",
        "path": "reference/truncation_fuzz_poc.md",
        "relevance": "Shows the exact fuzzer case that triggered the bug",
        "content": "Fuzzer-Found Case:\n\nnumerator = 679999967459348139995\nfeeAmt = 67999996745934813\ndenominator = 10000\n\nCalculation:\nnumerator / feeAmt = 679999967459348139995 / 67999996745934813\nExpected: 10000 (exactly, as denominator)\nActual (with truncation): 10000 (happens to be exact here)\n\nBUT the reverse calculation breaks:\nfeeAmt = numerator / denominator\nExpected: 679999967459348139995 / 10000 = 67999996745934813.9995\nActual (with truncation): 67999996745934813\n\nDifference: 0.9995 wei\n\nAssertion that fails:\n```\nassertGe(expectedFee, 0);  // passes\nassertGe(postSwapBalances[2], preSwapBalances[2]);  // FAILS\n\n// Manager receives:\nexpectedFee = 67999996745934814 wei (should receive this much)\nactualFee = 67999996745934813 wei (only received this much)\nDifference: 1 wei loss to pool manager\n```\n\nTest Results:\n```\n├─ [0] VM::assertGe(67999996745934814 [6.799e16], 0) [staticcall]\n│   └─ ← [Return]\n├─ [0] VM::assertGe(67999996745934813 [6.799e16], 0) [staticcall]\n│   └─ ← [Return]  ← FAILS: 67999996745934813 < 67999996745934814\n```\n\nImpact:\nPool manager loses 1 wei per this type of swap\nWith millions of swaps, these 1-wei losses accumulate\nUser benefits by 1 wei per transaction"
      },
      {
        "name": "Rounding Invariant",
        "path": "reference/rounding_invariant.md",
        "relevance": "Explains the mathematical invariant that should hold",
        "content": "Fee Calculation Invariant:\n\nFor an exact output swap with fee:\n\nLet O = output amount (specified)\nLet H = hook fee percentage (bps)\n\nThe fee calculation should satisfy:\n\nfee = O * H / (10_000 - H)  [Case 2: fee from input]\nOR\nfee = O * H / (10_000 + H)  [Case 1: fee from output]\n\nMathematical property:\nIf fee = numerator / denominator\nThen denominator = numerator / fee (should be exact)\n\nExample:\n- O = 100 (output amount)\n- H = 100 (1% fee)\n- denominator = 10_000 - 100 = 9_900\n- fee = 100 * 100 / 9_900 = 10_000 / 9_900 = 1.0101...\n\nWith truncation: fee = 1 wei\nReconstruction: denominator = 100 / 1 = 100 (WRONG! Should be ~9_900)\n\nThe invariant is broken by truncation.\n\nCorrect approach:\nRound UP to preserve invariant:\nfee = (numerator + denominator - 1) / denominator\nThis ensures fee >= true value\nUser pays slightly more, manager receives slightly more\nInvariant preserved"
      }
    ],
    "call_flow": [
      "1. Swap with unspecified delta: exact input specified, output unspecified",
      "2. beforeSwap: fee calculated for specified side (e.g., input)",
      "3. Pool executes swap, returns delta with actual output",
      "4. afterSwap: must reconcile fee for unspecified side",
      "5. unspecifiedDelta = numerator / denominator (integer division)",
      "6. Division truncates downward: 67999996745934813.9995 → 67999996745934813",
      "7. User receives 0.9995 wei more than calculated",
      "8. Pool manager receives 0.9995 wei less than intended",
      "9. Invariant check fails: denominator * fee ≠ numerator",
      "10. Over millions of swaps, wei losses accumulate to significant amounts"
    ],
    "context_hint": "Integer division in Solidity always truncates toward zero. When calculating fees as `numerator / denominator`, the result is always rounded down. This is acceptable when the rounding error is acceptable, but for fee calculations where `denominator = numerator / fee` should hold exactly, truncation breaks the invariant. The fix is to explicitly round UP using `(numerator + denominator - 1) / denominator`.",
    "expert_notes": "This is a subtle but important arithmetic issue in fee calculations. The Uniswap V4 hook pattern requires careful handling of fee math because fees are split across hook stages (beforeSwap/afterSwap). Truncation at the wrong stage can shift value between user and pool. The fuzzer discovered this because it uses diverse numeric values; static test cases with power-of-2 or simple numbers won't trigger the issue. Coinbase's fix involved both fixing the rounding (PR #11) and improving the test suite to use fuzz tests (PR #11).",
    "fix_description": "Round UP the division to preserve the fee invariant, ensuring the pool manager receives the correct fee amount and the invariant `denominator * fee ≈ numerator` holds.",
    "fix_code": "function _calculateUnspecifiedDelta(\n    int256 specifiedDelta,\n    uint128 hookFee\n) internal pure returns (int256) {\n    uint256 numerator = uint256(-specifiedDelta);\n    uint256 denominator = 10_000 - hookFee;  // or 10_000 + hookFee depending on case\n    \n    // FIXED: Round UP instead of truncating down\n    // (a + b - 1) / b rounds a/b up to nearest integer\n    uint256 feeAmount = (numerator + denominator - 1) / denominator;\n    \n    // Now the invariant holds:\n    // (denominator * feeAmount) >= numerator\n    // And the pool manager receives the correct amount\n    \n    return int256(feeAmount);\n}\n\n// Alternative fix using mulDiv with rounding:\nfunction _calculateFeeWithRounding(\n    uint256 amount,\n    uint128 feePercentage\n) internal pure returns (uint256) {\n    // Uses OZ's mulDiv which handles overflow safely\n    // FullMath.mulDiv(amount, feePercentage, 10_000)\n    // Optionally: mulDivRoundingUp for explicit rounding up\n    return FullMath.mulDivRoundingUp(amount, feePercentage, 10_000);\n}"
  },
  {
    "id": "gs_cantina_coinbase_vp2_003",
    "report_url": "https://cantina.xyz/portfolio/d3950206-883f-4308-86b7-c835afd37556",
    "project_name": "Coinbase Verified Pools v2",
    "github_url": "https://github.com/coinbase/verified-pools-contracts-audit",
    "language": "solidity",
    "chain": "base",
    "contest_date": "2025-10-26",
    "vulnerability_type": "fee_calculation_rounding",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "arithmetic",
    "is_vulnerable": true,
    "title": "Fee Calculations Truncated Downward Instead of Rounded Upward",
    "description": "The beforeSwap and afterSwap functions calculate fees by scaling values to uint256 and then downcasting back to int128. This combination of upcasting, arithmetic, and downcasting causes consistent downward truncation of fees. The protocol receives less fee than intended, with the difference (dust) benefiting users. The effect is subtle per swap but significant at scale.",
    "primary_file": {
      "name": "VerifiedPoolsBasicHookV2.sol",
      "path": "src/VerifiedPoolsBasicHookV2.sol",
      "lines": "185-210",
      "content": "function _calculateScaledFeeForExactOutput(\n    uint128 outputAmount,\n    uint128 hookFee\n) internal pure returns (int128) {\n    // Scale up to uint256 for calculation\n    uint256 numerator = uint256(outputAmount) * uint256(hookFee);\n    uint256 denominator = 10_000;\n    \n    // BUG: Integer division truncates downward\n    uint256 scaledFee = numerator / denominator;\n    // Example: 100 * 1500 / 10_000 = 150_000 / 10_000 = 15.0\n    // But if: 99 * 1515 / 10_000 = 150_185 / 10_000 = 15.0185\n    // Result: 15 (truncated, should be 15.0185 or rounded to 16)\n    \n    // Then downcast back to int128\n    return int128(scaledFee);\n    // BUG: Truncation is permanent, no rounding\n}\n\nfunction _calculateScaledFeeForExactInput(\n    uint128 inputAmount,\n    uint128 hookFee\n) internal pure returns (int128) {\n    // Same pattern of truncation\n    uint256 numerator = uint256(inputAmount) * uint256(hookFee);\n    uint256 denominator = 10_000 + hookFee;  // or 10_000 - hookFee\n    \n    // BUG: Division truncates, loses precision\n    uint256 scaledFee = numerator / denominator;\n    \n    return int128(scaledFee);\n    // User pays less fee than intended\n    // Pool receives less fee than intended\n}\n\n// IMPACT CALCULATION:\n// Fee percentage: 100 bps (1%)\n// Swap amount: 99 wei (small but real at scale)\n// Calculated fee: 99 * 100 / 10_000 = 0.99 wei\n// Truncated to: 0 wei (lost 0.99 wei)\n// \n// Swap amount: 10_000 wei (more typical)\n// Calculated fee: 10_000 * 100 / 10_000 = 100 wei\n// No truncation here, but...\n// \n// Swap amount: 10_001 wei\n// Calculated fee: 10_001 * 100 / 10_000 = 100.01 wei\n// Truncated to: 100 wei (lost 0.01 wei)\n// \n// Over millions of swaps, these losses accumulate"
    },
    "context_files": [
      {
        "name": "Fee Calculation Pattern",
        "path": "src/VerifiedPoolsBasicHookV2.sol",
        "relevance": "Shows the pattern used throughout fee calculations",
        "content": "// Throughout the hook, fees are calculated with this pattern:\n\n// Pattern 1: Direct percentage calculation\nfee = (amount * feePercentage) / 10_000;\n// Truncates down: 1001 * 100 / 10_000 = 10.01 → 10\n\n// Pattern 2: Reverse calculation (exact output with fee)\nfee = (amount * feePercentage) / (10_000 - feePercentage);\n// Truncates down: same issue\n\n// Pattern 3: Scale up for division\nuint256 scaledNumerator = uint256(amount) * uint256(feePercentage);\nuint256 fee = scaledNumerator / 10_000;\nreturn int128(fee);\n// Still truncates, loses precision in downcast\n\n// Current implementation uses Pattern 3\n// All three patterns have the same fundamental issue:\n// Integer division always rounds down in Solidity\n\n// Correct implementation should round UP:\nfee = (amount * feePercentage + 9_999) / 10_000;\n// This ensures: (fee * 10_000) >= (amount * feePercentage)\n// User always pays at least the intended fee percentage"
      },
      {
        "name": "Accumulation at Scale",
        "path": "reference/fee_truncation_scale.md",
        "relevance": "Shows how small truncations accumulate to significant losses",
        "content": "Fee Truncation Accumulation:\n\nAssuming Verified Pools with:\n- Average swap: 1000 wei (could be USD, ETH, etc.)\n- Fee rate: 100 bps (1%)\n- Expected fee per swap: 10 wei\n\nScenario 1: Amount that doesn't divide evenly\n- Swap: 1001 wei\n- Expected fee: 1001 * 100 / 10_000 = 10.01 wei\n- Actual fee (truncated): 10 wei\n- Loss per swap: 0.01 wei\n\nScenario 2: Reverse calculation\n- Output specified: 999 wei\n- Fee percentage: 100 bps\n- Expected fee: 999 * 100 / 9_900 = 10.09... wei\n- Actual fee (truncated): 10 wei\n- Loss per swap: 0.09 wei\n\nAccumulation Over Time:\n- Daily swaps: 100,000\n- Average truncation loss per swap: 0.05 wei\n- Daily loss: 5,000 wei\n- Yearly loss: 1,825,000 wei\n\nToken context:\n- If token has 18 decimals: 1,825,000 wei = 0.000001825 tokens\n- If 1 token = $10: loss = $0.00001825 per year\n\n- If token has 6 decimals (USDC): 1,825,000 wei = 1.825 USDC per year\n- If 1 USDC = $1: loss = $1.825 per year\n\n- If high-volume DEX with 1M swaps/day:\n- Daily loss: 50,000 wei\n- Yearly loss: 18,250,000 wei\n- At 6 decimals: 18.25 tokens per year\n- Significant for protocol revenue\n\nCombined with finding 1.2 (truncation in unspecifiedDelta):\n- Multiple fee calculation paths all truncate\n- Losses compound across different swap types\n- Total loss is higher than any single path\n\nPROTOCOL IMPACT:\nVerified Pools fee revenue depends on:\n1. Hook fee percentage (set by pool creators)\n2. Swap volume\n3. Fee calculation accuracy\n\nTruncation reduces #3, lowering actual revenue collection"
      }
    ],
    "call_flow": [
      "1. beforeSwap called with exact input swap",
      "2. Input amount: 1001 wei, fee rate: 100 bps",
      "3. _calculateScaledFeeForExactInput called",
      "4. numerator = 1001 * 100 = 100_100",
      "5. denominator = 10_000 + 100 = 10_100",
      "6. Division: 100_100 / 10_100 = 9.9108... wei",
      "7. Integer division result: 9 wei (truncated from 9.9108)",
      "8. Downcast to int128: int128(9)",
      "9. beforeSwap returns -9 (deduct 9 wei from user)",
      "10. User pays 9 wei but should pay ~9.91 wei",
      "11. Loss: 0.91 wei per swap",
      "12. Accumulated over 1M swaps: 910,000 wei lost"
    ],
    "context_hint": "Integer division in Solidity truncates toward zero (rounds down). For fee calculations, this is problematic because the protocol should receive at minimum the intended fee percentage. Rounding down means the protocol receives less. The fix is to explicitly round UP using techniques like `(numerator + denominator - 1) / denominator` or using OpenZeppelin's `mulDivRoundingUp`.",
    "expert_notes": "This is a widespread pattern in DeFi contracts. The issue is subtle because the loss per transaction is tiny (fractions of wei), but at scale it compounds. The Uniswap codebase is careful about rounding in favor of the protocol, using `FullMath.mulDivRoundingUp` for fee calculations. Coinbase's fix involved adding explicit rounding-up logic throughout the fee calculation path.",
    "fix_description": "Replace all fee calculations to explicitly round UP, ensuring the protocol receives at least the intended fee percentage and the rounding invariant holds.",
    "fix_code": "function _calculateScaledFeeForExactOutput(\n    uint128 outputAmount,\n    uint128 hookFee\n) internal pure returns (int128) {\n    // FIXED: Round UP instead of truncating down\n    uint256 numerator = uint256(outputAmount) * uint256(hookFee);\n    uint256 denominator = 10_000;\n    \n    // Round up: (a + b - 1) / b\n    uint256 scaledFee = (numerator + denominator - 1) / denominator;\n    \n    return int128(scaledFee);\n    // Now: 100 * 100 / 10_000 = 10_000 / 10_000 = 1 wei (no loss)\n    //      99 * 100 / 10_000 = 9_900 / 10_000 rounds to 1 wei (not 0)\n}\n\nfunction _calculateScaledFeeForExactInput(\n    uint128 inputAmount,\n    uint128 hookFee\n) internal pure returns (int128) {\n    uint256 numerator = uint256(inputAmount) * uint256(hookFee);\n    uint256 denominator = 10_000 + hookFee;\n    \n    // FIXED: Explicit rounding up\n    uint256 scaledFee = (numerator + denominator - 1) / denominator;\n    \n    return int128(scaledFee);\n    // Protocol receives correct fee, user pays intended percentage\n}\n\n// Alternative using OpenZeppelin:\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nfunction _calculateFeeOZ(\n    uint128 amount,\n    uint128 feePercentage\n) internal pure returns (int128) {\n    // Uses mulDiv with built-in rounding up\n    uint256 fee = Math.mulDivRoundingUp(\n        uint256(amount),\n        uint256(feePercentage),\n        10_000\n    );\n    return int128(fee);\n}"
  }
]