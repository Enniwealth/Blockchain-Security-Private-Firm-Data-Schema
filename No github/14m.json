[
  {
    "id": "gs_cantina_multiliquid_001",
    "report_url": "https://cantina.xyz/portfolio/92ee7667-c017-46fa-8882-416862c1365b",
    "project_name": "Multiliquid V2",
    "github_url": "https://github.com/uniformlabs/Multiliquid",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-11-11",
    "vulnerability_type": "fee_calculation",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Fee Is Overcharged for RWA to RWA Swap in exactOut Case",
    "description": "In RWA to RWA swaps using exactOut, the redemption fee calculation applies the fee twice to the input amount. The formula uses rwaInUSDWad which already includes the fee in its calculation, then applies the fee again in the delta computation, causing users to be charged higher redemption fees than intended.",
    "primary_file": {
      "name": "MultiLiquidSwap.sol",
      "path": "src/MultiLiquidSwap.sol",
      "lines": "180-200",
      "content": "function _calculateRWAToRWA(\n    bool exactOut,\n    uint256 rwaInID,\n    uint256 rwaInAmount,\n    uint256 rwaOutID,\n    uint256 rwaOutAmount\n) internal view returns (RWAToRWAReturnParams memory outputs) {\n    uint256 rwaInPrice = getRWAPrice(rwaInID);\n    uint256 rwaOutPrice = getRWAPrice(rwaOutID);\n    \n    uint256 rwaInUSDWad = rwaInAmount.mulWad(rwaInPrice);\n    uint256 rwaOutUSDWad = rwaOutAmount.mulWad(rwaOutPrice);\n    uint256 rwaOutAmtWad = rwaOutUSDWad.divWad(rwaOutPrice);\n    \n    if (exactOut) {\n        // BUG: Redemption fee applied twice\n        outputs.redemptionFeeAmt = _fromWad(\n            (\n                rwaInUSDWad.divWadUp(\n                    WAD - redemptionFeeRateIn  // Fee already in rwaInUSDWad\n                ) - rwaInUSDWad  // This subtracts fee from fee-inclusive amount\n            ) + (\n                rwaOutUSDWad - rwaOutAmtWad.mulWad(rwaOutPrice)  // Additional fee\n            ),\n            params.stablecoinDecimals\n        );\n    }\n}"
    },
    "context_files": [
      {
        "name": "Fee Calculation Helper",
        "path": "src/libraries/FeeCalculation.sol",
        "relevance": "Shows how redemption fee rates are applied",
        "content": "// Redemption fee rate: applied as discount from full amount\n// E.g., 1% redemption fee on 100 USD input:\n// Net amount received = 100 * (1 - 0.01) = 99 USD\n// Fee charged = 100 - 99 = 1 USD\n\nfunction calculateRedemptionFee(\n    uint256 amount,\n    uint256 feeRate\n) internal pure returns (uint256 feeAmount) {\n    // Fee = amount - (amount / (1 - feeRate))\n    // Simplified: amount * feeRate / (1 - feeRate)\n    uint256 netAmount = amount.mulWad(WAD - feeRate) / WAD;\n    feeAmount = amount - netAmount;\n}\n\n// In exactOut case:\n// rwaInUSDWad = input amount in USD (after fee is accounted for)\n// divWadUp(WAD - redemptionFeeRateIn) = dividing by (1 - fee rate)\n// This REVERSES the fee calculation\n// But then subtracting original rwaInUSDWad double-counts"
      },
      {
        "name": "Correct Formula",
        "path": "reference/correct_fee_formula.md",
        "relevance": "Shows the correct redemption fee calculation",
        "content": "INCORRECT (Current):\noutputs.redemptionFeeAmt = (rwaInUSDWad / (1 - fee) - rwaInUSDWad) + extra\n                         = (rwaInUSDWad / (1 - fee)) - rwaInUSDWad + extra\n                         = fee double-counted\n\nCORRECT (Should be):\noutputs.redemptionFeeAmt = rwaInUSDWad - rwaOutAmtWad * rwaOutPrice\n                         = total input - actual output\n                         = what actually got charged\n\nThe redemption fee should be:\nFee = Input Value (in USD) - Output Value (in USD)\nFee = rwaInUSDWad - (rwaOutAmtWad * rwaOutPrice)"
      }
    ],
    "call_flow": [
      "1. User initiates exactOut RWA swap: swap 100 RWA-A for exactly 50 RWA-B",
      "2. Calculate prices: RWA-A = $1/unit, RWA-B = $2/unit",
      "3. rwaInUSDWad = 100 * 1e18 = 100e18 USD",
      "4. rwaOutUSDWad = 50 * 2e18 = 100e18 USD",
      "5. Redemption fee rate = 1% (0.01e18)",
      "6. Calculate fee using buggy formula:",
      "7. divWadUp(WAD - 0.01e18) reverses fee: 100e18 / 0.99e18 ≈ 101.01e18",
      "8. Subtract rwaInUSDWad: 101.01e18 - 100e18 = 1.01e18",
      "9. Should be: 100e18 - 100e18 = 0 (both sides equal in USD)",
      "10. But buggy formula charges 1.01 USD fee instead of 1.00 USD",
      "11. User charged ~1% MORE than intended due to double-counting"
    ],
    "context_hint": "The vulnerability stems from confusion about fee direction in the formula. When doing exactOut, the system needs to calculate how much input is needed. The divWadUp operation attempts to reverse-calculate the input from output, but it's applied incorrectly—the code reverses a fee that's already been accounted for, creating double-counting.",
    "expert_notes": "This is a subtle mathematics error in fee calculation. The formula tries to handle the exactOut case by reversing the fee calculation, but applies it redundantly. The fix is to simplify: always calculate fee as the difference between input and output values in USD. Uniform Labs fixed this in PR #1ce7b92 by using the corrected formula: redemptionFeeAmt = rwaInUSDWad - rwaOutAmtWad.mulWad(rwaOutPrice).",
    "fix_description": "Correct the redemption fee calculation to use the difference between input and output values instead of double-applying the fee rate.",
    "fix_code": "function _calculateRWAToRWA(\n    bool exactOut,\n    uint256 rwaInID,\n    uint256 rwaInAmount,\n    uint256 rwaOutID,\n    uint256 rwaOutAmount\n) internal view returns (RWAToRWAReturnParams memory outputs) {\n    uint256 rwaInPrice = getRWAPrice(rwaInID);\n    uint256 rwaOutPrice = getRWAPrice(rwaOutID);\n    \n    uint256 rwaInUSDWad = rwaInAmount.mulWad(rwaInPrice);\n    uint256 rwaOutUSDWad = rwaOutAmount.mulWad(rwaOutPrice);\n    uint256 rwaOutAmtWad = rwaOutUSDWad.divWad(rwaOutPrice);\n    \n    if (exactOut) {\n        // FIXED: Calculate fee as simple difference between input and output\n        outputs.redemptionFeeAmt = _fromWad(\n            rwaInUSDWad - rwaOutAmtWad.mulWad(rwaOutPrice),\n            params.stablecoinDecimals\n        );\n    } else {\n        // exactIn case (unchanged)\n        outputs.redemptionFeeAmt = _fromWad(\n            (rwaInUSDWad - rwaOutUSDWad),\n            params.stablecoinDecimals\n        );\n    }\n}"
  },
  {
    "id": "gs_cantina_multiliquid_002",
    "report_url": "https://cantina.xyz/portfolio/92ee7667-c017-46fa-8882-416862c1365b",
    "project_name": "Multiliquid V2",
    "github_url": "https://github.com/uniformlabs/Multiliquid",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-11-11",
    "vulnerability_type": "fee_calculation",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Redemption Fee Is Overcharged for Stablecoin to RWA Swaps",
    "description": "In swapIntoRWA function, the redemption fee is calculated based on the entire stablecoin amount, but only the amount after protocol fee deduction (stablecoinAmount - protocolFee) is actually swapped into RWA. This causes users to be overcharged on redemption fees relative to what is actually being converted.",
    "primary_file": {
      "name": "MultiLiquidSwap.sol",
      "path": "src/MultiLiquidSwap.sol",
      "lines": "220-245",
      "content": "function swapIntoRWA(\n    uint256 stablecoinID,\n    address stablecoin,\n    uint256 stablecoinAmount,\n    uint256 rwaOutID,\n    uint256 minRWAOut\n) external returns (uint256 rwaOutAmount) {\n    // Charge protocol fee from full stablecoinAmount\n    uint256 protocolFee = _calculateMultiliquidFee(stablecoinAmount);\n    uint256 effectiveAmount = stablecoinAmount - protocolFee;\n    \n    // BUG: Calculate redemption fee on original stablecoinAmount\n    // But only effectiveAmount is actually converted\n    uint256 stablecoinInUSD = stablecoinAmount.mulWad(getStablecoinUSDValue(stablecoinID));\n    uint256 redemptionFee = stablecoinInUSD.mulWad(redemptionFeeRate);\n    \n    // Should be calculated on effectiveAmount instead:\n    // uint256 redemptionFee = effectiveAmount.mulWad(...).mulWad(redemptionFeeRate);\n    \n    // Only effectiveAmount is converted\n    rwaOutAmount = convertStablecoinToRWA(\n        stablecoin,\n        effectiveAmount,  // NOT stablecoinAmount\n        rwaOutID\n    );\n}"
    },
    "context_files": [
      {
        "name": "Correct Implementations",
        "path": "src/MultiLiquidSwap.sol",
        "relevance": "Shows how other swap functions correctly handle fee calculation",
        "content": "// swapIntoRWAExactOut - CORRECT\nfunction swapIntoRWAExactOut(\n    uint256 stablecoinID,\n    address stablecoin,\n    uint256 maxStablecoinIn,\n    uint256 rwaOutID,\n    uint256 exactRWAOut\n) external returns (uint256 stablecoinInAmount) {\n    // Calculate protocol fee based on effective amount\n    uint256 protocolFee = _calculateMultiliquidFee(maxStablecoinIn - protocolFee);\n    uint256 effectiveAmount = maxStablecoinIn - protocolFee;\n    \n    // Calculate redemption fee on EFFECTIVE amount only\n    uint256 effectiveInUSD = effectiveAmount.mulWad(getStablecoinUSDValue(stablecoinID));\n    uint256 redemptionFee = effectiveInUSD.mulWad(redemptionFeeRate);\n    \n    // This is the CORRECT pattern\n}\n\n// swapIntoStablecoin - CORRECT\nfunction swapIntoStablecoin(\n    uint256 rwaInID,\n    uint256 rwaInAmount,\n    uint256 stablecoinOutID,\n    address stablecoinOut\n) external returns (uint256 stablecoinOutAmount) {\n    // Convert RWA to USD\n    uint256 rwaInUSD = rwaInAmount.mulWad(getRWAPrice(rwaInID));\n    \n    // Calculate protocol fee from conversion amount\n    uint256 protocolFee = _calculateMultiliquidFee(rwaInUSD);\n    \n    // Redemption fee based on AFTER fee amount\n    uint256 afterProtocolFee = rwaInUSD - protocolFee;\n    uint256 redemptionFee = afterProtocolFee.mulWad(redemptionFeeRate);\n}"
      },
      {
        "name": "Fee Flow Diagram",
        "path": "reference/fee_flow.md",
        "relevance": "Shows correct vs incorrect fee charging sequence",
        "content": "CORRECT FLOW (swapIntoStablecoin):\n1. User inputs: 100 stablecoin\n2. Protocol fee (1%) charged: 100 * 1% = 1\n3. Effective amount: 100 - 1 = 99\n4. Redemption fee (2%) charged on effective: 99 * 2% = 1.98\n5. Final output: 99 - 1.98 = 97.02\n\nINCORRECT FLOW (swapIntoRWA current):\n1. User inputs: 100 stablecoin\n2. Protocol fee (1%) charged: 100 * 1% = 1\n3. Effective amount: 100 - 1 = 99\n4. Redemption fee (2%) charged on ORIGINAL: 100 * 2% = 2 ← WRONG\n5. Final output: 99 - 2 = 97\n   But user thinks they should get: 100 - 1 - 2 = 97 anyway (actually overpaying)\n\nThe issue: if redemption fee rate varies, overpayment becomes obvious\n\nExample with 5% redemption:\nCORRECT: 99 * 5% = 4.95 fee on 99 effective\nINCORRECT: 100 * 5% = 5.00 fee but only 99 being converted\n           User charged 5 but only 99 is subject to fee"
      }
    ],
    "call_flow": [
      "1. User calls swapIntoRWA with 100 USDC",
      "2. Protocol fee calculated: 100 USDC * 1% = 1 USDC",
      "3. Effective amount determined: 100 - 1 = 99 USDC",
      "4. BUG: Redemption fee calculated on original amount",
      "5. Redemption fee: 100 USDC * 2% = 2 USDC",
      "6. But only 99 USDC is being converted to RWA",
      "7. RWA conversion done with 99 USDC",
      "8. User charged 2 USDC redemption fee",
      "9. User effectively charged 3 USDC in fees (1 + 2)",
      "10. Correct should be: 99 * 2% = 1.98 USDC",
      "11. User overpaid 0.02 USDC",
      "12. Error multiplies across many transactions"
    ],
    "context_hint": "This is a consistency issue where swapIntoRWA violates the pattern used everywhere else in the codebase. Functions like swapIntoStablecoin, swapIntoRWAExactOut, and swapRWAToRWA all correctly calculate redemption fees on the effective amount (after protocol fee deduction). swapIntoRWA alone calculates on the original amount, causing overcharging.",
    "expert_notes": "This is a straightforward fee calculation bug where the function deviates from the established pattern. Since other similar functions handle this correctly, the fix is clear: calculate redemption fee on (stablecoinAmount - protocolFee) instead of stablecoinAmount. The error has low impact per transaction (user loses whatever the difference in fee rates times the amount), but compounds across all swapIntoRWA calls. Uniform Labs fixed this in PR #5d00b22.",
    "fix_description": "Calculate redemption fee on the effective stablecoin amount (after protocol fee deduction) rather than the original input amount.",
    "fix_code": "function swapIntoRWA(\n    uint256 stablecoinID,\n    address stablecoin,\n    uint256 stablecoinAmount,\n    uint256 rwaOutID,\n    uint256 minRWAOut\n) external returns (uint256 rwaOutAmount) {\n    // Charge protocol fee\n    uint256 protocolFee = _calculateMultiliquidFee(stablecoinAmount);\n    uint256 effectiveAmount = stablecoinAmount - protocolFee;\n    \n    // FIXED: Calculate redemption fee on EFFECTIVE amount\n    uint256 effectiveAmountInUSD = effectiveAmount.mulWad(\n        getStablecoinUSDValue(stablecoinID)\n    );\n    uint256 redemptionFee = effectiveAmountInUSD.mulWad(redemptionFeeRate);\n    \n    // Convert effective amount to RWA\n    rwaOutAmount = convertStablecoinToRWA(\n        stablecoin,\n        effectiveAmount,\n        rwaOutID\n    );\n    \n    require(rwaOutAmount >= minRWAOut, \"InsufficientRWAOut\");\n    \n    emit SwapIntoRWA(\n        stablecoinID,\n        stablecoinAmount,\n        rwaOutID,\n        rwaOutAmount,\n        protocolFee,\n        redemptionFee\n    );\n}"
  },
  {
    "id": "gs_cantina_multiliquid_003",
    "report_url": "https://cantina.xyz/portfolio/92ee7667-c017-46fa-8882-416862c1365b",
    "project_name": "Multiliquid V2",
    "github_url": "https://github.com/uniformlabs/Multiliquid",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-11-11",
    "vulnerability_type": "fee_calculation",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Protocol Fee Calculation Is Incorrect for Exact Out RWA to RWA Swaps",
    "description": "In the exactOut case for RWA to RWA swaps, the protocol fee calculation produces inconsistent results. The current forward calculation of fee yields a different value than the reverse calculation, causing the protocol fee to be miscalculated and economic parameters (like higher redemption fees) to have unpredictable effects on the required input amount.",
    "primary_file": {
      "name": "MultiLiquidSwap.sol",
      "path": "src/MultiLiquidSwap.sol",
      "lines": "140-170",
      "content": "function _calculateRWAToRWA(\n    bool exactOut,\n    uint256 rwaInID,\n    uint256 rwaInAmount,\n    uint256 rwaOutID,\n    uint256 rwaOutAmount\n) internal view returns (RWAToRWAReturnParams memory outputs) {\n    uint256 rwaInPrice = getRWAPrice(rwaInID);\n    uint256 rwaOutPrice = getRWAPrice(rwaOutID);\n    \n    uint256 rwaInUSDWad = rwaInAmount.mulWad(rwaInPrice);\n    uint256 rwaOutUSDWad = rwaOutAmount.mulWad(rwaOutPrice);\n    \n    if (exactOut) {\n        // Forward calculation of protocol fee\n        uint256 protocolFeeWad = rwaInUSDWad.mulWadUp(\n            _calculateMultiliquidFee(rwaInUSDWad)\n        );\n        \n        // Reverse calculation (what should match forward)\n        uint256 totalRwaInUSDWad = rwaInUSDWad.divWadUp(\n            WAD - _calculateMultiliquidFee(rwaInUSDWad)\n        );\n        uint256 protocolFeeWadReversed = totalRwaInUSDWad - rwaInUSDWad;\n        \n        // BUG: protocolFeeWad != protocolFeeWadReversed\n        // This causes inconsistency in fee calculations\n        outputs.protocolFeeWad = protocolFeeWad; // Wrong value used\n    }\n}"
    },
    "context_files": [
      {
        "name": "Fee Calculation Logic",
        "path": "reference/fee_logic.md",
        "relevance": "Explains forward vs reverse fee calculation",
        "content": "Protocol Fee Model:\n- Fee rate depends on volume (fee tiers)\n- For exactOut: need to reverse-calculate total input from output\n\nFORWARD calculation (WRONG for exactOut):\n- Assumes we know the net input\n- Fee = netInput * feeRate\n- Used for exactIn (works fine)\n\nREVERSE calculation (CORRECT for exactOut):\n- We know the output, need to find total input required\n- output = totalInput * (1 - feeRate)\n- totalInput = output / (1 - feeRate)\n- Fee = totalInput - output\n\nThe issue: When feeRate is based on totalInput (volume-based tiers),\nreverse calculation is mathematically different from forward.\n\nEXAMPLE:\nIf we want output = 100 USD\nAnd fee rate = 1% (but only if input > 5000)\n\nFORWARD: Can't use directly, fee rate depends on amount we're trying to find\nREVERSE: totalInput = 100 / (1 - 0.01) = 101.01\n         Fee = 1.01\n         But 101.01 might trigger different fee tier!\n\nThe current code uses FORWARD calculation in exactOut,\nwhich is mathematically wrong for reverse-calculating total input."
      },
      {
        "name": "Test Case Evidence",
        "path": "reference/test_mismatch.sol",
        "relevance": "Shows the mismatch between forward and reverse calculations",
        "content": "// Test case from audit demonstrates the issue:\n\n// Current behavior:\nprotocolFeeWad = 265144819575263251\nrwaInUSDWad = 53028963915052650186\nusdAfterProtocolFeeWad = totalRwaInUSDWad - protocolFeeWadReversed\n                       = 53027638190954773869\n\n// With fix:\nprotocolFeeWad = 266477205603279650  (matches reverse)\nrwaInUSDWad = 53028963915052650186\nusdAfterProtocolFeeWad = 53028963915052650186 (consistent)\n\n// The test shows redemption fees change behavior:\ntest_swapRWAToRWA_exactOut_with_higher_redemptionFees(\n    BEFORE: 46343861844048634640\n    AFTER: 46342703247502533424  (slightly less input required)\n)\n\n// This indicates the protocol fee calculation affects down-stream\n// calculations in unpredictable ways"
      }
    ],
    "call_flow": [
      "1. User requests exactOut RWA swap: want 100 RWA-B output",
      "2. System needs to reverse-calculate required RWA-A input",
      "3. Get output value: 100 * priceB = 100 USD",
      "4. Look up fee tier for this volume (depends on input, unknown yet)",
      "5. BUG: Use FORWARD fee calculation:",
      "6.   - Assume input = 100",
      "7.   - Calculate fee = 100 * 1% = 1",
      "8.   - Total = 101",
      "9. But correct is REVERSE calculation:",
      "10.  - Total = 100 / (1 - 1%) = 101.01",
      "11.  - Fee = 1.01",
      "12. Difference compounds when fee tiers change based on volume",
      "13. Higher redemption fees should increase input required",
      "14. But due to fee mismatch, effect is unpredictable"
    ],
    "context_hint": "This is a subtle mathematical issue in reverse-calculating fees. When a fee rate depends on the total volume (fee tiers), and you need to calculate total input from desired output, you cannot simply use forward fee calculation. The forward approach assumes you know the base amount, but in reverse calculation, the fee tier itself depends on the unknown total input. This creates a circular dependency that the current code doesn't resolve correctly.",
    "expert_notes": "The vulnerability requires understanding fee tier mechanics: fee rates vary based on volume, creating a function fee(volume). For exactOut, we need: totalInput = output / (1 - fee(totalInput)). This is implicit and requires solving iteratively or using the reverse formula. The current code uses forward calculation which is mathematically inconsistent with the reverse case. The fix uses proper reverse calculation: totalInput = output / (1 - feeRate), then derives fee as the difference. Uniform Labs fixed this in PR #802ba0f.",
    "fix_description": "Use reverse fee calculation for exactOut case instead of forward calculation, ensuring totalInput is properly computed from desired output.",
    "fix_code": "function _calculateRWAToRWA(\n    bool exactOut,\n    uint256 rwaInID,\n    uint256 rwaInAmount,\n    uint256 rwaOutID,\n    uint256 rwaOutAmount\n) internal view returns (RWAToRWAReturnParams memory outputs) {\n    uint256 rwaInPrice = getRWAPrice(rwaInID);\n    uint256 rwaOutPrice = getRWAPrice(rwaOutID);\n    \n    uint256 rwaOutUSDWad = rwaOutAmount.mulWad(rwaOutPrice);\n    \n    if (exactOut) {\n        // FIXED: Use reverse fee calculation\n        // Step 1: Start with desired output value\n        uint256 outputValueUSD = rwaOutUSDWad;\n        \n        // Step 2: Get the fee rate (initially assume base rate)\n        uint256 feeRate = _calculateMultiliquidFee(outputValueUSD);\n        \n        // Step 3: Reverse calculate total input needed\n        // totalInput = output / (1 - feeRate)\n        uint256 totalRwaInUSDWad = outputValueUSD.divWadUp(\n            WAD - feeRate\n        );\n        \n        // Step 4: Calculate actual protocol fee\n        uint256 protocolFeeWad = totalRwaInUSDWad - outputValueUSD;\n        \n        // Step 5: Verify fee tier hasn't changed with new total\n        uint256 verifiedFeeRate = _calculateMultiliquidFee(totalRwaInUSDWad);\n        if (verifiedFeeRate != feeRate) {\n            // Fee tier changed, recalculate with new rate\n            totalRwaInUSDWad = outputValueUSD.divWadUp(\n                WAD - verifiedFeeRate\n            );\n            protocolFeeWad = totalRwaInUSDWad - outputValueUSD;\n        }\n        \n        uint256 rwaInAmount = totalRwaInUSDWad.divWad(rwaInPrice);\n        outputs.rwaInAmount = rwaInAmount;\n        outputs.protocolFeeWad = protocolFeeWad;\n    } else {\n        // exactIn case (unchanged)\n        uint256 rwaInUSDWad = rwaInAmount.mulWad(rwaInPrice);\n        uint256 protocolFeeWad = rwaInUSDWad.mulWadUp(\n            _calculateMultiliquidFee(rwaInUSDWad)\n        );\n        outputs.protocolFeeWad = protocolFeeWad;\n    }\n}"
  }
]