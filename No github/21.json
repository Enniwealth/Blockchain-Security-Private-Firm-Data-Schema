//Marked
[
  {
    "id": "gs_cantina_tadle_v3_001",
    "report_url": "https://cantina.xyz/portfolio/ce7893fe-e354-476f-8384-d1d24a5c3eaa",
    "project_name": "Tadle v3 Sandbox",
    "github_url": "https://github.com/tadle-com/v3-sandbox-audit_1",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-13",
    "vulnerability_type": "access_control",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "denial_of_service",
    "is_vulnerable": true,
    "title": "Validator Spoofing Allows Arbitrary Address Cooldown Enforcement, Blocking Claims Indefinitely",
    "description": "The claim function inside TadleConnectors treats the validator address supplied by the caller exactly as it treats msg.sender: it verifies a 24‑hour cooldown and then records the current timestamp for both parties through _updateClaimTimestamps. Because there is no authentication or consent check on the validator, an attacker can pick any arbitrary address as the validator and force the cooldown onto that address",
    "primary_file": {
      "name": "TadleConnectors.sol",
      "path": "src/TadleConnectors.sol",
      "lines": "120-145",
      "content": "function claim(\n    address token,\n    address validator,\n    uint256 level\n) external nonReentrant onlySandboxAccount {\n    // BUG: validator parameter is completely uncontrolled\n    // No signature verification, no consent check, no authentication\n    // Any caller can pass ANY address as validator\n    \n    _verifyClaimEligibility(msg.sender, token);\n    _verifyClaimEligibility(validator, token);\n    \n    // VULNERABLE: Both msg.sender AND validator get cooldown enforced\n    _updateClaimTimestamps(msg.sender, validator, token);\n    \n    // Tokens transferred to msg.sender\n    _transferTokens(token, msg.sender, level);\n}\n\nfunction _updateClaimTimestamps(\n    address user,\n    address validator,\n    address token\n) internal {\n    // BUG: validator is updated even though:\n    // 1. validator never consented\n    // 2. validator never called claim\n    // 3. validator didn't authorize this transaction\n    \n    // Updates cooldown for msg.sender (legitimate)\n    lastClaimTimes[user][token] = block.timestamp;\n    \n    // Updates cooldown for validator (SPOOFED)\n    // This is the attacker's weapon\n    lastClaimTimes[validator][token] = block.timestamp;\n}\n\nfunction _verifyClaimEligibility(address user, address token) internal view {\n    // Checks 24-hour cooldown\n    uint256 lastClaim = lastClaimTimes[user][token];\n    if (lastClaim > 0) {\n        uint256 daysSince = (block.timestamp - lastClaim) / 1 days;\n        require(daysSince >= 1, \"TadleConnectors: daily check-in limit reached\");\n    }\n}\n\n// ATTACK SCENARIO:\n// 1. Alice is a legitimate sandbox user\n// 2. Alice earns rewards and is eligible to claim\n// 3. Bob creates a sandbox account (easy, only needs manager signature once)\n// 4. Bob calls: claim(token, alice, level)\n//    - msg.sender = Bob (has valid claim)\n//    - validator = alice (targeted victim)\n// 5. Execution flow:\n//    a. _verifyClaimEligibility(bob, token) ✓ passes\n//    b. _verifyClaimEligibility(alice, token) ✓ passes (first time)\n//    c. _updateClaimTimestamps(bob, alice, token)\n//       - lastClaimTimes[bob][token] = now (legitimate)\n//       - lastClaimTimes[alice][token] = now (SPOOFED!)\n//    d. Bob receives tokens\n// 6. Now Alice cannot claim even though she earned rewards\n// 7. Alice's lastClaimTimes[alice][token] is set to now\n// 8. Alice tries to claim: fails \"daily check-in limit reached\"\n// 9. Bob repeats step 4 every 24 hours + 1 second\n// 10. Alice is permanently blocked from claiming"
    },
    "context_files": [
      {
        "name": "TadleSandBoxFactory - Easy Account Creation",
        "path": "src/TadleSandBoxFactory.sol",
        "relevance": "Shows that any address can create a sandbox account, enabling attackers to get valid claims",
        "content": "contract TadleSandBoxFactory {\n    function build(address owner, bytes calldata managerSignature) external {\n        // Creates a new sandbox account\n        // Only requires:\n        // 1. An owner address\n        // 2. A manager signature (obtained once)\n        // \n        // This means:\n        // - Attacker can create unlimited sandbox accounts\n        // - Each has access to claim() function\n        // - Each can be used to target different victims\n        \n        require(_isValidManagerSignature(owner, managerSignature), \"Invalid signature\");\n        \n        address newSandbox = _deployClone(accountProxy);\n        _registerSandbox(newSandbox, owner);\n    }\n}\n\n// Attack execution:\n// 1. Attacker gets one manager signature for themselves\n// 2. Creates N sandbox accounts via build()\n// 3. Each sandbox has valid claim eligibility\n// 4. Uses each to target different victims with different tokens\n// 5. Cost: One-time manager signature (low bar)\n// 6. Result: Can grief unlimited victims simultaneously"
      },
      {
        "name": "Cooldown Enforcement Logic",
        "path": "src/TadleConnectors.sol",
        "relevance": "Shows how lastClaimTimes prevents claiming and how it's bypassed",
        "content": "// Cooldown check:\nrequire(\n    (block.timestamp - lastClaimTimes[user][token]) >= 1 days,\n    \"TadleConnectors: daily check-in limit reached\"\n);\n\n// Once lastClaimTimes[victim][token] = X, victim cannot claim until X + 1 day\n// Attacker can maintain this by calling claim(token, victim) repeatedly\n// Each call resets victim's lastClaimTimes[victim][token] = now\n// This creates a permanent block that slides forward\n\n// Timeline:\n// Day 0: Bob calls claim(token, alice) → lastClaimTimes[alice][token] = Day 0\n// Day 0.5: Alice tries to claim → Only 0.5 days passed → REVERT\n// Day 1: Alice tries to claim → Exactly 1 day passed → Should succeed\n// Day 1 + 1 sec: Bob calls claim(token, alice) again → lastClaimTimes[alice][token] = Day 1 + 1 sec\n// Day 2: Alice tries to claim → Only 0.999... days passed → REVERT\n// \n// Pattern: Alice can NEVER claim because Bob always resets the timer"
      },
      {
        "name": "Attack Scenario - Permanent Claim Block",
        "path": "reference/tadle_validator_spoofing.md",
        "relevance": "Documents the full attack chain and impact",
        "content": "SCENARIO: Attacker Permanently Blocks Victim's Claims\n\nSetup:\n- Tadle protocol with sandbox accounts and token airdrop\n- Alice is a legitimate sandbox user with earned rewards\n- Token allocation: 1000 tokens per day\n- Cooldown: 24 hours between claims\n\nAttack Steps:\n\n1. Attacker (Bob) creates a sandbox account\n   - Gets manager signature once\n   - Calls TadleSandBoxFactory.build(bob, signature)\n   - Now Bob's account is eligible to claim\n\n2. Day 0, 12:00 UTC: Bob launches attack\n   - Calls: tadle.claim(USDC, alice, level)\n   - Parameters:\n     * token = USDC (Alice's reward token)\n     * validator = alice (victim's address)\n     * level = some valid level\n   - Requirements check:\n     * Bob is valid sandbox account ✓\n     * Bob's claim eligible ✓\n     * Alice's claim eligible ✓ (first time)\n   - Execution:\n     * lastClaimTimes[bob][USDC] = Day 0, 12:00\n     * lastClaimTimes[alice][USDC] = Day 0, 12:00 ← SPOOFED\n     * Bob receives USDC tokens\n\n3. Day 1, 12:00 UTC: Alice tries to claim\n   - Calls: tadle.claim(USDC, <validator>, level)\n   - Check: (Day 1, 12:00 - Day 0, 12:00) >= 1 day? YES\n   - Should succeed ✓\n   - But Bob is faster...\n\n4. Day 1, 11:59:59 UTC: Bob calls again\n   - Calls: tadle.claim(USDC, alice, level)\n   - Alice's cooldown reset: lastClaimTimes[alice][USDC] = Day 1, 11:59:59\n\n5. Day 1, 12:00:01 UTC: Alice tries to claim\n   - Check: (Day 1, 12:00:01 - Day 1, 11:59:59) >= 1 day? NO (only 2 seconds)\n   - REVERT: \"daily check-in limit reached\"\n   - Alice blocked\n\n6. Pattern repeats\n   - Every ~24 hours, Bob resets Alice's cooldown\n   - Alice's window to claim slides but never actually opens\n   - Alice can never successfully claim\n\nCost Analysis:\n- Bob's cost per attack: ~1-2 wei of gas per claim call\n- Can target multiple victims: 10, 100, 1000 victims simultaneously\n- Can use multiple sandbox accounts for parallel attacks\n- One-time setup cost: Manager signature (already obtained)\n\nImpact:\n- Alice receives 0 rewards even though she earned 1000 per day\n- Over 30 days: 30,000 tokens permanently stolen/lost\n- Non-recoverable: Even if Bob stops attacking, Alice lost all past rewards\n- Onboarding flow broken: New users targeted immediately after signup\n- Campaign analytics corrupted: Malicious actors spam events without claims\n\nVictim Experience:\n- \"I've been trying to claim for days but keep getting 'daily limit' error\"\n- Doesn't realize they're being griefed\n- Assumes protocol is buggy\n- Loses trust and exits\n\nAttacker Incentive:\n- Steals victim's rewards: high profit\n- Denies competitor claims: competitive griefing\n- Damages protocol reputation: coordinated attacks\n- Cost-effective: Minimal gas, replicable across victims"
      }
    ],
    "call_flow": [
      "1. Attacker Bob creates sandbox account via TadleSandBoxFactory.build()",
      "2. Bob's account becomes eligible to claim rewards",
      "3. Bob calls tadle.claim(token, victimAddress, level)",
      "4. msg.sender = Bob, validator = victim (spoofed)",
      "5. _verifyClaimEligibility(bob, token) executes - passes",
      "6. _verifyClaimEligibility(victim, token) executes - passes (first time)",
      "7. _updateClaimTimestamps(bob, victim, token) called",
      "8. lastClaimTimes[bob][token] = block.timestamp (legitimate)",
      "9. lastClaimTimes[victim][token] = block.timestamp (SPOOFED)",
      "10. Tokens transferred to Bob",
      "11. Victim now in 24-hour cooldown despite not calling claim",
      "12. Victim attempts claim - _verifyClaimEligibility(victim) checks lastClaimTimes[victim]",
      "13. Only seconds/minutes passed since spoofed update - REVERT",
      "14. Bob repeats attack just before victim's cooldown expires",
      "15. Victim's claim window perpetually blocked by sliding cooldown"
    ],
    "context_hint": "This is a classic example of unauthenticated parameter usage. The claim function treats the validator parameter as if the caller has authority to update that address's state. In reality, anyone can pass any address. The fix requires verifying that the validator is either (1) the caller themselves, (2) has authorized the caller with a signature, or (3) is approved in advance in an on-chain registry.",
    "expert_notes": "Cantina identified this as a high-risk griefing vector because: (1) unlimited sandbox creation enables attack scaling, (2) no signature requirement means no recovery, (3) repeated calls maintain perpetual block, and (4) victims have no insight they're being targeted. The fix combines access control (signature/approval) with cooldown redesign. Tadle implemented the fix in PR #11daedd by requiring validator signatures.",
    "fix_description": "Require that the validator either be the caller themselves or provide a cryptographic signature binding themselves to the claim operation. Alternatively, maintain an on-chain approved validator mapping and only allow approved validators. This ensures only consenting addresses have their cooldown updated.",
    "fix_code": "function claim(\n    address token,\n    address validator,\n    uint256 level,\n    bytes calldata validatorSignature  // NEW: require validator signature\n) external nonReentrant onlySandboxAccount {\n    // FIXED: Validate that validator consents to this operation\n    // Either validator is msg.sender\n    if (validator != msg.sender) {\n        // Or validator has signed this transaction\n        bytes32 messageHash = keccak256(abi.encodePacked(\n            msg.sender,\n            token,\n            level,\n            block.chainid,\n            address(this)\n        ));\n        bytes32 ethSignedMessageHash = messageHash.toEthSignedMessageHash();\n        address recoveredValidator = ethSignedMessageHash.recover(validatorSignature);\n        \n        require(\n            recoveredValidator == validator,\n            \"TadleConnectors: invalid validator signature\"\n        );\n    }\n    \n    _verifyClaimEligibility(msg.sender, token);\n    _verifyClaimEligibility(validator, token);\n    \n    // Now safe to update validator's cooldown\n    // validator has explicitly consented\n    _updateClaimTimestamps(msg.sender, validator, token);\n    \n    _transferTokens(token, msg.sender, level);\n}\n\n// With this fix:\n// - Bob can still call claim(token, bob, level) without signature\n// - Bob CANNOT call claim(token, alice, level) without alice's signature\n// - Alice can create delegations by signing messages\n// - Signature binds: delegator + token + recipient\n// - Impossible to spoof because validator must sign"
  },
  {
    "id": "gs_cantina_tadle_v3_002",
    "report_url": "https://cantina.xyz/portfolio/ce7893fe-e354-476f-8384-d1d24a5c3eaa",
    "project_name": "Tadle v3 Sandbox",
    "github_url": "https://github.com/tadle-com/v3-sandbox-audit_1",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-13",
    "vulnerability_type": "fund_loss",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "state_management",
    "is_vulnerable": true,
    "title": "ETH Withdrawal Permanently Blocked After First Airdrop Claim Due to Balance Check Logic",
    "description": "The ETH withdrawal protection compares the smart account's current balance against the sum of claimed ETH and the withdrawal amount. However, airdrop implementations that track exact ETH transferred for each claim cause this check to permanently fail after the first claim. Immediately after claiming, the account balance equals the total claimed amount, making any positive withdrawal attempt impossible. The account becomes permanently unable to withdraw or transfer ETH even though the funds exist, locking the balance indefinitely.",
    "primary_file": {
      "name": "AccountManagerResolver.sol",
      "path": "src/resolvers/AccountManagerResolver.sol",
      "lines": "200-225",
      "content": "function withdraw(address token, uint256 amt) external {\n    // ETH-specific balance guard\n    if (token == ethAddr && airdropAddress != address(0)) {\n        // BUG: Flawed logic for ETH withdrawal protection\n        \n        uint256 claimedAmount = IAirdrop(airdropAddress).getUserClaimedAmount(\n            address(this),\n            ethAddr\n        );\n        \n        // This check attempts to prevent overspending\n        // but has a critical flaw with airdrop accounting\n        require(\n            address(this).balance >= claimedAmount + amt,\n            \"AccountManagerResolver: insufficient balance after airdrop claims\"\n        );\n    }\n    \n    // Transfer tokens\n    _transferETH(token, msg.sender, amt);\n}\n\n// VULNERABILITY SCENARIO:\n// Assume airdrop sends exact amounts and tracks them\n// Example: Account allocated 1 ETH\n//\n// Day 1:\n//   - Account balance: 0 ETH\n//   - claimedAmount: 0 ETH\n//   - Want to withdraw: 0.5 ETH\n//   - Check: 0 >= (0 + 0.5)? NO → User can't withdraw (fine, no balance)\n//\n// Claim happens (receives 1 ETH from airdrop):\n//   - Account balance: 1 ETH\n//   - claimedAmount: 1 ETH (airdrop tracks exact transfer)\n//   - Now: 1 >= (1 + X)? Only if X = 0\n//\n// Day 2:\n//   - Account balance: 1 ETH (funds sitting there)\n//   - claimedAmount: 1 ETH\n//   - Want to withdraw: 0.001 ETH\n//   - Check: 1 >= (1 + 0.001)? NO → PERMANENTLY BLOCKED\n//   - Want to withdraw: 0.5 ETH\n//   - Check: 1 >= (1 + 0.5)? NO → PERMANENTLY BLOCKED\n//   - Want to withdraw: 1 ETH (all funds)\n//   - Check: 1 >= (1 + 1)? NO → PERMANENTLY BLOCKED\n//\n// Account is permanently locked\n// The math: balance >= claimed + amount\n//           1 >= 1 + amount\n//           amount <= 0\n// Only withdrawal of 0 passes, which is useless\n//\n// PROBLEM: The guard assumes balance > claimed\n// But airdrop distributed the EXACT claimed amount\n// So balance == claimed, and no positive withdrawal works"
    },
    "context_files": [
      {
        "name": "Airdrop Accounting Pattern",
        "path": "src/interfaces/IAirdrop.sol",
        "relevance": "Shows how airdrop tracks claimed amounts exactly",
        "content": "interface IAirdrop {\n    function claim(address recipient, address token, uint256 amount) external;\n    \n    function getUserClaimedAmount(\n        address user,\n        address token\n    ) external view returns (uint256);\n}\n\n// Typical airdrop implementation:\ncontract Airdrop {\n    mapping(address user => mapping(address token => uint256)) userClaimed;\n    \n    function claim(\n        address user,\n        address token,\n        uint256 amount,\n        bytes32[] proof\n    ) external {\n        require(verifyProof(user, token, amount, proof), \"Invalid proof\");\n        \n        // Exact tracking: whatever is transferred is what's tracked\n        token.transfer(user, amount);\n        \n        userClaimed[user][token] += amount;  // Exact amount\n    }\n}\n\n// When called by the smart account:\n// Account calls: airdrop.claim(account, ETH, 1e18)\n// Airdrop transfers: 1e18 to account\n// Airdrop tracks: userClaimed[account][ETH] = 1e18\n// \n// In withdrawal guard:\n// claimedAmount = airdrop.getUserClaimedAmount(account, ETH)\n//               = 1e18 (exact tracking)\n// balance = account.balance = 1e18 (exact transfer)\n// \n// Check: 1e18 >= (1e18 + withdrawAmount)?\n// Only passes if withdrawAmount == 0"
      },
      {
        "name": "Fund Lock Scenario",
        "path": "reference/tadle_eth_lock.md",
        "relevance": "Documents the fund lock scenario and impact",
        "content": "SCENARIO: ETH Locked in Account After First Claim\n\nSetup:\n- Alice has a Tadle sandbox account\n- Account allocated 1 ETH from airdrop\n- Alice wants to claim and use the ETH\n\nStep 1: Claim Airdrop (Day 1)\n- Alice calls: account.claim(airdrop, ETH, 1e18, proof)\n- Airdrop validates proof and transfers 1e18 to account\n- State after:\n  * account.balance = 1 ETH\n  * airdrop.getUserClaimedAmount(account, ETH) = 1 ETH\n\nStep 2: Attempt Withdrawal (Day 2)\n- Alice wants to send 0.5 ETH to exchange\n- Alice calls: account.withdraw(ETH, 0.5e18)\n- Check executes:\n  * claimedAmount = 1e18\n  * balance = 1e18\n  * balance >= (claimedAmount + withdrawAmount)?\n  * 1e18 >= (1e18 + 0.5e18)?\n  * 1e18 >= 1.5e18? NO\n  * REVERT: \"insufficient balance after airdrop claims\"\n\nStep 3: Full Withdrawal Attempt\n- Alice tries to withdraw all: 1 ETH\n- Check: 1e18 >= (1e18 + 1e18)? NO\n- REVERT again\n\nStep 4: Zero Withdrawal\n- Alice tries to withdraw 0 ETH (testing)\n- Check: 1e18 >= (1e18 + 0)? YES\n- Succeeds but transfers 0 ETH (useless)\n\nFinal State:\n- Account holds: 1 ETH (locked)\n- Cannot withdraw: Any positive amount fails\n- Cannot transfer: Requires withdrawal\n- Cannot forward: No mechanism except withdraw\n- Funds functionally inaccessible\n\nImpact on Alice:\n- Claimed airdrop successfully\n- Cannot use the tokens\n- No error message explains the block\n- No recovery path without contract upgrade\n- Tokens permanently stuck unless admin intervention\n\nRoot Cause Analysis:\n- Guard formula: balance >= claimed + withdrawal\n- Rearranged: withdrawal <= balance - claimed\n- With exact airdrop accounting: withdrawal <= 0\n- Mathematically impossible for positive amounts\n\nAffected Flows:\n- Every account that claims from exact-tracking airdrop\n- All ETH withdrawals after first claim\n- Prevents any account usage after airdrop"
      }
    ],
    "call_flow": [
      "1. Account eligible for ETH airdrop with 1 ETH allocation",
      "2. Account calls airdrop.claim(account, ETH, 1e18, proof)",
      "3. Airdrop validates Merkle proof",
      "4. Airdrop transfers 1e18 ETH to account",
      "5. Airdrop records: userClaimed[account][ETH] = 1e18",
      "6. account.balance = 1 ETH, claimedAmount = 1 ETH",
      "7. User calls account.withdraw(ETH, 0.5e18)",
      "8. AccountManagerResolver.withdraw() executes",
      "9. Token is ETH and airdropAddress is set → special check",
      "10. Retrieves claimedAmount from airdrop: 1e18",
      "11. Checks: address(this).balance >= claimedAmount + amt",
      "12. Checks: 1e18 >= (1e18 + 0.5e18)",
      "13. Checks: 1e18 >= 1.5e18 → FALSE",
      "14. REVERT with message",
      "15. User cannot withdraw despite funds existing",
      "16. Retry with any positive amount → same failure",
      "17. Only zero withdrawal would pass (useless)"
    ],
    "context_hint": "This is a classic balance accounting bug where the guard assumes residual balance (balance > claimed), but the actual transfer results in exact balance (balance == claimed). The fix requires changing the guard logic to not use cumulative claimed as a constraint, but instead to check the current balance itself or track unspent amounts.",
    "expert_notes": "The vulnerability exploits a mismatch between the intended and actual behavior of the airdrop. The guard was designed to prevent withdrawals that would exceed the claim amount, but it doesn't account for the scenario where claimed amount has already been transferred. This is a common integration bug when connecting to external airdrop systems. Cantina recommended using actual available balance rather than cumulative inflows.",
    "fix_description": "Replace the cumulative claimed amount check with a guard based on actual available balance. Either track unspent amounts separately or simply check that the current balance is sufficient for the withdrawal.",
    "fix_code": "function withdraw(address token, uint256 amt) external {\n    // FIXED: Use actual balance instead of cumulative claims\n    if (token == ethAddr && airdropAddress != address(0)) {\n        // Option 1: Check actual balance is sufficient (simplest)\n        require(\n            address(this).balance >= amt,\n            \"AccountManagerResolver: insufficient balance\"\n        );\n    }\n    \n    // Transfer tokens\n    _transferETH(token, msg.sender, amt);\n}\n\n// With this fix:\n// - Claimed: 1 ETH, Balance: 1 ETH\n// - Want to withdraw: 0.5 ETH\n// - Check: 1 ETH >= 0.5 ETH? YES ✓\n// - Withdrawal succeeds\n// - Account receives: 0.5 ETH\n// - Account balance: 0.5 ETH\n//\n// Alternative Fix (if cumulative limit needed for other reasons):\n// Track unspent instead of claimed:\n//\nmapping(address account => mapping(address token => uint256)) unspent;\n\nfunction claim(address token, uint256 amount) external {\n    IAirdrop(airdropAddress).claim(address(this), token, amount);\n    unspent[address(this)][token] += amount;\n}\n\nfunction withdraw(address token, uint256 amt) external {\n    if (token == ethAddr && airdropAddress != address(0)) {\n        require(\n            unspent[address(this)][token] >= amt,\n            \"AccountManagerResolver: cannot withdraw more than claimed\"\n        );\n        unspent[address(this)][token] -= amt;  // Track spent\n    }\n    \n    _transferETH(token, msg.sender, amt);\n}\n\n// This allows:\n// - Tracking cumulative claimed\n// - Preventing overdraw of claims\n// - While allowing actual withdrawals\n// - Because unspent is decremented as tokens leave"
  },
  {
    "id": "gs_cantina_tadle_v3_003",
    "report_url": "https://cantina.xyz/portfolio/ce7893fe-e354-476f-8384-d1d24a5c3eaa",
    "project_name": "Tadle v3 Sandbox",
    "github_url": "https://github.com/tadle-com/v3-sandbox-audit_1",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-13",
    "vulnerability_type": "access_control",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "proxy_pattern",
    "is_vulnerable": true,
    "title": "UpgradeableProxy Allows Unprotected First-Time Initialization, Enabling Arbitrary Logic Installation",
    "description": "The UpgradeableProxy.initializeImplementation function is external and only checks that the current implementation is unset. It performs no authentication check. If the proxy is deployed with _logic == address(0), any address can call this function to set the first implementation and execute arbitrary delegatecall code. An attacker can install malicious logic in the proxy's context before legitimate initialization, gaining complete control over the proxy's storage and funds.",
    "primary_file": {
      "name": "UpgradeableProxy.sol",
      "path": "src/proxy/UpgradeableProxy.sol",
      "lines": "50-90",
      "content": "contract UpgradeableProxy {\n    bytes32 private constant IMPLEMENTATION_SLOT =\n        bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n    \n    constructor(address _owner) {\n        _setOwner(_owner);\n        // BUG: Can be deployed with _logic = address(0)\n        // Then implementation slot stays empty\n    }\n    \n    // VULNERABLE: External, unprotected initialization\n    function initializeImplementation(\n        address newImplementation,\n        bytes memory data\n    ) external {\n        // BUG: Only checks if already initialized\n        // No authentication requirement (no onlyOwner)\n        // No code existence check\n        \n        require(\n            _getImplementation() == address(0),\n            \"implementation already initialized\"\n        );\n        \n        // BUG: Any address can call this before owner\n        // Setting arbitrary implementation\n        _setImplementation(newImplementation);\n        \n        // BUG: Executes delegatecall with arbitrary data\n        // This code runs in the proxy's storage context\n        // Attacker can pass any contract as newImplementation\n        // and any calldata in data\n        \n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n    \n    function upgradeTo(address newImplementation) external onlyOwner {\n        // Owner-protected, but initialization is not\n        _setImplementation(newImplementation);\n    }\n    \n    // ATTACK VECTOR:\n    // 1. Tadle deploys UpgradeableProxy with:\n    //    - owner = tadle.eth (trusted address)\n    //    - _logic = address(0) (initialization deferred)\n    //\n    // 2. Before Tadle calls initializeImplementation(),\n    //    Attacker sees the empty proxy in mempool\n    //\n    // 3. Attacker deploys MaliciousImplementation:\n    //    ```\n    //    contract MaliciousImplementation {\n    //        function initialize()\n    //            external\n    //        {\n    //            // Storage slot 0: owner\n    //            // Overwrite owner to attacker's address\n    //            assembly {\n    //                sstore(0, attacker)\n    //            }\n    //            \n    //            // Transfer all funds to attacker\n    //            if (address(this).balance > 0) {\n    //                attacker.transfer(address(this).balance);\n    //            }\n    //        }\n    //    }\n    //    ```\n    //\n    // 4. Attacker front-runs Tadle's initialization:\n    //    proxy.initializeImplementation(\n    //        maliciousImplementation,\n    //        abi.encodeWithSelector(\n    //            MaliciousImplementation.initialize.selector\n    //        )\n    //    )\n    //\n    // 5. Execution:\n    //    a. Check passes: _getImplementation() == address(0)? YES\n    //    b. Sets implementation to maliciousImplementation\n    //    c. Executes delegatecall to initialize()\n    //    d. initialize() runs in proxy's storage context\n    //    e. Overwrites owner slot\n    //    f. Transfers funds\n    //    g. Proxy is now fully controlled by attacker\n    //\n    // 6. When Tadle tries to call upgradeTo(),\n    //    they get \"caller is not owner\" revert\n    //    because storage has been corrupted\n    //\n    // IMPACT:\n    // - Complete loss of proxy control\n    // - Funds stolen\n    // - Legitimate implementation never installed\n    // - Impossible to recover without redeploying"
    },
    "context_files": [
      {
        "name": "Unprotected Initialization Pattern",
        "path": "reference/tadle_proxy_weakness.md",
        "relevance": "Shows the attack pattern and its execution",
        "content": "VULNERABILITY: Unguarded Delegatecall in Proxy Initialization\n\nRoot Cause:\n- initializeImplementation() is external (callable by anyone)\n- Only guards: implementation not already set\n- Missing: onlyOwner modifier\n- Missing: code existence check\n- Missing: factory-enforced initialization\n\nAttack Prerequisites:\n- Proxy deployed with _logic = address(0)\n- Proxy has received funds (not necessary, but increases attack value)\n- Attacker controls account with ETH for gas\n\nAttack Execution (Front-Running):\n\n1. Proxy state:\n   - owner = tadle.eth\n   - implementation = address(0)\n   - balance = 100 ETH (collected from deposits)\n   - code storage: empty\n\n2. Tadle calls:\n   tx = proxy.initializeImplementation(realImpl, initData)\n   - Not yet confirmed\n   - In mempool, visible to attackers\n\n3. Attacker deploys malicious contract:\n   contract Evil {\n       fallback() external payable {\n           assembly {\n               // Overwrite owner (usually slot 0)\n               sstore(0, 0x1234567890...)\n           }\n       }\n   }\n\n4. Attacker front-runs:\n   tx2 = proxy.initializeImplementation(\n       address(Evil),\n       abi.encodeWithSignature(\"hack()\")\n   )\n   - Higher gas price\n   - Included before Tadle's tx\n\n5. Execution order:\n   - tx2 executes first\n   - Implementation set to Evil\n   - delegatecall to Evil.hack()\n   - Evil code runs in proxy context\n   - Owner overwritten\n   - Proxy now controlled by attacker\n   - Tadle's tx2 fails: \"implementation already initialized\"\n\nVariant: Direct Takeover\n\nMalicious code in delegation:\nfunction initialize() {\n    // Transfer all ETH to attacker\n    payable(0xattacker).transfer(address(this).balance);\n    \n    // Overwrite owner\n    assembly {\n        sstore(0, 0xattacker)\n    }\n    \n    // Set allowed selector\n    // Now attacker can call any function through proxy\n}\n\nAttacker gains:\n- Proxy ownership\n- All stored ETH\n- Ability to call malicious functions\n- Complete storage corruption\n\nTadle loses:\n- Proxy control\n- Ability to upgrade\n- Stored funds\n- Protocol functionality"
      },
      {
        "name": "Safe Proxy Pattern Comparison",
        "path": "reference/safe_initialization.md",
        "relevance": "Shows how other protocols handle this safely",
        "content": "SAFE PATTERN 1: Constructor-Based Initialization\n\nSafest approach: no separate init function\n\ncontract SafeProxy {\n    address private implementation;\n    address private owner;\n    \n    constructor(\n        address _implementation,\n        address _owner,\n        bytes calldata _data\n    ) {\n        // Set both atomically\n        require(_implementation != address(0));\n        implementation = _implementation;\n        owner = _owner;\n        \n        // Initialize in same tx\n        if (_data.length > 0) {\n            Address.functionDelegateCall(_implementation, _data);\n        }\n    }\n}\n\nBenefits:\n- No race condition\n- Atomic setup\n- No uninitialized window\n- No external init function\n\nSAFE PATTERN 2: Protected Initializer\n\ncontract ProtectedProxy {\n    address private implementation;\n    address private owner;\n    bool private initialized;\n    \n    constructor(address _owner) {\n        owner = _owner;  // Set owner FIRST\n        initialized = false;\n    }\n    \n    // Protected by onlyOwner\n    function initializeImplementation(\n        address _implementation,\n        bytes calldata _data\n    ) external onlyOwner {\n        require(!initialized, \"Already initialized\");\n        require(_implementation != address(0), \"Invalid implementation\");\n        \n        // Check code exists\n        require(_implementation.code.length > 0, \"Not a contract\");\n        \n        implementation = _implementation;\n        initialized = true;\n        \n        if (_data.length > 0) {\n            Address.functionDelegateCall(_implementation, _data);\n        }\n    }\n    \n    function upgradeTo(address _implementation) external onlyOwner {\n        require(_implementation.code.length > 0, \"Not a contract\");\n        implementation = _implementation;\n    }\n}\n\nBenefits:\n- Owner-protected\n- Code check prevents EOAs\n- Prevents replay\n\nSAFE PATTERN 3: Transparent Proxy (OpenZeppelin)\n\ncontract TransparentProxy {\n    // Standard transparent proxy implementation\n    // - Admin-only functions use special modifier\n    // - Prevents admin from accessing user functions\n    // - Clear separation\n}\n\nBenefits:\n- Industry standard\n- Well-audited\n- Clear semantics"
      }
    ],
    "call_flow": [
      "1. Tadle team decides to deploy upgradeable proxy",
      "2. Deploys UpgradeableProxy(owner=tadle.eth)",
      "3. Constructor sets owner but leaves implementation = address(0)",
      "4. Proxy added to deposits/liquidity (has value now)",
      "5. Transaction to initialize proxy submitted to mempool",
      "6. Attacker monitors mempool",
      "7. Sees uninitialized proxy with value",
      "8. Deploys MaliciousImplementation contract",
      "9. Creates front-run transaction with higher gas price",
      "10. Calls proxy.initializeImplementation(malicious, malData)",
      "11. Check: _getImplementation() == address(0)? YES (not yet set)",
      "12. Sets implementation = maliciousImplementation",
      "13. Executes delegatecall to malData in malicious contract",
      "14. Malicious code runs in proxy's context (its storage)",
      "15. Overwrites owner variable to attacker address",
      "16. Transfers all funds from proxy to attacker",
      "17. Returns successfully",
      "18. Original Tadle tx arrives: check fails \"already initialized\"",
      "19. Proxy is now controlled by attacker",
      "20. All funds lost, recovery requires new proxy"
    ],
    "context_hint": "This is a race condition in initialization. The vulnerability arises because an uninitialized proxy is vulnerable to any actor before the legitimate owner initializes it. The proxy itself is valuable (people send funds to it), creating incentive for attackers to intercept initialization. The fix requires either atomic setup (constructor) or owner-protected setup.",
    "expert_notes": "This is a critical vulnerability in proxy patterns. Cantina found that many projects make this mistake when deferring initialization. The key insight: uninitialized proxies with delegatecall capabilities are exploitable because anyone can install logic before the owner does. Even storage corruption attacks are possible. The fix requires either: (1) initialization in constructor with initial implementation, (2) onlyOwner guard on initializeImplementation, (3) factory enforcement that initializes immediately.",
    "fix_description": "Add onlyOwner modifier to initializeImplementation to prevent unauthorized callers from setting the first implementation. Additionally, add a code existence check to reject EOA/destroyed contract addresses. Alternatively, move initialization to constructor to make it atomic.",
    "fix_code": "// FIX OPTION 1: Protect with onlyOwner\nfunction initializeImplementation(\n    address newImplementation,\n    bytes memory data\n) external onlyOwner {  // ADDED: onlyOwner\n    require(\n        _getImplementation() == address(0),\n        \"implementation already initialized\"\n    );\n    \n    // ADDED: Check code exists\n    require(\n        newImplementation.code.length > 0,\n        \"UpgradeableProxy: not a contract\"\n    );\n    \n    _setImplementation(newImplementation);\n    \n    if (data.length > 0) {\n        Address.functionDelegateCall(newImplementation, data);\n    }\n}\n\n// FIX OPTION 2: Constructor-based (safest)\ncontract UpgradeableProxy {\n    bytes32 private constant IMPLEMENTATION_SLOT =\n        bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1);\n    \n    address private owner;\n    \n    constructor(\n        address _owner,\n        address _implementation,  // ADDED\n        bytes memory _data  // ADDED\n    ) {\n        require(_owner != address(0), \"Invalid owner\");\n        require(_implementation != address(0), \"Invalid implementation\");\n        require(_implementation.code.length > 0, \"Not a contract\");\n        \n        owner = _owner;\n        _setImplementation(_implementation);\n        \n        // Initialize atomically\n        if (_data.length > 0) {\n            Address.functionDelegateCall(_implementation, _data);\n        }\n    }\n    \n    function upgradeTo(address newImplementation) external onlyOwner {\n        require(newImplementation.code.length > 0, \"Not a contract\");\n        _setImplementation(newImplementation);\n    }\n}\n\n// Benefits of Option 2:\n// - No initialization window\n// - Atomic setup\n// - No external init function possible\n// - Race condition impossible\n// - All deployment details in constructor"
  },
  {
    "id": "gs_cantina_tadle_v3_004",
    "report_url": "https://cantina.xyz/portfolio/ce7893fe-e354-476f-8384-d1d24a5c3eaa",
    "project_name": "Tadle v3 Sandbox",
    "github_url": "https://github.com/tadle-com/v3-sandbox-audit_1",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-13",
    "vulnerability_type": "access_control",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "state_management",
    "is_vulnerable": true,
    "title": "Factory Rotation Breaks All New Sandbox Claims, Creating Permanent DoS for Recently Created Accounts",
    "description": "TadleConnectors caches the factory address at initialization and queries it forever via the onlySandboxAccount modifier. When governance rotates the factory (updating it in Auth), new sandboxes are registered under the fresh address but existing TadleConnectors still query the retired factory. This causes all claims from newly created sandboxes to revert with \"not a verified sandbox account\" while existing sandboxes continue working. New user onboarding is permanently blocked until connectors are redeployed.",
    "primary_file": {
      "name": "TadleConnectors.sol",
      "path": "src/TadleConnectors.sol",
      "lines": "30-70",
      "content": "contract TadleConnectors {\n    IAuth public auth;\n    address public factory;  // BUG: Cached at initialization\n    \n    function initialize(\n        address _auth,\n        address _factory\n    ) external onlyOwner initializer {\n        require(_factory != address(0), \"Invalid factory\");\n        \n        auth = IAuth(_auth);\n        factory = _factory;  // Cached forever\n    }\n    \n    modifier onlySandboxAccount() {\n        require(factory != address(0), \"Factory not initialized\");\n        \n        // BUG: Queries the cached factory address\n        // If governance rotates factory, this queries old factory\n        require(\n            ITadleSandBoxFactory(factory).isSandboxAccount(msg.sender),\n            \"TadleConnectors: caller is not a verified sandbox account\"\n        );\n        _;\n    }\n    \n    function claim(\n        address token,\n        address validator,\n        uint256 level\n    ) external nonReentrant onlySandboxAccount {  // Uses cached factory\n        // ...\n    }\n    \n    // VULNERABILITY SCENARIO:\n    // Timeline:\n    //\n    // Block 1,000,000: Deployment\n    // - Auth.factory = OldFactory\n    // - TadleConnectors.factory = OldFactory (cached)\n    // - Sandbox A created on OldFactory\n    // - Sandbox A.claim() works ✓\n    //\n    // Block 2,000,000: Governance decision\n    // - Deploy NewFactory\n    // - Auth.setFactory(NewFactory)\n    // - Auth.factory = NewFactory\n    // - TadleConnectors.factory = OldFactory (still cached!) ← BUG\n    //\n    // Block 2,000,001: New user onboarding\n    // - Create Sandbox B on NewFactory\n    // - Sandbox B registered on NewFactory\n    // - NewFactory.isSandboxAccount(B) = true\n    // - But TadleConnectors still has OldFactory cached\n    //\n    // Block 2,000,002: User B tries to claim\n    // - Call: TadleConnectors.claim(token, validator, level)\n    // - Modifier: onlySandboxAccount checks\n    // - Queries: OldFactory.isSandboxAccount(B)\n    // - OldFactory.isSandboxAccount(B) = false (B never created on old)\n    // - REVERT: \"not a verified sandbox account\"\n    //\n    // Result:\n    // - Sandbox A (created on old) still works\n    // - Sandbox B (created on new) permanently broken\n    // - All new sandboxes cannot claim\n    // - Onboarding halted until TadleConnectors redeployed\n}"
    },
    "context_files": [
      {
        "name": "Auth Factory Rotation",
        "path": "src/Auth.sol",
        "relevance": "Shows how governance rotates the factory",
        "content": "contract Auth {\n    address public factory;\n    \n    function setFactory(address _factory) external onlyAdmin {\n        require(_factory != address(0), \"Invalid factory\");\n        \n        address oldFactory = factory;\n        factory = _factory;  // Updates immediately\n        \n        emit FactoryUpdated(oldFactory, _factory);\n    }\n}\n\n// When setFactory is called:\n// - Auth.factory = newFactory (instantly updated)\n// - All contracts should start using newFactory\n// - But TadleConnectors.factory = oldFactory (immutable cache)\n// - This is the disconnect"
      },
      {
        "name": "DoS Impact Timeline",
        "path": "reference/tadle_factory_rotation.md",
        "relevance": "Documents the impact and progression of the bug",
        "content": "SCENARIO: New User Onboarding Permanently Blocked\n\nSetup Phase:\n- OldFactory deployed 6 months ago\n- 10,000 sandbox accounts created on OldFactory\n- TadleConnectors v1 deployed with OldFactory cached\n- All 10,000 users claiming daily without issues\n\nDay 365: Governance upgrade\n- Security audit recommends NewFactory with improved checks\n- Deploys NewFactory with enhanced functionality\n- Calls Auth.setFactory(NewFactory)\n- Auth.factory = NewFactory (updated)\n- Event: FactoryUpdated(OldFactory, NewFactory)\n\nDay 365 + 1 hour: First new user attempts signup\n- User calls: TadleSandBoxFactory(newFactory).build(...)\n- NewFactory creates Sandbox_11000\n- NewFactory.isSandboxAccount(Sandbox_11000) = true ✓\n- User receives confirmation: \"Sandbox created successfully\"\n\nDay 365 + 2 hours: New user attempts claim\n- User earns rewards and is ready to claim\n- Calls: TadleConnectors.claim(token, validator, level)\n- Modifier: onlySandboxAccount\n  - Queries: factory.isSandboxAccount(Sandbox_11000)\n  - factory = OldFactory (cached, never updated)\n  - OldFactory.isSandboxAccount(Sandbox_11000)?\n    Sandbox_11000 never created on OldFactory\n    → false\n  - REVERT: \"not a verified sandbox account\"\n- User receives error, confused\n- Thinks account is broken\n- Cannot claim earned rewards\n\nDay 365 + 1 week: Issue escalates\n- All new users (11000-12000) cannot claim\n- Old users (1-10000) still work\n- Tadle support flooded with complaints\n- Community discussions: \"New factory broken?\"\n- Users threatened to migrate to competitors\n\nDay 365 + 30 days: Root cause identified\n- Tadle developers realize TadleConnectors cached factory\n- Factory rotation broke all new signups\n- Cannot fix without redeploying TadleConnectors\n- Redeployment requires:\n  * Contract upgrade vote\n  * Time delay (governance timelock)\n  * Risk of breaking existing claims during migration\n\nDay 365 + 40 days: Emergency governance\n- Vote to redeploy TadleConnectors\n- New version: reads factory from Auth instead of caching\n- All 1000 new users still cannot claim (stuck for 40 days)\n- 40,000 tokens lost per user (1000 tokens/day × 40 days)\n- Total loss: 40,000,000 tokens\n\nDay 365 + 50 days: Redeployment complete\n- New TadleConnectors queries Auth.factory dynamically\n- New users can finally claim\n- Old rewards unrecoverable\n- User trust damaged\n\nImpact Summary:\n- 1000 new users blocked from claiming\n- 40 days of downtime\n- ~40M tokens lost\n- Governance overhead\n- Reputational damage\n- Competitive disadvantage"
      }
    ],
    "call_flow": [
      "1. Auth.setFactory(NewFactory) called by governance",
      "2. Auth.factory = NewFactory (updated immediately)",
      "3. FactoryUpdated event emitted",
      "4. NewFactory begins registering new sandboxes",
      "5. New sandbox created: Sandbox_11000",
      "6. NewFactory.isSandboxAccount(Sandbox_11000) = true",
      "7. User calls TadleConnectors.claim(token, validator, level)",
      "8. onlySandboxAccount modifier executes",
      "9. Checks: factory != address(0) ✓ (OldFactory cached)",
      "10. Calls: OldFactory.isSandboxAccount(Sandbox_11000)",
      "11. OldFactory has no record of Sandbox_11000 (never created there)",
      "12. OldFactory.isSandboxAccount returns false",
      "13. Require statement fails",
      "14. REVERT: \"caller is not a verified sandbox account\"",
      "15. User unable to claim despite being on NewFactory",
      "16. All subsequent new sandboxes have same issue",
      "17. Onboarding permanently blocked until TadleConnectors redeployed"
    ],
    "context_hint": "This is a state synchronization problem. TadleConnectors cached a critical address (factory) at initialization time, assuming it would never change. When governance rotates that address, downstream components have stale references. The fix requires either reading the current value from Auth (dynamic) or having Auth notify TadleConnectors to update (pull vs push).",
    "expert_notes": "This vulnerability is subtle because it doesn't affect existing functionality—it only affects new users. The old factory remains valid for old sandboxes, so no one notices until new users fail. This is a common pattern in governance updates: dependent contracts fail to sync with authoritative updates. Cantina recommended either: (1) have connectors read factory from Auth dynamically, or (2) have setFactory on Auth also call setFactory on all connectors. Tadle implemented solution (1).",
    "fix_description": "Modify TadleConnectors to read the current factory address from Auth on each claim instead of caching it. This ensures connectors always use the current factory address, even after governance rotations.",
    "fix_code": "contract TadleConnectors {\n    IAuth public auth;\n    // REMOVED: address public factory; (no longer cached)\n    \n    function initialize(\n        address _auth,\n        address _factory  // Still needed for validation\n    ) external onlyOwner initializer {\n        require(_auth != address(0), \"Invalid auth\");\n        require(_factory != address(0), \"Invalid factory\");\n        \n        auth = IAuth(_auth);\n        // REMOVED: factory = _factory; (don't cache)\n    }\n    \n    modifier onlySandboxAccount() {\n        // FIXED: Read factory dynamically from Auth\n        address currentFactory = auth.factory();\n        require(\n            currentFactory != address(0),\n            \"TadleConnectors: factory not set\"\n        );\n        require(\n            ITadleSandBoxFactory(currentFactory).isSandboxAccount(msg.sender),\n            \"TadleConnectors: caller is not a verified sandbox account\"\n        );\n        _;\n    }\n    \n    function claim(\n        address token,\n        address validator,\n        uint256 level\n    ) external nonReentrant onlySandboxAccount {\n        // Now uses current factory via modifier\n        // Survives factory rotations\n    }\n}\n\n// With this fix:\n// - Day 365: Auth.setFactory(NewFactory)\n// - Day 365 + 2h: User calls claim\n// - onlySandboxAccount reads: auth.factory() = NewFactory (current)\n// - Queries: NewFactory.isSandboxAccount(Sandbox_11000) = true\n// - Claim proceeds successfully\n// - All new users work immediately\n// - No redeployment needed\n// - No downtime"
  }
]