{
  "id": "gs_quantstamp_afi_afi001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "AFI Vault",
  "source_finding_id": "AFI-1",
  "report_url": "https://certificate.quantstamp.com/full/afi-vault/",
  "github_repo_url": "https://github.com/AFI-Protocol/afi-contracts",
  "contest_date": "2025-11-12",
  "severity": "high",
  "vulnerability_type": "economic_attack",
  "difficulty_tier": 4,
  "context_level": "cross_contract",
  "finding_title": "Oracle Updates Vulnerable to Sandwich Attacks",
  "finding_description": "The AFI Vault's deposit() and withdraw() functions are vulnerable to sandwich attacks via oracle rate updates. The vault uses stepwise oracle updates that process rate changes within the same block. An attacker can frontrun an oracle update, deposit at the old rate, capture the benefit of the new rate update, and withdraw at the updated rate within the same transaction or block.",
  "attack_scenario": "1. Oracle reports updated rate: 1 USDT = 1.01 USDe (10,000 USDT collateral value increases from 10,000 to 10,100 USDe)\n2. Attacker detects oracle update in mempool\n3. Attacker frontruns with deposit(1000 USDT): receives shares at old rate 1:1, gets 1000 shares\n4. Oracle update executes: rate changes to 1.01, vault net value increases by 100 USDe\n5. Attacker immediately withdraw(1000 shares): receives USDT at new rate 1.01, gets 1010 USDT\n6. Attacker profit: 10 USDT per 1% rate update, repeatable 6 times daily = 60 USDT/day\n7. With 10k USDT capital, economics: 10,000 * 1% * 6 updates/day = 600 USDT profit/day ($600/day or 2.19M annually if capital scales)",
  "fix_description": "Implement deposit cooldown-based protection to prevent same-block/same-transaction extraction. Two approaches: (1) Add 1-day minimum deposit-to-withdrawal lockup: deposits become withdrawable only after 1 day, preventing same-block or next-block sandwich attacks. (2) Add oracle rate change delay: require deposits to snapshot the rate at deposit time, and only allow withdrawal after rate stabilizes (no change > X% in last Y blocks). (3) Add slippage protection: users specify minimum acceptable conversion rate, transaction reverts if actual rate differs. Recommended: Implement approach 1 (simplest) combined with approach 3 (user control).",
  "primary_file": {
    "path": "src/afiVault.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./Oracle.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract AFIVault {\n    IERC20 public USDT;\n    IERC20 public USDe;\n    Oracle public oracle;\n    \n    mapping(address => uint256) public balances;\n    uint256 public totalShares;\n    uint256 public totalAssets;\n    \n    event Deposit(address indexed user, uint256 assets, uint256 shares);\n    event Withdraw(address indexed user, uint256 assets, uint256 shares);\n    \n    function deposit(uint256 assets) public returns (uint256 shares) {\n        require(assets > 0, \"Zero assets\");\n        \n        // VULNERABLE: Uses current oracle rate without protection against same-block manipulation\n        uint256 rate = oracle.getRate();\n        shares = (assets * 1e18) / rate;\n        \n        balances[msg.sender] += assets;\n        totalShares += shares;\n        totalAssets += assets;\n        \n        USDT.transferFrom(msg.sender, address(this), assets);\n        emit Deposit(msg.sender, assets, shares);\n        return shares;\n    }\n    \n    function withdraw(uint256 shares) public returns (uint256 assets) {\n        require(shares > 0, \"Zero shares\");\n        require(balances[msg.sender] >= shares, \"Insufficient balance\");\n        \n        // VULNERABLE: Can withdraw in same block/transaction as deposit if oracle rate changed\n        uint256 rate = oracle.getRate();\n        assets = (shares * rate) / 1e18;\n        \n        balances[msg.sender] -= shares;\n        totalShares -= shares;\n        totalAssets -= assets;\n        \n        USDT.transfer(msg.sender, assets);\n        emit Withdraw(msg.sender, assets, shares);\n        return assets;\n    }\n    \n    function getSharePrice() public view returns (uint256) {\n        if (totalShares == 0) return 1e18;\n        return (totalAssets * 1e18) / totalShares;\n    }\n}\n",
    "vulnerable_lines": [29, 30, 41, 42],
    "vulnerable_functions": ["deposit", "withdraw"]
  },
  "context_files": [
    {
      "path": "src/Oracle.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract Oracle {\n    uint256 public rate = 1e18;  // 1 USDT = 1 USDe\n    \n    function updateRate(uint256 newRate) public {\n        // VULNERABLE: Rate update can occur in same block/mempool as deposit\n        require(newRate > 0, \"Zero rate\");\n        rate = newRate;  // No rate change limits, no delays\n    }\n    \n    function getRate() public view returns (uint256) {\n        return rate;\n    }\n}\n",
      "relevance": "Oracle contract allows stepwise rate updates without delays, enabling sandwich attacks when rate changes are detected in mempool"
    }
  ],
  "call_flow": "Attacker detects oracle.updateRate() in mempool → Attacker calls deposit(1000 USDT) at rate 1e18 → Oracle.updateRate(1.01e18) executes → Attacker calls withdraw(shares) at rate 1.01e18 → Attacker profits 10 USDT",
  "context_hint": "The vulnerability is timing-based rather than logic-based. The vault correctly calculates share prices at deposit and withdrawal, but the attacker profits from the rate change that occurs between operations. This is enabled by the oracle allowing instant rate updates without delays. The attack requires either mempool visibility (flashbots) or collusion with the oracle provider.",
  "is_vulnerable": true,
  "expert_notes": "This is a sophisticated MEV attack that exploits the oracle's lack of delay mechanisms. While each individual operation is mathematically correct, the combination of deposit → rate update → withdraw within a single block violates the intended invariant that rate changes should affect new deposits prospectively, not retroactively. The fix requires adding temporal constraints (lockup periods or rate-change delays) that prevent profitable extraction."
}

{
  "id": "gs_quantstamp_afi_afi002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "AFI Vault",
  "source_finding_id": "AFI-2",
  "report_url": "https://certificate.quantstamp.com/full/afi-vault/",
  "github_repo_url": "https://github.com/AFI-Protocol/afi-contracts",
  "contest_date": "2025-11-12",
  "severity": "medium",
  "vulnerability_type": "rounding_error",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "Flawed Decimal Conversion Logic in _convertToShares()",
  "finding_description": "The _convertToShares() function does not account for decimal mismatches between the vault asset (possibly 6 decimals like USDC) and the share token (18 decimals like standard ERC20). This causes incorrect share calculations for non-18-decimal assets: 100 USDC (100e6 wei) incorrectly yields 100e6 shares instead of 100e18 shares, breaking vault economics for assets with different decimal places.",
  "attack_scenario": "1. AFI Vault is created to handle USDC (6 decimals)\n2. User deposits 100 USDC = 100e6 wei\n3. _convertToShares(100e6) is called\n4. Function executes: shares = (assets * 1e18) / assetDecimals (incorrectly uses 1e18 instead of decimal scaling)\n5. shares = (100e6 * 1e18) / 1e18 = 100e6 shares (should be 100e18 shares)\n6. User receives 100e6 shares instead of 100e18\n7. User's balance is understated by factor of 1e12\n8. When user tries to withdraw: they can only withdraw 100 USDC (100e6 wei) instead of full amount\n9. Or if redemption uses wrong math: gets 100e6 wei instead of 100 USDC value\n10. Multi-asset vault breaks: USDC operations differ from 18-decimal assets by 1e12x",
  "fix_description": "Modify _convertToShares() to account for asset decimal places. Correct implementation: (1) Query asset decimals: uint8 decimals = IERC20Metadata(asset).decimals(); (2) Calculate decimal offset: uint8 offset = 18 - decimals; (3) Scale input: uint256 scaledAssets = assets * (10 ** offset); (4) Then convert: shares = (scaledAssets * 1e18) / pricePerShare. Alternatively, use OpenZeppelin's _convertToShares pattern which handles decimals correctly. Test with multiple decimal assets (USDC=6, DAI=18, USDT=6) to verify.",
  "primary_file": {
    "path": "src/afiVault.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ncontract AFIVault {\n    IERC20 public asset;\n    uint8 public assetDecimals;\n    \n    constructor(IERC20 _asset) {\n        asset = _asset;\n        assetDecimals = IERC20Metadata(_asset).decimals();\n    }\n    \n    function deposit(uint256 assets) public returns (uint256 shares) {\n        shares = _convertToShares(assets);\n        // ... transfer logic\n        return shares;\n    }\n    \n    // VULNERABLE: Does not scale assets by decimal difference\n    function _convertToShares(uint256 assets) internal view returns (uint256) {\n        // Incorrect: Assumes assets are always 18 decimals\n        // If USDC (6 decimals): 100 USDC = 100e6 wei\n        // Calculation: (100e6 * 1e18) / 1e18 = 100e6 shares (should be 100e18)\n        \n        uint256 totalAssets = getTotalAssets();\n        uint256 supply = totalSupply();\n        \n        if (supply == 0) {\n            return assets;  // VULNERABLE: Doesn't normalize decimals\n        }\n        \n        return (assets * supply) / totalAssets;\n    }\n    \n    // CORRECT VERSION (for reference):\n    function _convertToSharesFixed(uint256 assets) internal view returns (uint256) {\n        uint8 offset = 18 - assetDecimals;\n        uint256 scaledAssets = assets * (10 ** offset);\n        \n        uint256 totalAssets = getTotalAssets();\n        uint256 supply = totalSupply();\n        \n        if (supply == 0) {\n            return scaledAssets;\n        }\n        \n        return (scaledAssets * supply) / totalAssets;\n    }\n    \n    function getTotalAssets() public view returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n    \n    function totalSupply() public view returns (uint256) {\n        return 0;  // Placeholder\n    }\n}\n",
    "vulnerable_lines": [28, 29, 30, 31, 32, 33, 34, 35, 36],
    "vulnerable_functions": ["_convertToShares"]
  },
  "context_files": [],
  "call_flow": "User deposits 100 USDC (6 decimals = 100e6 wei) → _convertToShares(100e6) → missing decimal scaling → returns 100e6 shares instead of 100e18 → user's share balance understated by 1e12",
  "context_hint": "ERC4626 vaults must handle variable decimal assets. The standard way is to normalize all internal calculations to 18 decimals (extended decimals), converting from asset decimals at entry and back at exit. This vault skips the normalization step, causing shares to be calculated in the wrong scale. This breaks vault fairness: early users with 18-decimal assets get inflated shares, while later users with 6-decimal assets get deflated shares.",
  "is_vulnerable": true,
  "expert_notes": "This is a common pitfall when adapting ERC4626 vault patterns to support multiple assets. The vulnerability stems from conflating asset amounts (which vary in decimal places) with vault share amounts (which should always be 18 decimals). Proper fix requires understanding ERC4626's decimal handling pattern: (1) normalize deposits to 18 decimals, (2) perform all calculations in 18-decimal space, (3) convert back to asset decimals for withdrawals. Many protocols have fallen into this trap, including some high-value exploits."
}
