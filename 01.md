# Startale Stablecoin Vaults - Quantstamp Audit Findings

## High Severity Findings

### STA-1: Leveraged TVL Manipulation via Sandwich Attack on distribute()

```json
{
  "id": "gs_quantstamp_startale_STA001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "quantstamp",
  "source_report": "2025-11-startale-stablecoin-vaults",
  "source_finding_id": "STA-1",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  
  "severity": "high",
  "vulnerability_type": "economic_attack",
  "difficulty_tier": 4,
  "context_level": "cross_contract",
  
  "finding_title": "Leveraged TVL Manipulation via Sandwich Attack on distribute()",
  "finding_description": "The RewardRedistributor's distribute() function reads the sUSDSC vault's totalAssets() at execution time to calculate yield splits. An attacker can build a leveraged position in the sUSDSC vault using a lending pool (e.g., Aave-style), sandwich the distribute() transaction, and capture disproportionate yield while stealing from EarnVault users. The attack uses borrowed USDSC as collateral in recursive loops to artificially inflate sUSDSC's TVL, manipulating the yield distribution formula.",
  "attack_scenario": "1. Attacker detects operator's distribute() transaction in mempool\n2. Attacker frontruns with leverage loop (5 iterations): Deposit 1M USDSC → get 1M sUSDSC → borrow 900k USDSC. Deposit 900k → get 900k sUSDSC → borrow 810k. Continue until 4.095M total deposited using 3.685M borrowed + 1M original capital\n3. This inflates sUSDSC vault from 10M to 14.095M USDSC\n4. Operator's distribute() executes with manipulated TVL: Normal split would be toEarn=316,667 USDSC, toOn=633,333 USDSC. Manipulated split: toEarn=248,752 USDSC (lost 67,915), toOn=701,248 USDSC (gained 67,915). Attacker's 4.095M shares (29% of vault) capture 203,693 USDSC of inflated yield\n5. Attacker backruns: Redeem 4.095M shares for 4,298,693 USDSC, repay 3.685M loan (interest ~1.4 USDSC for 2 minutes), net profit 203,191 USDSC per attack\n6. Attack repeatable 6 times daily = 1.2M USDSC profit/day = 445M USDSC profit/year (44,493% APY)",
  "fix_description": "Implement snapshot-based TVL mechanism to prevent same-block manipulation. In RewardRedistributor.sol:\n1. Add storage: uint256 public lastSUSDSCTVL; uint256 public lastSnapshotBlock;\n2. Add function snapshotTVL() external onlyRole(OPERATOR_ROLE) { lastSUSDSCTVL = susdscVault.totalAssets(); lastSnapshotBlock = block.number; }\n3. In distribute() require(lastSnapshotBlock == block.number - 1, 'Must snapshot in previous block') and use lastSUSDSCTVL instead of susdscVault.totalAssets()\n4. Operator workflow: Call snapshotTVL() in block N, then call distribute() in block N+1. This forces attacker to hold leveraged position for minimum 1 full block (~12 seconds), making attack 100x more expensive\n5. For defense-in-depth, add 1-hour withdrawal cooldown to sUSDSC vault and minimum time post-deposit during which funds cannot be withdrawn",
  
  "primary_file": {
    "path": "src/distributor/RewardRedistributor.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ninterface IMYieldToOne is IERC20 {\n    function claimYield() external returns (uint256);\n    function yieldRecipient() external view returns (address);\n}\n\ninterface IEarnVault {\n    function onYield(uint256 amount) external;\n}\n\ninterface IERC4626 {\n    function totalAssets() external view returns (uint256);\n    function onYield(uint256 amount) external;\n}\n\ncontract RewardRedistributor is AccessControl, ReentrancyGuard, Pausable {\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n    \n    address private USDSC_ADDRESS;\n    address private treasury;\n    IEarnVault private earnVault;\n    IERC4626 private susdscVault;\n    \n    uint256 private constant RAY = 1e27;\n    uint256 private constant MAX_FEE_BPS = 10000;\n    uint256 private feeBps = 500; // 5% fee\n    \n    // Carry accumulator for rounding precision\n    uint256 private carryEarn;\n    uint256 private carryOn;\n    \n    event Distributed(uint256 indexed blockNumber, uint256 grossYield, uint256 toEarn, uint256 toOn, uint256 toStartale);\n    \n    constructor(\n        address usdscAddress,\n        address treasuryAddr,\n        IEarnVault earnV,\n        IERC4626 sVault,\n        address admin,\n        address keeper\n    ) {\n        require(usdscAddress != address(0), \"Zero USDSC address\");\n        require(treasuryAddr != address(0), \"Zero treasury\");\n        require(address(earnV) != address(0), \"Zero earnVault\");\n        require(address(sVault) != address(0), \"Zero sUSDSCVault\");\n        require(admin != address(0), \"Zero admin\");\n        require(keeper != address(0), \"Zero keeper\");\n        \n        USDSC_ADDRESS = usdscAddress;\n        treasury = treasuryAddr;\n        earnVault = earnV;\n        susdscVault = sVault;\n        \n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _grantRole(OPERATOR_ROLE, keeper);\n    }\n    \n    // VULNERABLE: Uses spot TVL at execution time\n    function distribute() external whenNotPaused onlyRole(OPERATOR_ROLE) nonReentrant {\n        uint256 balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this));\n        uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield();\n        uint256 gross = balanceBefore + minted;\n        \n        if (gross == 0) return;\n        \n        uint256 feeToStartale;\n        uint256 toEarn;\n        uint256 toOn;\n        uint256 toStartaleExtra;\n        uint256 sBase;\n        uint256 T_earn;\n        uint256 T_yield;\n        \n        (feeToStartale, toEarn, toOn, toStartaleExtra, sBase, T_earn, T_yield) = _calculateSplit(gross, true, false);\n        \n        // Transfer allocations\n        if (feeToStartale > 0) {\n            IERC20(USDSC_ADDRESS).transfer(treasury, feeToStartale);\n        }\n        \n        if (toEarn > 0) {\n            IERC20(USDSC_ADDRESS).approve(address(earnVault), toEarn);\n            earnVault.onYield(toEarn);\n        }\n        \n        if (toOn > 0) {\n            IERC20(USDSC_ADDRESS).transfer(address(susdscVault), toOn);\n            susdscVault.onYield(toOn);\n        }\n        \n        if (toStartaleExtra > 0) {\n            IERC20(USDSC_ADDRESS).transfer(treasury, toStartaleExtra);\n        }\n        \n        emit Distributed(block.number, gross, toEarn, toOn, feeToStartale + toStartaleExtra);\n    }\n    \n    function _calculateSplit(\n        uint256 gross,\n        bool useCarries,\n        bool preview\n    ) internal returns (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra, uint256 sBase, uint256 T_earn, uint256 T_yield) {\n        // VULNERABILITY: Includes donations in gross amount\n        feeToStartale = (gross * feeBps) / MAX_FEE_BPS;\n        uint256 net = gross - feeToStartale;\n        \n        T_earn = 2000000 * 1e18; // Example: 2M USDSC\n        T_yield = susdscVault.totalAssets(); // VULNERABLE: Spot TVL\n        \n        uint256 SNow = IERC20(USDSC_ADDRESS).totalSupply();\n        sBase = SNow > gross ? SNow - gross : 0; // VULNERABLE: Uses gross not just minted\n        \n        uint256 S_base = sBase > 0 ? sBase : SNow;\n        \n        if (useCarries) {\n            uint256 numEarn = net * T_earn + carryEarn;\n            toEarn = numEarn / S_base;\n            carryEarn = numEarn % S_base;\n            \n            uint256 numOn = net * T_yield + carryOn;\n            toOn = numOn / S_base;\n            carryOn = numOn % S_base;\n        } else {\n            toEarn = (net * T_earn) / S_base;\n            toOn = (net * T_yield) / S_base;\n        }\n        \n        toStartaleExtra = net - (toEarn + toOn);\n        \n        return (feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield);\n    }\n    \n    function setTreasury(address _treasury) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_treasury != address(0), \"Zero address\");\n        treasury = _treasury;\n    }\n    \n    function setFee(uint256 _feeBps) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_feeBps <= MAX_FEE_BPS, \"Fee too high\");\n        feeBps = _feeBps;\n    }\n}",
    "vulnerable_lines": [108, 109, 110, 113, 120, 143, 144, 145, 147, 148, 149, 155, 156, 157, 158, 159, 160, 161, 162],
    "vulnerable_functions": ["distribute", "_calculateSplit"]
  },
  
  "context_files": [
    {
      "path": "src/vaults/4626/SUSDSCVaultUpgradable.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC4626/ERC4626.sol\";\n\n// Simplified vault interface showing totalAssets() that can be manipulated\ncontract SUSDSCVaultUpgradeable is ERC4626 {\n    constructor(IERC20 asset) ERC4626(asset) ERC20(\"sUSDSC\", \"sUSDSC\") {}\n    \n    // This function returns spot TVL at transaction execution time\n    // Can be inflated by attacker through leveraged deposits\n    function totalAssets() public view override returns (uint256) {\n        return asset.balanceOf(address(this));\n    }\n    \n    function onYield(uint256 amount) external {\n        // Receives yield from RewardRedistributor\n    }\n}",
      "relevance": "The sUSDSC vault's totalAssets() is read at execution time in distribute(), allowing same-block manipulation. No time-delayed snapshot is used."
    }
  ],
  
  "call_flow": "Attacker.detectMempool() -> Attacker.frontRun() -> Attacker.borrowAndDeposit() -> inflate sUSDSC.totalAssets() -> Operator.distribute() -> RewardDistributor reads spot TVL -> manipulated yield split -> Attacker.backRun() -> Attacker.repayAndProfit()",
  "context_hint": "ERC4626 share accounting is fair - attacker gets correct shares at deposit and correct assets at redemption. The vulnerability exists because distribute() uses spot totalAssets() instead of a time-delayed snapshot. This is a sophisticated economic attack that requires understanding both lending pool mechanics and yield distribution formulas. The attacker can execute this profitably multiple times daily with modest capital due to Aave-style 90% LTV.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a novel attack vector combining three elements: (1) ERC4626 fair accounting that makes deposits/redemptions proportional, (2) Accessible lending pools with high LTV, (3) TVL-based distribution formula read at transaction execution time. The fix is elegant - a one-block delay between snapshot and distribution prevents the attack entirely since attacker can't profitably hold leveraged position for 12+ seconds. Similar pattern seen in Curve gauge votes and Convex voting escrow systems."
}
```

### STA-2: Boost Rewards Not Settled During Deposit Operations

```json
{
  "id": "gs_quantstamp_startale_STA002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "quantstamp",
  "source_report": "2025-11-startale-stablecoin-vaults",
  "source_finding_id": "STA-2",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  
  "severity": "high",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "Boost Rewards Not Settled During Deposit Operations",
  "finding_description": "The deposit() and depositWithPermit() functions settle USDSC yield via _settle() but do NOT settle boost rewards via _settleBoost(). This creates an accounting vulnerability where users can increase their principal without updating their boost reward indices, causing them to earn boost rewards on their new principal retroactively from their old index position. This allows users to steal boost rewards from other depositors.",
  "attack_scenario": "1. Time T0 - Initial State: Alice deposits 1000 USDSC (first deposit). principal[Alice] = 1000, userBoostIndex[Alice][TokenA] = 0 (default for new user), boostGlobalIndex[TokenA] = 0\n2. Time T1 - First Boost Distribution: Keeper distributes 1000 TokenA boost rewards to vault. boostGlobalIndex[TokenA] increases: 0 + (1000 * 1e27) / 1000 = 1e27. Alice's pending rewards: 1000 * (1e27 - 0) / 1e27 = 1000 TokenA ✓\n3. Time T2 - Alice Deposits More WITHOUT Settlement: Alice calls deposit(1000) (doubles her position). _settle() is called → USDSC yield settled ✓. _settleBoost() is NOT called → Boost indices NOT updated ✗. Alice's state: principal[Alice] = 2000 (doubled!), userBoostIndex[Alice][TokenA] = 0 (STILL 0! Not updated to 1e27). Alice's 1000 TokenA is still pending in userBoostAccrued\n4. Time T3 - Second Boost Distribution: Keeper distributes another 1000 TokenA. Total distributed: 2000 TokenA in system. boostGlobalIndex[TokenA] increases: 1e27 + (1000 * 1e27) / 2000 = 1.5e27\n5. Time T4 - Alice Tries to Claim: Alice calls claim() or withdraw(). _settleBoost() is called. Incorrect calculation: owed = 2000 * (1.5e27 - 0) / 1e27 = 3000 TokenA. Alice tries to claim 3000 TokenA when only 2000 exist! Transaction REVERTS with InsufficientBoostClaimReserve()\n6. Correct should be: Old principal (1000): T0→T1 = 1000 TokenA. Old principal (1000): T1→T3 = 500 TokenA. New principal (1000): T2→T3 = 500 TokenA. Total correct: 2000 TokenA",
  "fix_description": "Add boost reward settlement to both deposit functions. In deposit() after _settle(msg.sender), add loop: for (uint256 i = 0; i < $.activeBoostTokens.length; i++) { _settleBoost(msg.sender, $.activeBoostTokens[i]); }. Do same for depositWithPermit(). This ensures userBoostIndex is updated to current boostGlobalIndex BEFORE principal is increased, so new principal only earns boost from point of deposit forward.",
  
  "primary_file": {
    "path": "src/vaults/earn/EarnVaultUpgradeable.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"./EarnVaultStorageBase.sol\";\nimport \"./BoostRewardsLib.sol\";\n\ncontract EarnVaultUpgradeable is Initializable, ReentrancyGuardUpgradeable {\n    using BoostRewardsLib for EarnVaultStorage;\n    \n    EarnVaultStorage private $;\n    \n    modifier whenNotPaused() {\n        require(!$.paused, \"Paused\");\n        _;\n    }\n    \n    function initialize(\n        address usdsc,\n        address yieldRedist,\n        address boostKeeper,\n        address owner,\n        address pauser,\n        address treasuryAddr\n    ) public initializer {\n        $.USDSC = IERC20(usdsc);\n        $.yieldRedistributor = yieldRedist;\n        $.boostRewardKeeper = boostKeeper;\n        $.owner = owner;\n        $.pauser = pauser;\n        $.treasury = treasuryAddr;\n        $.RAY = 1e27;\n    }\n    \n    // VULNERABLE: Only settles USDSC, NOT boost rewards\n    function deposit(uint256 amount) external virtual whenNotPaused nonReentrant {\n        EarnVaultStorage storage $ = _getStorage();\n        require(amount > 0, \"Zero amount\");\n        \n        _settle(msg.sender);\n        // MISSING: Boost reward settlement!\n        \n        $.USDSC.safeTransferFrom(msg.sender, address(this), amount);\n        $.principal[msg.sender] += amount;\n        $.totalPrincipal += amount;\n        $.claimReserve += amount;\n        \n        emit Deposit(msg.sender, amount);\n    }\n    \n    // VULNERABLE: Same issue in depositWithPermit\n    function depositWithPermit(\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused nonReentrant {\n        EarnVaultStorage storage $ = _getStorage();\n        require(amount > 0, \"Zero amount\");\n        \n        try IERC20Permit(address($.USDSC)).permit(\n            msg.sender, address(this), amount, deadline, v, r, s\n        ) {} catch {\n            revert PermitFailed();\n        }\n        \n        _settle(msg.sender);\n        // MISSING: Boost reward settlement!\n        \n        $.USDSC.safeTransferFrom(msg.sender, address(this), amount);\n        $.principal[msg.sender] += amount;\n        $.totalPrincipal += amount;\n        $.claimReserve += amount;\n        \n        emit Deposit(msg.sender, amount);\n    }\n    \n    // CORRECT: withdraw() DOES settle boost rewards\n    function withdraw(uint256 amount) external virtual whenNotPaused nonReentrant {\n        EarnVaultStorage storage $ = _getStorage();\n        require(amount > 0, \"Zero amount\");\n        \n        _settle(msg.sender);\n        \n        uint256 p = $.principal[msg.sender];\n        require(amount <= p, \"Insufficient principal\");\n        \n        // Settle and claim ALL boost rewards in single loop\n        for (uint256 i = 0; i < $.activeBoostTokens.length; i++) {\n            address token = $.activeBoostTokens[i];\n            _settleBoost(msg.sender, token);\n            BoostRewardsLib.claimBoostReward(\n                msg.sender,\n                token,\n                p,\n                $.userBoostIndex[msg.sender][token],\n                $.boostGlobalIndex[token],\n                $.userBoostAccrued,\n                $.boostClaimReserve\n            );\n        }\n        \n        $.principal[msg.sender] -= amount;\n        $.totalPrincipal -= amount;\n        $.USDSC.safeTransfer(msg.sender, amount);\n        \n        emit Withdrawal(msg.sender, amount);\n    }\n    \n    function _settle(address user) internal {\n        EarnVaultStorage storage $ = _getStorage();\n        uint256 p = $.principal[user];\n        if (p == 0) return;\n        \n        uint256 gi = $.globalIndex;\n        uint256 ui = $.userIndex[user];\n        if (gi > ui) {\n            uint256 owed = p * (gi - ui) / $.RAY;\n            $.yield[user] += owed;\n            $.userIndex[user] = gi;\n        }\n    }\n    \n    function _settleBoost(address user, address token) internal {\n        EarnVaultStorage storage $ = _getStorage();\n        uint256 userIndex = $.userBoostIndex[user][token];\n        uint256 globalIndex = $.boostGlobalIndex[token];\n        \n        if (globalIndex > userIndex) {\n            uint256 principal = $.principal[user];\n            uint256 owed = principal * (globalIndex - userIndex) / $.RAY;\n            $.userBoostAccrued[user][token] += owed;\n            $.userBoostIndex[user][token] = globalIndex;\n        }\n    }\n    \n    function _getStorage() internal pure returns (EarnVaultStorage storage $) {\n        assembly {\n            $.slot := 0\n        }\n    }\n    \n    event Deposit(address indexed user, uint256 amount);\n    event Withdrawal(address indexed user, uint256 amount);\n}",
    "vulnerable_lines": [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71],
    "vulnerable_functions": ["deposit", "depositWithPermit"]
  },
  
  "context_files": [
    {
      "path": "src/vaults/earn/BoostRewardsLib.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary BoostRewardsLib {\n    uint256 constant RAY = 1e27;\n    \n    function settleBoostReward(\n        address user,\n        address token,\n        uint256 principal,\n        uint256 userIndex,\n        uint256 globalIndex\n    ) internal returns (uint256 owed) {\n        if (globalIndex <= userIndex) return 0;\n        // owed = principal * (globalIndex - userIndex) / RAY\n        owed = principal * (globalIndex - userIndex) / RAY;\n    }\n    \n    function claimBoostReward(\n        address user,\n        address token,\n        uint256 principal,\n        uint256 userIndex,\n        uint256 globalIndex,\n        mapping(address => mapping(address => uint256)) storage userBoostAccrued,\n        mapping(address => uint256) storage boostClaimReserve\n    ) internal returns (uint256 claimedAmount) {\n        uint256 owed = settleBoostReward(user, token, principal, userIndex, globalIndex);\n        claimedAmount = userBoostAccrued[user][token] + owed;\n        \n        require(boostClaimReserve[token] >= claimedAmount, \"Insufficient reserve\");\n        \n        boostClaimReserve[token] -= claimedAmount;\n        userBoostAccrued[user][token] = 0;\n        \n        IERC20(token).transfer(user, claimedAmount);\n    }\n}",
      "relevance": "The boost reward index calculation formula. When _settleBoost() is not called before increasing principal, the calculation applies old index delta to new principal amount, causing over-calculation."
    }
  ],
  
  "call_flow": "User.deposit() -> _settle() (USDSC only) -> principal += amount -> (no _settleBoost()) -> User.claim() -> _settleBoost() called -> owed = NEW_principal * (boostGlobalIndex - OLD_userIndex) / RAY -> OVER-ALLOCATION",
  "context_hint": "This is an index-based accounting bug where the invariant 'userBoostIndex must be updated whenever principal changes' is violated. The fix is straightforward - add the same _settleBoost loop that exists in withdraw() to deposit() and depositWithPermit(). This pattern (settling before state change) is critical in all index-based reward systems.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Classic index accounting pattern violation. The comparison with withdraw() (which DOES settle boost) makes this obvious - deposit is the mirror operation and must also settle. This likely happened during refactoring where USDSC yield settlement was added but boost settlement was overlooked. The severity is high because it compounds over time - each deposit without settlement increases the 'skew' until eventually the contract can't pay out claimed rewards."
}
```

## Medium Severity Findings

### STA-3: Incorrect S_base Calculation with Donations Causes Yield Misallocation

```json
{
  "id": "gs_quantstamp_startale_STA003",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "quantstamp",
  "source_report": "2025-11-startale-stablecoin-vaults",
  "source_finding_id": "STA-3",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  
  "severity": "medium",
  "vulnerability_type": "rounding_error",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "Incorrect S_base Calculation with Donations Causes Yield Misallocation",
  "finding_description": "The RewardRedistributor's distribute() function contains an accounting bug when tokens are donated to the contract. The function includes balanceBefore (donations) in the gross amount passed to _calculateSplit(), which causes S_base (supply base) to be artificially reduced. This results in vaults receiving a higher percentage of yield than intended, with the treasury receiving correspondingly less.",
  "attack_scenario": "1. User accidentally transfers 1M USDSC directly to RewardRedistributor contract (wrong address or protocol error)\n2. Operator calls distribute(): balanceBefore = 1M, minted = 50k (increases totalSupply to 6.05M), gross = 1.05M passed to _calculateSplit\n3. In _calculateSplit: feeToStartale = 105k, net = 945k, SNow = 6.05M, S_base = 6.05M - 1.05M = 5M (WRONG! Should be 6M), T_earn = 2M, T_yield = 3M\n4. Allocation calculation: toEarn = 378k (should be 315k), toOn = 567k (should be 472.5k), toStartaleExtra = 0 (should be 157.5k)\n5. Vaults receive 100% of net yield, treasury receives 0 remainder, losing ~157k USDSC per distribution",
  "fix_description": "Remove balanceBefore logic and only distribute actual minted yield. Change distribute() to: uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield(); if (minted == 0) return; (feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield) = _calculateSplit(minted, true, false);. Add separate recoverDonations() function: function recoverDonations() external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant { uint256 balance = IERC20(USDSC_ADDRESS).balanceOf(address(this)); if (balance > 0) { IERC20(USDSC_ADDRESS).safeTransfer(treasury, balance); emit DonationsRecovered(balance); } }",
  
  "primary_file": {
    "path": "src/distributor/RewardRedistributor.sol",
    "content": "pragma solidity ^0.8.19;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ninterface IMYieldToOne is IERC20 {\n    function claimYield() external returns (uint256);\n}\n\ncontract RewardRedistributor {\n    address private USDSC_ADDRESS;\n    address private treasury;\n    \n    uint256 private constant RAY = 1e27;\n    uint256 private constant MAX_FEE_BPS = 10000;\n    uint256 private feeBps = 500;\n    \n    uint256 private carryEarn;\n    uint256 private carryOn;\n    \n    // VULNERABLE: Function includes donations in gross calculation\n    function distribute() external {\n        uint256 balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this)); // Includes donations!\n        uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield(); // Only M0 yield\n        uint256 gross = balanceBefore + minted; // VULNERABLE: Total including donations\n        \n        (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra) = _calculateSplit(gross);\n        \n        // Distribute...\n    }\n    \n    function _calculateSplit(uint256 gross) internal returns (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra) {\n        // VULNERABLE: Uses gross in S_base calculation\n        feeToStartale = (gross * feeBps) / MAX_FEE_BPS;\n        uint256 net = gross - feeToStartale;\n        \n        uint256 T_earn = 2000000 * 1e18; // 2M USDSC\n        uint256 T_yield = 3000000 * 1e18; // 3M USDSC\n        \n        uint256 SNow = IERC20(USDSC_ADDRESS).totalSupply();\n        \n        // VULNERABLE: Subtracts gross (not just minted) from SNow\n        uint256 S_base = SNow > gross ? SNow - gross : 0;\n        \n        uint256 numEarn = net * T_earn + carryEarn;\n        toEarn = numEarn / S_base;\n        carryEarn = numEarn % S_base;\n        \n        uint256 numOn = net * T_yield + carryOn;\n        toOn = numOn / S_base;\n        carryOn = numOn % S_base;\n        \n        // VULNERABLE: toStartaleExtra = 0 when donations present\n        toStartaleExtra = net - (toEarn + toOn);\n        \n        return (feeToStartale, toEarn, toOn, toStartaleExtra);\n    }\n}",
    "vulnerable_lines": [24, 25, 26, 27, 37, 43, 49, 51, 52, 53, 54, 57, 58],
    "vulnerable_functions": ["distribute", "_calculateSplit"]
  },
  
  "context_files": [],
  
  "call_flow": "User.accidentalTransfer(1M USDSC) -> RewardRedistributor.distribute() -> balanceBefore = 1M -> minted = 50k -> gross = 1.05M -> S_base = (6.05M - 1.05M) = 5M (WRONG) -> yield over-allocated to vaults",
  "context_hint": "S_base represents the total supply before new minting. When donations are included in gross, S_base is artificially reduced, making the yield split formula allocate more to vaults (T_earn and T_yield) and less to treasury (toStartaleExtra). The bug only manifests when donations are received. A PoC was created but confirmed this does NOT cause arithmetic underflow - instead it causes pure accounting imbalance.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a yield distribution accounting bug in a multi-cohort system. The issue is subtle - the formula allocates based on 'what percentage of supply is each cohort', but when donations inflate S_base calculation, the denominator is wrong. The fix is clean: only distribute actual minted yield, and handle donations separately with a recovery function. Similar pattern in Curve and Yearn multi-vault systems."
}
```

### STA-4: previewDistribute() Does Not Perform an Exact Dry-Run of distribute()

```json
{
  "id": "gs_quantstamp_startale_STA004",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "quantstamp",
  "source_report": "2025-11-startale-stablecoin-vaults",
  "source_finding_id": "STA-4",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  
  "severity": "medium",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "previewDistribute() Does Not Perform an Exact Dry-Run of distribute()",
  "finding_description": "The NatSpec documentation describes previewDistribute() as 'Exact dry-run of {distribute} against current chain state (includes carries)'. However, distribute() includes both yield newly minted in the function call together with the balance of the contract prior to minting. In contrast, previewDistribute() only includes the hypothetical newly minted yield. Hence, the latter function does not in fact perform an exact dry-run of the distribute() function, leading to inaccurate estimates when the contract already contains some USDSC.",
  "attack_scenario": "1. RewardRedistributor contract has 100k USDSC already in balance (from prior distribution or donations)\n2. Operator calls previewDistribute() to estimate upcoming distribution: estimates based on new minted 50k only\n3. Operator calls distribute(): actual gross = balanceBefore(100k) + minted(50k) = 150k\n4. previewDistribute() estimated toEarn based on 50k, but distribute() allocates based on 150k\n5. Estimates are off by 3x (100k/50k), causing operator confusion and potential operational issues",
  "fix_description": "Correct the implementation by properly incorporating the extant USDSC balance in the distribution amount. Change previewDistribute() to include balanceBefore: uint256 balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this)); uint256 minted = previewYield(); (estimated result) = _calculateSplit(balanceBefore + minted, true, true);. Alternatively, add a new differently-named function (e.g., previewMintedDistribution()) that preserves current behavior for different use cases.",
  
  "primary_file": {
    "path": "src/distributor/RewardDistributor.sol",
    "content": "pragma solidity ^0.8.19;\n\ncontract RewardDistributor {\n    address private USDSC_ADDRESS;\n    \n    /**\n     * @notice Exact dry-run of {distribute} against current chain state (includes carries).\n     * @return Estimated distribution amounts\n     * VULNERABLE: Does not include balanceBefore in calculation!\n     */\n    function previewDistribute() external view returns (uint256, uint256, uint256, uint256) {\n        // VULNERABLE: Only uses minted, not balanceBefore + minted\n        uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield(); // Would be minted\n        \n        (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra) = _calculateSplit(minted, true, true);\n        \n        return (feeToStartale, toEarn, toOn, toStartaleExtra);\n    }\n    \n    // CORRECT: distribute() includes balanceBefore\n    function distribute() external {\n        uint256 balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this)); // NOT included in preview!\n        uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield();\n        uint256 gross = balanceBefore + minted; // DIFFERENT from preview\n        \n        (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra) = _calculateSplit(gross, true, false);\n        \n        // Execute distribution...\n    }\n    \n    function _calculateSplit(uint256 gross, bool useCarries, bool preview) internal pure returns (uint256, uint256, uint256, uint256) {\n        // Split logic...\n    }\n}",
    "vulnerable_lines": [9, 10, 11, 12, 13, 14, 15, 16, 17, 21, 22, 23, 24, 25],
    "vulnerable_functions": ["previewDistribute", "distribute"]
  },
  
  "context_files": [],
  
  "call_flow": "Operator.previewDistribute() -> uses only minted(50k) -> returns estimates -> Operator.distribute() -> uses balanceBefore(100k) + minted(50k) = 150k -> actual result differs from preview",
  "context_hint": "This is a specification-implementation mismatch. The NatSpec promises exact dry-run behavior, but the implementation differs. When contracts accumulate balance (common in production), the preview becomes inaccurate. This is not exploitable but reduces utility of the preview function.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Simple but important for operational transparency. The fix is just one line - include balanceBefore in previewDistribute(). The discrepancy becomes obvious only when contract holds balance, which happens regularly in production systems."
}
```

### STA-5: Unexpected Boost Token Behavior Can Lead to Denial of Service

```json
{
  "id": "gs_quantstamp_startale_STA005",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "quantstamp",
  "source_report": "2025-11-startale-stablecoin-vaults",
  "source_finding_id": "STA-5",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  
  "severity": "medium",
  "vulnerability_type": "dos",
  "difficulty_tier": 2,
  "context_level": "multi_file",
  
  "finding_title": "Unexpected Boost Token Behavior Can Lead to Denial of Service",
  "finding_description": "On calls of distributeBoostReward() and claimBoostReward(), calls are made to the transfer() functions of all token contracts contained in the activeBoostTokens array. These calls occur in EarnVault functions: withdraw(), claim(), and onBoostReward(). However, considering these tokens are contracts external to the Startale project, they may exhibit unexpected behavior. For instance, if funds are frozen, they may revert on transfer. This would cause all of the above EarnVault functions to revert. However, once a token is added to activeBoostTokens, it cannot be removed. One token having its funds frozen would result in a denial-of-service that would prevent any funds from leaving the EarnVault.",
  "attack_scenario": "1. Protocol adds USDC as boost token via onBoostReward() (assume USDC is legitimate)\n2. USDC is distributed to 1000 users via multiple onBoostReward() calls\n3. Due to regulatory action (OFAC sanctions), USDC token implements global transfer freezing\n4. Any user calling withdraw() or claim() attempts to iterate through activeBoostTokens which includes frozen USDC\n5. USDC.transfer() in iteration reverts due to frozen tokens\n6. withdraw() call reverts, trapping user's principal in contract\n7. ALL users unable to withdraw principal until protocol can upgrade to remove USDC from activeBoostTokens\n8. One external token's freeze = complete protocol DoS",
  "fix_description": "Allow removal of tokens from activeBoostTokens array and enable selective token claiming. Implement: (1) removeBoostToken(address token) external onlyOwner function that removes token from activeBoostTokens array using swap-and-pop pattern, (2) claimBoostRewardForToken(address token) external function allowing users to claim specific tokens, skipping frozen ones, (3) Optional: Add MAX_BOOST_TOKENS constant to limit array growth.",
  
  "primary_file": {
    "path": "src/vaults/earn/BoostRewardsLib.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary BoostRewardsLib {\n    uint256 constant RAY = 1e27;\n    \n    // VULNERABLE: Tokens can be added but never removed\n    function distributeBoostReward(\n        address token,\n        uint256 amount,\n        mapping(address => uint256) storage boostClaimReserve,\n        uint256 totalPrincipal,\n        address[] storage activeBoostTokens,\n        mapping(address => uint256) storage boostTokenIndex,\n        mapping(address => uint256) storage boostGlobalIndex\n    ) external {\n        uint256 bal = IERC20(token).balanceOf(address(this));\n        \n        require(bal >= boostClaimReserve[token] + amount, \"Insufficient balance\");\n        \n        boostClaimReserve[token] += amount;\n        \n        // Track active boost tokens (only add if not already tracked)\n        if (boostTokenIndex[token] == 0) {\n            activeBoostTokens.push(token);\n            boostTokenIndex[token] = activeBoostTokens.length; // 1-based index\n        }\n        \n        // Update boost global index for this token\n        uint256 num = amount * RAY;\n        uint256 delta = num / totalPrincipal;\n        boostGlobalIndex[token] += delta;\n    }\n    \n    // VULNERABLE: Loops through all tokens, one revert = all revert\n    function claimBoostReward(\n        address user,\n        address token,\n        uint256 principal,\n        uint256 userIndex,\n        uint256 globalIndex,\n        mapping(address => mapping(address => uint256)) storage userBoostAccrued,\n        mapping(address => uint256) storage boostClaimReserve\n    ) external returns (uint256) {\n        uint256 owed = principal * (globalIndex - userIndex) / RAY;\n        uint256 claimedAmount = userBoostAccrued[user][token] + owed;\n        \n        require(boostClaimReserve[token] >= claimedAmount, \"Insufficient reserve\");\n        \n        boostClaimReserve[token] -= claimedAmount;\n        userBoostAccrued[user][token] = 0;\n        \n        // VULNERABLE: If this reverts due to frozen token, entire claim/withdraw reverts\n        IERC20(token).transfer(user, claimedAmount);\n        \n        return claimedAmount;\n    }\n}\n\n// In EarnVault.sol - loops through all tokens\ncontract EarnVault {\n    function withdraw(uint256 amount) external {\n        // ... validation ...\n        \n        // VULNERABLE: One frozen token breaks entire function\n        for (uint256 i = 0; i < activeBoostTokens.length; i++) {\n            address token = activeBoostTokens[i];\n            _settleBoost(msg.sender, token);\n            // If this token is frozen, entire loop reverts\n            BoostRewardsLib.claimBoostReward(\n                msg.sender,\n                token,\n                principal,\n                userBoostIndex[msg.sender][token],\n                boostGlobalIndex[token],\n                userBoostAccrued,\n                boostClaimReserve\n            );\n        }\n        \n        // Principal withdrawal never reached if any token reverts\n        USDSC.transfer(msg.sender, amount);\n    }\n}",
    "vulnerable_lines": [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55],
    "vulnerable_functions": ["distributeBoostReward", "claimBoostReward", "withdraw"]
  },
  
  "context_files": [
    {
      "path": "src/vaults/earn/EarnVault.sol",
      "content": "// Simplified withdraw showing the loop vulnerability\ncontract EarnVault {\n    address[] public activeBoostTokens;\n    \n    function withdraw(uint256 amount) external nonReentrant {\n        require(amount <= principal[msg.sender], \"Insufficient principal\");\n        \n        _settle(msg.sender);\n        \n        // VULNERABLE: This loop can be broken by one bad token\n        for (uint256 i = 0; i < activeBoostTokens.length; i++) {\n            address token = activeBoostTokens[i];\n            _settleBoost(msg.sender, token);\n            // One frozen token here = entire withdraw reverts\n            BoostRewardsLib.claimBoostReward(msg.sender, token, ...);\n        }\n        \n        // If loop fails, principal never transfers\n        principal[msg.sender] -= amount;\n        USDSC.transfer(msg.sender, amount);\n    }\n}",
      "relevance": "Shows how withdraw() must iterate through all activeBoostTokens. One frozen token blocks all withdrawals."
    }
  ],
  
  "call_flow": "User.withdraw() -> for loop over activeBoostTokens -> claimBoostReward(USDC) where USDC is frozen -> transfer() reverts -> entire withdraw() reverts -> user trapped",
  "context_hint": "Operational resilience issue. Token freezes (USDC sanctions, bridge exploits, etc.) are real scenarios. The architecture requires all tokens in activeBoostTokens to cooperate for withdraw() to succeed. This creates a systemic risk dependency.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Classic DoS through external dependency. The fix is straightforward: (1) allow removing frozen tokens, (2) let users claim specific tokens selectively. Without these, one bad token breaks the entire protocol. We've seen similar issues in Curve (frozen USDT blocking gauges) and Compound (problematic tokens in markets)."
}
```

