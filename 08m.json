[{
  "id": "gs_quantstamp_campnft_camp001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp - NFT",
  "source_finding_id": "CAMP-1",
  "report_url": "https://certificate.quantstamp.com/full/camp-nft/94cdb738-1a01-4f6c-8632-3bdec427161e/index.html",
  "github_repo_url": "https://github.com/campaign-layer/origin-protocol",
  "contest_date": "2025-08-22",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 4,
  "context_level": "cross_contract",
  "finding_title": "Transferred NFTs May Be Missing Royalty Vault",
  "finding_description": "Token owners receive royalty payments for subscriptions and dispute settlements. These rewards are paid to vaults associated with each token owner to avoid DoS attack vectors. Vaults are created during the minting process via a factory pattern. However, when a token is transferred to a new owner, the new owner may not have a vault registered in the royaltyVaults mapping. In this case, royalty payments will be transferred to the zero address, resulting in a loss of funds. Furthermore, there is no mechanism for the new owner or contract owner to create and register a vault to recover from this state.",
  "attack_scenario": "1. Alice mints token 1 with ID=1. A RoyaltyVault is automatically created and registered for Alice in the royaltyVaults mapping\n2. Alice transfers token 1 to Bob, who has never minted any IP before\n3. Charlie buys access to token 1 from Bob\n4. The marketplace attempts to pay Bob's royalty share by calling ipToken.royaltyVaults(Bob)\n5. Since Bob has no vault entry, the function returns address(0)\n6. The royalty payment is routed to address(0) using SafeTransferLib, permanently locking the funds\n7. Bob loses all royalty revenue from the sale\n8. This repeats for every sale, creating permanent fund loss with each transaction",
  "fix_description": "Implement a getOrCreateRoyaltyVault(address tokenOwner) function that retrieves an existing vault from the mapping, or lazily creates a new one if it doesn't exist. This function should be called whenever royalty payments need to be routed. Make the royaltyVaults mapping private and expose it through the getOrCreateRoyaltyVault function. The gas cost of vault creation is paid by the user buying access, not by the new token owner. This approach ensures that every token owner always has a vault available for receiving royalties, eliminating the zero-address transfer issue.\n\nCode example:\nmapping(address => address) private _royaltyVaults;\n\nfunction getOrCreateRoyaltyVault(address tokenOwner) external returns (address vault) {\n    vault = _royaltyVaults[tokenOwner];\n    if (vault == address(0)) {\n        vault = address(new RoyaltyVault(tokenOwner));\n        _royaltyVaults[tokenOwner] = vault;\n    }\n}",
  "primary_file": {
    "path": "contracts/IpNFT.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"./RoyaltyVault.sol\";\n\ncontract IpNFT is ERC721 {\n    // VULNERABLE: Public mapping, no factory for lazy creation\n    mapping(address => address) public royaltyVaults;\n    \n    // VULNERABLE: Vault created only during minting\n    function mintWithSignature(\n        address to,\n        uint256 tokenId,\n        bytes memory uri,\n        LicenseTerms calldata licenseTerms,\n        bytes memory signature\n    ) external {\n        // Verify signature\n        _verifySignature(to, tokenId, licenseTerms, signature);\n        \n        // Mint the token\n        _mint(to, tokenId);\n        \n        // VULNERABLE: Vault only created for minter\n        if (royaltyVaults[to] == address(0)) {\n            RoyaltyVault vault = new RoyaltyVault(to);\n            royaltyVaults[to] = address(vault);\n        }\n        \n        emit TokenMinted(to, tokenId);\n    }\n    \n    // VULNERABLE: safeTransferFrom does NOT create vault for recipient\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal override {\n        // No vault creation logic here\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n    \n    // VULNERABLE: Returns address(0) if recipient has no vault\n    function getRoyaltyVault(address owner) external view returns (address) {\n        return royaltyVaults[owner];  // Returns address(0) if not set\n    }\n}\n",
    "vulnerable_lines": [8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42],
    "vulnerable_functions": ["mintWithSignature", "_beforeTokenTransfer", "getRoyaltyVault"]
  },
  "context_files": [
    {
      "path": "contracts/Marketplace.sol",
      "content": "// Marketplace uses the royaltyVaults mapping when distributing payments\n\nfunction buyAccess(\n    address buyer,\n    uint256 tokenId\n) external payable {\n    // ... validate and process purchase ...\n    \n    // Distribute royalty to token owner\n    address owner = ipToken.ownerOf(tokenId);\n    address royaltyVault = ipToken.royaltyVaults(owner);\n    \n    // VULNERABLE: If royaltyVault is address(0), payment is lost\n    if (royaltyVault == address(0)) {\n        // This sends funds to address(0), permanently locking them\n        SafeTransferLib.safeTransferETH(royaltyVault, royaltyShare);\n    }\n}\n",
      "relevance": "Shows how the missing vault check in IpNFT causes fund loss in the Marketplace contract"
    }
  ],
  "call_flow": "Alice.mintWithSignature() → vault created for Alice → Alice.transferFrom(alice, bob, tokenId) → no vault created for Bob → Charlie.buyAccess(tokenId) → marketplace queries ipToken.royaltyVaults(bob) → returns address(0) → funds sent to address(0) → permanent lock",
  "context_hint": "The vulnerability stems from a mismatch between vault creation (during minting) and token ownership changes (via transfer). The contract assumes vault existence when routing payments, but transfers don't trigger vault creation. The fix uses lazy initialization: the first time someone buys access from a token owner, the vault is created if needed. This pattern (factory with getOrCreate) is standard in ERC4626 vaults and other production DeFi contracts.",
  "is_vulnerable": true,
  "expert_notes": "This is a critical fund loss vulnerability in a multi-stage protocol. The root cause is architectural: the protocol separates token ownership from royalty routing without enforcing consistency. The fix is minimal but requires careful testing of the interaction between vault creation and existing approval/transfer logic. Note that this affects ALL token transfers, not just first transfers - if Bob receives token 1 and later transfers it to Charlie, Charlie will also lack a vault."
},

{
  "id": "gs_quantstamp_campnft_camp002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp - NFT",
  "source_finding_id": "CAMP-2",
  "report_url": "https://certificate.quantstamp.com/full/camp-nft/94cdb738-1a01-4f6c-8632-3bdec427161e/index.html",
  "github_repo_url": "https://github.com/campaign-layer/origin-protocol",
  "contest_date": "2025-08-22",
  "severity": "high",
  "vulnerability_type": "economic_attack",
  "difficulty_tier": 4,
  "context_level": "cross_contract",
  "finding_title": "Possible Frontrunning of Buy Actions by Changing Token Terms",
  "finding_description": "Token access can be purchased via the marketplace according to conditions outlined in the token's terms. Token owners can update these terms at any point using updateTerms(). The marketplace does not validate that terms remain unchanged between transaction submission and execution. Token owners can exploit this by frontrunning buyAccess() calls and changing the subscription price, duration, or payment token. Additionally, when purchasing with wrapped tokens (wCAMP), the buyAccess() function does not verify that native tokens were not sent, allowing a malicious token owner to receive both native and wrapped tokens. Token owners can also exploit token approvals by updating the price to match a buyer's full approval and steal all approved tokens instead of just the intended subscription fee.",
  "attack_scenario": "Exploit A - Payment Token Switching:\n1. Mallory mints token 1 with payments in native CAMP tokens\n2. Bob approves 10 ETH to the Marketplace contract\n3. Bob submits buyAccess(tokenId=1, value=1 ETH) expecting to pay 1 ETH for 30 days\n4. Mallory monitors mempool and frontruns with updateTerms(tokenId=1, paymentToken=wCAMP, price=10 ETH)\n5. Bob's transaction executes, paying 10 ETH in wCAMP (his approval is used) + 1 ETH in native (sent but not validated)\n6. Mallory receives 10 ETH instead of 1 ETH, Bob loses 11 ETH total\n\nExploit B - Price Manipulation via Approval Exploitation:\n1. Alice approves 1000 USDC to Marketplace (for multiple purchases)\n2. Alice submits buyAccess(tokenId=2, expectedPrice=100 USDC) to buy 30-day access\n3. Bob monitors mempool, detects Alice's transaction\n4. Bob frontruns with updateTerms(tokenId=2, price=1000 USDC)\n5. Alice's transaction executes with new price: _routeTokenPayment transfers 1000 USDC\n6. Bob receives 1000 USDC instead of 100 USDC\n\nExploit C - Duration Reduction:\n1. Carol buys 1 year (365 days) of access for 100 USDC\n2. Owner frontruns with updateTerms reducing duration to 1 second\n3. Carol's subscription immediately expires upon purchase\n4. Owner extracts same 100 USDC for minimal value delivery",
  "fix_description": "Implement two-part fix: (1) Add validation to ensure msg.value == 0 when purchasing with wCAMP tokens to prevent native token theft. (2) Require buyers to specify expected terms and validate they haven't changed. Modify buyAccess() to include expectedPrice, expectedDuration, and expectedPaymentToken parameters. Compare these against actual terms stored in ipToken.getTerms(tokenId) and revert if mismatch.\n\nCode:\nfunction buyAccess(\n    address buyer,\n    uint256 tokenId,\n    uint256 expectedPrice,\n    uint32 expectedDuration,\n    address expectedPaymentToken\n) external payable {\n    IpNFT.LicenseTerms memory terms = ipToken.getTerms(tokenId);\n    if (terms.price != expectedPrice ||\n        terms.duration != expectedDuration ||\n        terms.paymentToken != expectedPaymentToken) {\n        revert TermsMismatch();\n    }\n    if (terms.paymentToken != address(0) && msg.value != 0) {\n        revert UnexpectedNativePayment();\n    }\n}",
  "primary_file": {
    "path": "contracts/Marketplace.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"./IpNFT.sol\";\nimport \"./RoyaltyModule.sol\";\n\ncontract Marketplace {\n    IpNFT public ipToken;\n    RoyaltyModule public royaltyModule;\n    \n    // VULNERABLE: No term commitment from buyer\n    function buyAccess(\n        address buyer,\n        uint256 tokenId\n    ) external payable {\n        // Retrieve current terms\n        IpNFT.LicenseTerms memory terms = ipToken.getTerms(tokenId);\n        \n        // VULNERABLE: No check that terms match buyer's expectations\n        // Terms can be changed after transaction submission\n        \n        // VULNERABLE: No validation of msg.value for wCAMP purchases\n        // If paymentToken is wCAMP, shouldn't accept native tokens\n        if (terms.paymentToken == address(wCAMP)) {\n            // VULNERABLE: msg.value not checked, native tokens accepted\n            // If owner changed paymentToken from native to wCAMP,\n            // buyer's native tokens are locked in contract\n            _routeTokenPayment(buyer, terms.price, terms.paymentToken);\n        } else if (terms.paymentToken == address(0)) {\n            // Native token payment\n            require(msg.value >= terms.price, \"Insufficient payment\");\n        }\n        \n        // Create subscription\n        subscriptions[tokenId][buyer] = block.timestamp + terms.duration;\n        \n        // Distribute royalties\n        royaltyModule.distributeRoyalty(tokenId, terms.price);\n        \n        emit AccessBought(buyer, tokenId, terms.price);\n    }\n    \n    // VULNERABLE: Private helper, no approval limit check\n    function _routeTokenPayment(\n        address payer,\n        uint256 amount,\n        address token\n    ) private {\n        // VULNERABLE: Transfers entire approved amount if price is high\n        // Owner can frontrun and set price to full approval\n        SafeTransferLib.safeTransferFrom(\n            token,\n            payer,\n            address(this),\n            amount\n        );\n    }\n}\n",
    "vulnerable_lines": [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36],
    "vulnerable_functions": ["buyAccess", "_routeTokenPayment"]
  },
  "context_files": [
    {
      "path": "contracts/IpNFT.sol",
      "content": "// Terms can be updated at any time by token owner\n\nmapping(uint256 => LicenseTerms) public terms;\n\nfunction updateTerms(\n    uint256 tokenId,\n    LicenseTerms calldata newTerms\n) external {\n    require(msg.sender == ownerOf(tokenId), \"Not owner\");\n    // VULNERABLE: No frontrun protection, can be called in same block as buyAccess\n    terms[tokenId] = newTerms;\n}\n\nstruct LicenseTerms {\n    uint256 price;           // Can be changed to match approvals\n    uint32 duration;         // Can be changed to minimal value\n    address paymentToken;    // Can be switched to exploit native balance\n    uint16 royaltyBps;       // Royalty percentage\n}\n",
      "relevance": "Shows how updateTerms() allows arbitrary manipulation of all purchase parameters"
    }
  ],
  "call_flow": "Buyer.approveAndCall buyAccess(tokenId, expectedPrice=100) → Owner.updateTerms(tokenId, newPrice=1000) → buyAccess executes with new price → Buyer sends 1000 instead of 100 → Approval used for full amount → Owner gets full approval value",
  "context_hint": "This vulnerability chains together three separate issues: (1) lack of term commitment from buyer, (2) missing validation of native tokens for wrapped token payments, (3) exploitable token approvals. The attack surface exists because the marketplace trusts buyAccess() callers to manually ensure terms are as expected, but provides no mechanism to verify this assumption. Camp's private mempool mitigates classic frontrunning, but intentional term manipulation by the owner is still possible.",
  "is_vulnerable": true,
  "expert_notes": "This is a sophisticated economic attack that exploits the interaction between ERC20 approvals and dynamic pricing. The vulnerability has three vectors: (1) direct frontrunning (owner sees transaction in mempool and changes terms), (2) speculative manipulation (owner changes terms anticipating future transactions), (3) approval exploitation (owner learns approval amount and extracts it). The fix requires buyers to commit to expected terms, similar to slippage protection in DEX swaps. This is a critical lesson in cross-contract interactions: when contract A calls functions in contract B, contract A must validate that B's state hasn't changed unexpectedly."
},

{
  "id": "gs_quantstamp_campnft_camp003",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp - NFT",
  "source_finding_id": "CAMP-3",
  "report_url": "https://certificate.quantstamp.com/full/camp-nft/94cdb738-1a01-4f6c-8632-3bdec427161e/index.html",
  "github_repo_url": "https://github.com/campaign-layer/origin-protocol",
  "contest_date": "2025-08-22",
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "finding_title": "Token Owner Can Frontrun Evidence Hashes To Block Disputes",
  "finding_description": "The DisputeModule contract uses a global isUsedEvidenceHash mapping to prevent duplicate evidence submission across all disputes. However, this design enables malicious actors to permanently block legitimate disputes by frontrunning evidence hashes. When a dispute is raised in raiseDispute(), the evidence hash is marked as used globally and permanently, even if the dispute is later cancelled via cancelDispute(). The cancellation returns the bond to the initiator but does not clear the evidence hash from the isUsedEvidenceHash mapping. IP owners can exploit this by monitoring for incoming dispute transactions, frontrunning with raiseDispute() using the same evidence hash, then cancelling their own throwaway dispute. This permanently burns the evidence hash while recovering the bond, preventing any future disputes using that evidence.",
  "attack_scenario": "1. Alice discovers Bob's IP contains infringing content and prepares evidence with hash 0xabc123def456\n2. Alice crafts transaction raiseDispute(bobTokenId, 0xabc123def456, tag) with bond=1 CAMP\n3. Bob (the IP owner) monitors mempool and sees Alice's dispute transaction\n4. Bob frontruns with raiseDispute(randomTokenId, 0xabc123def456, tag) using same evidence hash\n5. Bob pays his own 1 CAMP bond\n6. Bob immediately calls cancelDispute(bobDisputeId) to recover his 1 CAMP bond\n7. isUsedEvidenceHash[0xabc123def456] remains true (never cleared during cancelDispute)\n8. Alice's original transaction executes but fails with EvidenceAlreadyUsed() revert\n9. Alice's transaction reverts, her evidence cannot be used\n10. Evidence hash 0xabc123def456 is permanently marked as used\n11. Alice cannot use her evidence against Bob's infringing IP\n12. Bob has blocked a legitimate dispute with minimal cost (bond was returned)",
  "fix_description": "Implement sender-specific evidence tracking instead of global evidence tracking. Create a combined key from both the evidence hash and the sender's address. This prevents one user from blocking another user's evidence while still preventing the same user from submitting duplicate evidence.\n\nCode:\nfunction raiseDispute(\n    uint256 _targetIpId,\n    bytes32 _disputeEvidenceHash,\n    bytes32 _disputeTag\n) external returns (uint256 id) {\n    require(_disputeEvidenceHash != bytes32(0), \"Invalid evidence\");\n    \n    // Create sender-specific evidence key\n    bytes32 senderEvidenceKey = keccak256(abi.encodePacked(\n        _disputeEvidenceHash,\n        msg.sender\n    ));\n    \n    require(!isUsedEvidenceHash[senderEvidenceKey], \"Evidence already used\");\n    isUsedEvidenceHash[senderEvidenceKey] = true;\n    \n    // ... rest of raiseDispute logic ...\n}\n\nNote: This change allows the same evidence to be used in multiple disputes by different users, which is the intended tradeoff.",
  "primary_file": {
    "path": "contracts/DisputeModule.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract DisputeModule {\n    // VULNERABLE: Global evidence hash tracking\n    mapping(bytes32 => bool) public isUsedEvidenceHash;\n    \n    struct Dispute {\n        uint256 targetIpId;\n        address initiator;\n        bytes32 evidenceHash;\n        uint256 bond;\n        DisputeStatus status;\n    }\n    \n    // VULNERABLE: No sender-specific tracking\n    function raiseDispute(\n        uint256 _targetIpId,\n        bytes32 _disputeEvidenceHash,\n        bytes32 _disputeTag\n    ) external returns (uint256 id) {\n        require(_disputeEvidenceHash != bytes32(0), \"Invalid evidence\");\n        \n        // VULNERABLE: Global check prevents any user from using this hash\n        require(!isUsedEvidenceHash[_disputeEvidenceHash], \"EvidenceAlreadyUsed\");\n        \n        // VULNERABLE: Hash marked globally, even if dispute is later cancelled\n        isUsedEvidenceHash[_disputeEvidenceHash] = true;\n        \n        // Create dispute\n        uint256 disputeId = disputes.length;\n        disputes.push(Dispute({\n            targetIpId: _targetIpId,\n            initiator: msg.sender,\n            evidenceHash: _disputeEvidenceHash,\n            bond: msg.value,\n            status: DisputeStatus.Raised\n        }));\n        \n        emit DisputeRaised(disputeId, _targetIpId, msg.sender);\n        return disputeId;\n    }\n    \n    // VULNERABLE: Cancellation does NOT clear the evidence hash\n    function cancelDispute(uint256 _disputeId) external {\n        Dispute storage d = disputes[_disputeId];\n        \n        require(msg.sender == d.initiator, \"Not initiator\");\n        require(d.status == DisputeStatus.Raised, \"Invalid status\");\n        \n        // VULNERABLE: Hash remains marked as used\n        // isUsedEvidenceHash[d.evidenceHash] is still true\n        \n        // Return bond to initiator\n        d.status = DisputeStatus.Cancelled;\n        (bool success, ) = msg.sender.call{value: d.bond}(\"\");\n        require(success, \"Refund failed\");\n        \n        emit DisputeCancelled(_disputeId);\n    }\n}\n",
    "vulnerable_lines": [5, 6, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
    "vulnerable_functions": ["raiseDispute", "cancelDispute"]
  },
  "context_files": [
    {
      "path": "contracts/DisputeModule.sol",
      "content": "// Fixed implementation with sender-specific keys:\n//\n// mapping(bytes32 => bool) public isUsedEvidenceHash;\n//\n// function raiseDispute(\n//     uint256 _targetIpId,\n//     bytes32 _disputeEvidenceHash,\n//     bytes32 _disputeTag\n// ) external returns (uint256 id) {\n//     require(_disputeEvidenceHash != bytes32(0), \"Invalid evidence\");\n//     \n//     // Create sender-specific evidence key\n//     bytes32 senderEvidenceKey = keccak256(abi.encodePacked(\n//         _disputeEvidenceHash,\n//         msg.sender\n//     ));\n//     \n//     require(!isUsedEvidenceHash[senderEvidenceKey], \"Evidence already used by you\");\n//     isUsedEvidenceHash[senderEvidenceKey] = true;\n//     \n//     // ... rest of function ...\n// }\n//\n// Tradeoff: Alice and Bob can both submit the same evidence hash\n// This is acceptable because evidence comes with metadata about the infringing content\n// IP owners cannot block one specific user's evidence without blocking all users\n",
      "relevance": "Shows the fix and explains the acceptable tradeoff of allowing per-user evidence reuse"
    }
  ],
  "call_flow": "Alice.raiseDispute(bobTokenId, hash=0xabc123) → Bob.raiseDispute(randomTokenId, hash=0xabc123) → mark isUsedEvidenceHash[0xabc123]=true → Bob.cancelDispute() → hash still marked true → Alice's transaction fails → evidence blocked permanently",
  "context_hint": "This vulnerability exploits the contract's attempt to prevent duplicate evidence (noble goal) without accounting for who submitted it. The global mapping treats all evidence hashes as globally unique, but evidence has meaning only in context of the dispute claim. By using sender-specific keys, the contract can prevent an individual from reusing their own evidence while allowing different users to submit the same evidence independently.",
  "is_vulnerable": true,
  "expert_notes": "This is a subtle design flaw in the dispute mechanism. The protocol's intended behavior is: 'prevent duplicate evidence across disputes.' The implementation achieves: 'prevent any use of evidence once seen.' The fix requires distinguishing between 'Alice used hash X' and 'hash X was ever used.' Note that Camp's private mempool mitigates the classic frontrunning attack vector, but IP owners can still intentionally exploit this vulnerability. The tradeoff of allowing per-user evidence reuse is acceptable because evidence inherently carries metadata (content hash, claim details) that prevents meaningless reuse."
},

{
  "id": "gs_quantstamp_campnft_camp004",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp - NFT",
  "source_finding_id": "CAMP-4",
  "report_url": "https://certificate.quantstamp.com/full/camp-nft/94cdb738-1a01-4f6c-8632-3bdec427161e/index.html",
  "github_repo_url": "https://github.com/campaign-layer/origin-protocol",
  "contest_date": "2025-08-22",
  "severity": "medium",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "Extreme Term Values Can Have Unintended Consequences",
  "finding_description": "Token terms designate the conditions for buying access and minting derivative tokens. The input validation for these values is very lax, allowing extreme values to be assigned with potentially unintended consequences. (1) Price can be set to 0, eliminating royalty payments to parent tokens and making derivative creation economically exploitable. (2) Duration can be set to very low values (e.g., 1 second), making subscription management near impossible. (3) Royalty fee can be set to 100%, which blocks derivative token creation entirely since the royalty must sum to at most 100%. Even other high values may make it challenging or impossible to create derivative tokens with multiple parents.",
  "attack_scenario": "Attack A - Zero Price Exploitation:\n1. Alice owns token A (parent) with 10% royalty\n2. Bob mints token B as derivative of token A\n3. Bob sets token B price to 0\n4. Charlie buys access to token B\n5. Alice receives 0 royalty (10% of 0 = 0)\n6. Bob offers similar content as Alice for free while Alice derives no revenue\n\nAttack B - Minimal Duration Exploitation:\n1. Owner sets token duration to 1 second\n2. Users cannot effectively purchase subscriptions (one per second)\n3. Subscription management becomes impractical\n4. Access model completely breaks down\n\nAttack C - 100% Royalty Blocking Derivatives:\n1. Owner sets token royalty to 100%\n2. Total royalties now equal 100% (already maxed out)\n3. Cannot mint any derivative tokens (would exceed 100%)\n4. No children can be created from this token\n5. If this was a parent token, all derivative chains are blocked",
  "fix_description": "Implement minimum and maximum limits for all term values: (1) Set minPrice (e.g., 10_000 wei) and require price >= minPrice. (2) Set minDuration (e.g., 1 hour) and maxDuration (e.g., 365 days) and require minDuration <= duration <= maxDuration. (3) Limit royaltyBps to at most 100/9% (approximately 11.11%), ensuring any combination of up to 9 tokens can form a derivative chain. Alternatively, set a reasonable maximum like 50% and document the limitation.\n\nCode:\nfunction updateTerms(uint256 tokenId, LicenseTerms calldata newTerms) external {\n    require(msg.sender == ownerOf(tokenId), \"Not owner\");\n    require(newTerms.price >= MIN_PRICE, \"Price too low\");\n    require(newTerms.duration >= MIN_DURATION, \"Duration too short\");\n    require(newTerms.duration <= MAX_DURATION, \"Duration too long\");\n    require(newTerms.royaltyBps > 0 && newTerms.royaltyBps <= MAX_ROYALTY_BPS, \"Invalid royalty\");\n    // MAX_ROYALTY_BPS = 10_000 / 9 ≈ 1111 (11.11%)\n    \n    terms[tokenId] = newTerms;\n    emit TermsUpdated(tokenId, newTerms);\n}",
  "primary_file": {
    "path": "contracts/IpNFT.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract IpNFT is ERC721 {\n    // VULNERABLE: No constant limits defined\n    \n    struct LicenseTerms {\n        uint256 price;           // Can be set to 0\n        uint32 duration;         // Can be set to 1\n        address paymentToken;    // ETH or wCAMP\n        uint16 royaltyBps;       // Can be set to 10_000 (100%)\n    }\n    \n    mapping(uint256 => LicenseTerms) public terms;\n    \n    // VULNERABLE: No input validation on extreme values\n    function mintWithSignature(\n        address to,\n        uint256 tokenId,\n        LicenseTerms calldata licenseTerms,\n        bytes memory signature\n    ) external {\n        // VULNERABLE: Accepts price = 0\n        // VULNERABLE: Accepts duration = 0\n        // VULNERABLE: Accepts royaltyBps = 10_000 (100%)\n        \n        // Verify signature and mint\n        _verifySignature(to, tokenId, licenseTerms, signature);\n        _mint(to, tokenId);\n        \n        terms[tokenId] = licenseTerms;\n    }\n    \n    // VULNERABLE: No validation, allows extreme updates\n    function updateTerms(\n        uint256 tokenId,\n        LicenseTerms calldata newTerms\n    ) external {\n        require(msg.sender == ownerOf(tokenId), \"Not owner\");\n        \n        // VULNERABLE: Any values accepted\n        // price could be updated to 0 after initial mint\n        // duration could be set to 1 second\n        // royaltyBps could be 10_000 blocking derivatives\n        \n        terms[tokenId] = newTerms;\n        emit TermsUpdated(tokenId, newTerms);\n    }\n}\n",
    "vulnerable_lines": [17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
    "vulnerable_functions": ["mintWithSignature", "updateTerms"]
  },
  "context_files": [
    {
      "path": "contracts/RoyaltyModule.sol",
      "content": "// Derivative token creation requires royalty validation\n\nfunction setParentIpsAndRoyaltyPercents(\n    uint256 childTokenId,\n    uint256[] calldata parentTokenIds,\n    uint16[] calldata royaltyBps\n) external {\n    uint256 totalRoyalties = 0;\n    \n    for (uint i = 0; i < parentTokenIds.length; i++) {\n        totalRoyalties += royaltyBps[i];\n    }\n    \n    // VULNERABLE: If any parent has royaltyBps = 10_000 (100%),\n    // this check will fail because totalRoyalties > 10_000\n    require(totalRoyalties <= 10_000, \"Royalties exceed 100%\");\n    \n    // ... set up royalty distribution ...\n}\n",
      "relevance": "Shows how extreme royalty values block derivative token creation"
    }
  ],
  "call_flow": "Owner.updateTerms(tokenId, price=0) → Charlie.buyAccess(tokenId) → royalty = 0 * 10% = 0 → parent receives no payment → exploit complete",
  "context_hint": "This vulnerability represents a failure to define the intended business logic constraints in code. Every protocol has acceptable ranges for parameters (e.g., minimum subscription duration, maximum fees). Without explicit validation, malicious or careless actors can configure tokens in ways that break the intended behavior. This is a common pattern in DeFi: parameters should have bounds, not just type limits.",
  "is_vulnerable": true,
  "expert_notes": "This is a business logic vulnerability rather than a code execution vulnerability. The contract works as coded, but the code doesn't enforce the protocol's intended constraints. The fix requires product design decisions: what IS the acceptable range for duration, royalty, etc.? Once decided, these should become immutable constants or configurable through governance, not editable per-token without limits. The 11.11% (1/9) royalty cap is mathematically derived from needing to support 8 parent tokens in a derivative chain."
},

{
  "id": "gs_quantstamp_campnft_camp005",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Camp - NFT",
  "source_finding_id": "CAMP-5",
  "report_url": "https://certificate.quantstamp.com/full/camp-nft/94cdb738-1a01-4f6c-8632-3bdec427161e/index.html",
  "github_repo_url": "https://github.com/campaign-layer/origin-protocol",
  "contest_date": "2025-08-22",
  "severity": "medium",
  "vulnerability_type": "economic_attack",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  "finding_title": "Maximizing Royalties by Frontrunning Token Minting",
  "finding_description": "Any token can have up to 8 parent tokens whose owners receive a percentage share of all generated revenue. This revenue split is locked in stone during the minting process according to the royalty terms of the parent tokens at mint time. The RoyaltyModule ensures that the sum of royalties never exceeds 100%, but if it sums to less than 100%, the token owner receives the remainder. This creates an incentive for parent token owners to frontrun the minting transaction and increase their royalty terms before the derivative is created. By frontrunning, a parent owner can temporarily increase their royalty percentage, capture the higher percentage in the derivative's permanently locked royalty distribution, then revert their terms back to normal values. This allows parent owners to extract more revenue from all future purchases of that derivative token.",
  "attack_scenario": "1. Alice mints parent token P with 10% royalty terms\n2. Bob submits mintWithSignature transaction to create token C with 3 parents (Alice=10%, Mallory=10%, Owner=10%, Remainder=70% to creator)\n3. Mallory owns another parent token M with current royalty = 10%\n4. Mallory monitors mempool and detects Bob's mint transaction\n5. Mallory frontruns with updateTerms(M, royaltyBps=65%)\n6. Bob's mint transaction executes with new parent terms\n7. Token C is created with royalty split locked as: Alice=10%, Mallory=65%, Owner=10%, Creator=15%\n8. Mallory changes her terms back to 10% (revert to original)\n9. Mallory captured 65% of all C's revenue instead of 10%\n10. All future purchases of C pay Mallory 65% instead of 10%, permanently\n11. This is 6.5x her normal royalty rate\n12. Bob's intended royalty distribution is destroyed",
  "fix_description": "Implement one of two solutions: (1) Limit maximum royalty percentage to 100/9% (approximately 11.11%) per token. This ensures that even if all 9 slots are filled, total cannot exceed 100%, and no parent can dominate by increasing their terms. With this cap, the attack becomes unprofitable. (2) Require the minting user to pass expected royalty percentages for each parent and validate they match actual terms. Revert if mismatch detected.\n\nPreferred solution (option 1) for simplicity:\nfunction updateTerms(uint256 tokenId, LicenseTerms calldata newTerms) external {\n    require(msg.sender == ownerOf(tokenId), \"Not owner\");\n    require(newTerms.royaltyBps <= MAX_ROYALTY_BPS, \"Royalty too high\");\n    // MAX_ROYALTY_BPS = 10_000 / 9 = 1111 (11.11%)\n    terms[tokenId] = newTerms;\n}\n\nAlternative solution (option 2):\nfunction setParentIpsAndRoyaltyPercents(\n    uint256 childTokenId,\n    uint256[] calldata parentTokenIds,\n    uint16[] calldata expectedParentRoyalties\n) external {\n    for (uint i = 0; i < parentTokenIds.length; i++) {\n        IpNFT.LicenseTerms memory parentTerms = ipToken.getTerms(parentTokenIds[i]);\n        require(parentTerms.royaltyBps == expectedParentRoyalties[i], \"Parent royalty changed\");\n    }\n}",
  "primary_file": {
    "path": "contracts/RoyaltyModule.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ncontract RoyaltyModule {\n    IpNFT public ipToken;\n    \n    // VULNERABLE: No cap on individual royalty percentages\n    // VULNERABLE: No commitment to expected parent terms\n    function setParentIpsAndRoyaltyPercents(\n        uint256 childTokenId,\n        uint256[] calldata parentTokenIds,\n        uint16[] calldata royaltyBps\n    ) external {\n        require(parentTokenIds.length <= 8, \"Too many parents\");\n        \n        uint256 totalRoyalties = 0;\n        \n        for (uint i = 0; i < parentTokenIds.length; i++) {\n            // VULNERABLE: No validation that parent royalty terms haven't changed\n            // Parent owner can frontrun and increase their royalty\n            // This function locks in whatever royalty is current\n            totalRoyalties += royaltyBps[i];\n        }\n        \n        require(totalRoyalties <= 10_000, \"Exceeds 100%\");\n        \n        // Store the royalty distribution\n        for (uint i = 0; i < parentTokenIds.length; i++) {\n            royaltyDistribution[childTokenId][i] = RoyaltyInfo({\n                parentTokenId: parentTokenIds[i],\n                royaltyBps: royaltyBps[i]  // VULNERABLE: Locked in, even if it increased\n            });\n        }\n    }\n    \n    // VULNERABLE: Called at mint time, captures whatever current terms are\n    function _setupDerivativeRoyalties(\n        uint256 childTokenId,\n        uint256[] memory parentTokenIds\n    ) internal {\n        // Retrieve current parent terms\n        for (uint i = 0; i < parentTokenIds.length; i++) {\n            IpNFT.LicenseTerms memory parentTerms = ipToken.getTerms(parentTokenIds[i]);\n            // VULNERABLE: parentTerms.royaltyBps can be different from what minter expected\n            // If parent owner frontran, this captures the increased amount\n            royaltyDistribution[childTokenId][i] = RoyaltyInfo({\n                parentTokenId: parentTokenIds[i],\n                royaltyBps: parentTerms.royaltyBps  // Frontrun captured here\n            });\n        }\n    }\n}\n",
    "vulnerable_lines": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42],
    "vulnerable_functions": ["setParentIpsAndRoyaltyPercents", "_setupDerivativeRoyalties"]
  },
  "context_files": [
    {
      "path": "contracts/IpNFT.sol",
      "content": "// Parent token terms can be changed at any time\n\nmapping(uint256 => LicenseTerms) public terms;\n\nfunction updateTerms(\n    uint256 tokenId,\n    LicenseTerms calldata newTerms\n) external {\n    require(msg.sender == ownerOf(tokenId), \"Not owner\");\n    \n    // VULNERABLE: No maximum on royaltyBps\n    // Can be changed from 10% to 65% right before derivative minting\n    // Then changed back to 10% after minting completes\n    // The derivative retains the 65% permanently\n    \n    terms[tokenId] = newTerms;\n    emit TermsUpdated(tokenId, newTerms);\n}\n",
      "relevance": "Shows how parent token terms can be frontrun and temporarily modified"
    }
  ],
  "call_flow": "Bob.submitMint(parents=[Alice, Mallory, Owner]) → Mallory.updateTerms(royalty=65%) → Bob.mint executes → royalty locked at 65% → Mallory.updateTerms(royalty=10%) → all future revenue includes 65% to Mallory",
  "context_hint": "This vulnerability exploits the lock-in mechanism that makes royalty distributions immutable after minting. While immutability is desired (prevents changing terms on existing minted derivatives), it creates a window for frontrunning exploitation. The contract retrieves parent terms at mint time without allowing the minter to validate them first. This is analogous to MEV attacks on DEX swaps, but in the context of revenue sharing.",
  "is_vulnerable": true,
  "expert_notes": "This attack combines two mechanisms: (1) immutable royalty locking (good for stability, bad for attack resistance) and (2) permissioned term updates (IP owner can change terms). The 11.11% royalty cap fix elegantly addresses this by making the attack unprofitable - even if Mallory increases her royalty to 65%, she's immediately capped at 11.11%, so the frontrun provides no benefit. The alternative fix (expected royalty validation) follows the slippage protection pattern from AMMs but requires UI/SDK changes to calculate expected values. The 11.11% cap is mathematically derived: 8 parents × 11.11% ≈ 89%, leaving space for token owner to receive ~11%."
}]
