[
  {
    "id": "gs_diligence_linea_001",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "consensys_diligence",
    "source_report": "Linea Burn Mechanism - October 2025",
    "source_finding_id": "4.1",
    "report_url": "https://diligence.consensys.io/audits/2025/10/linea-burn-mechanism/",
    "github_repo_url": "https://github.com/Consensys/linea-monorepo",
    "contest_date": "2025-10-13",
    "severity": "high",
    "vulnerability_type": "initialization_failure",
    "difficulty_tier": 2,
    "context_level": "cross_contract",
    "finding_title": "Deployment Script Leaves Contract Uninitialized; fallback Does Not Enforce msg.value > 0",
    "finding_description": "The deployment script for RollupRevenueVault incorrectly attempts to call a non-existent initialize() function with no parameters, leaving the contract uninitialized and non-functional. The script specifies an empty initializer signature 'initialize()', but the RollupRevenueVault contract only defines an initialize() function that requires 10 parameters. When OpenZeppelin's deployProxy executes this empty initializer, the call is routed to the contract's fallback function instead of performing proper initialization. As a result, the contract remains uninitialized, allowing anyone to claim it by calling the actual initialize function and gaining full control including DEFAULT_ADMIN_ROLE. Additionally, the fallback function accepts ETH without enforcing msg.value > 0, which could allow zero-value calls that trigger unintended events.",
    "attack_scenario": "1. Deployment script calls deployUpgradableFromFactory with initializer: 'initialize()' (no parameters)\n2. The proxy is deployed successfully and the initializer call is made\n3. Contract has no zero-parameter initialize() function, so the call routes to fallback()\n4. fallback() executes successfully (emits EthReceived event) without initializing state\n5. Contract appears deployed but is completely uninitialized:\n   - No roles are granted (no admin, no invoice submitter, no burner)\n   - Critical addresses are not set (tokenBridge, messageService, l1LineaTokenBurner, lineaToken, dex all zero)\n   - lastInvoiceDate is 0\n6. Attacker monitors mempool or block explorer and detects the uninitialized contract\n7. Attacker front-runs or immediately calls the real initialize() function with their own parameters\n8. Attacker grants themselves DEFAULT_ADMIN_ROLE, INVOICE_SUBMITTER_ROLE, BURNER_ROLE\n9. Attacker sets all critical contract addresses to their controlled contracts\n10. Attacker now controls: invoice submission, burn operations, DEX routing, token bridging\n11. Attacker can drain any ETH sent to the contract or manipulate the burn mechanism\n12. Even if detected, the contract is permanently compromised as initialization cannot be repeated",
    "fix_description": "The fix requires three changes:\n\n1. **Fix the deployment script** to call the correct initialize function with all required parameters:\n````typescript\nconst contract `= await deployUpgradableFromFactory(`\n  contractName`,`\n  `[`\n    lastInvoiceDate`,`\n    defaultAdmin`,`\n    invoiceSubmitter`,`\n    burner`,`\n    invoicePaymentReceiver`,`\n    tokenBridge`,`\n    messageService`,`\n    l1LineaTokenBurner`,`\n    lineaToken`,`\n    dex\n  `],`\n  `{`\n    initializer`: \"initialize(uint256,address,address,address,address,address,address,address,address,address)\",`\n    unsafeAllow`: [\"constructor\"],`\n  `}`\n`);`\n````\n\n2. **Add validation to fallback()** to prevent zero-value calls:\n````solidity\nfallback`() external payable {`\n  require`(`msg.value` > 0, NoEthSent());`\n  emit EthReceived`(`msg.value`);`\n`}`\n````\n\n3. **Bundle with reinitializer** to avoid another front-running window if upgrading an existing deployment:\n````solidity\n`/`/ In upgrade transaction`,` call upgradeToAndCall with reinitializer\nproxy.upgradeToAndCall`(`\n  newImplementation`,`\n  abi.encodeWithSelector`(`\n    RollupRevenueVault.initializeRolesAndStorageVariables.selector`,`\n    params...\n  `)`\n`);`\n````",
    "primary_file": {
      "path": "contracts/src/operational/RollupRevenueVault.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0 OR MIT\npragma solidity 0.8.30;\n\nimport { AccessControlUpgradeable } from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { L2MessageService } from "../messaging/l2/L2MessageService.sol";\nimport { TokenBridge } from "../bridging/token/TokenBridge.sol";\nimport { IRollupRevenueVault } from "./interfaces/IRollupRevenueVault.sol";\n\n/**\n * @title Upgradeable Rollup Revenue Vault Contract.\n * @notice Accepts rollup revenue, and performs burning operations.\n * @author Consensys Software Inc.\n * @custom:security-contact security-report@linea.build\n */\ncontract RollupRevenueVault is AccessControlUpgradeable, IRollupRevenueVault {\n bytes32 public constant INVOICE_SUBMITTER_ROLE = keccak256("INVOICE_SUBMITTER_ROLE");\n bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");\n\n /// @notice Percentage of ETH to be burnt when performing the burn and bridge operation.\n uint256 public constant ETH_BURNT_PERCENTAGE = 20;\n\n /// @notice Decentralized exchange adapter contract for swapping ETH to LINEA tokens.\n address public dexSwapAdapter;\n /// @notice Address to receive invoice payments.\n address public invoicePaymentReceiver;\n /// @notice Amount of invoice arrears.\n uint256 public invoiceArrears;\n /// @notice Timestamp of the last invoice.\n uint256 public lastInvoiceDate;\n /// @notice Address of the token bridge contract.\n TokenBridge public tokenBridge;\n /// @notice Address of the L2 message service contract.\n L2MessageService public messageService;\n /// @notice Address of the L1 LINEA token burner contract to which LINEA tokens are bridged for burning.\n address public l1LineaTokenBurner;\n /// @notice Address of the LINEA token contract.\n address public lineaToken;\n\n /// @custom:oz-upgrades-unsafe-allow constructor\n constructor() {\n _disableInitializers();\n }\n\n /**\n * @notice Reinitializes the contract state for upgrade.\n * @param _lastInvoiceDate The default or starting timestamp for invoices less 1 second.\n * @param _defaultAdmin Address to be granted the default admin role.\n * @param _invoiceSubmitter Address to be granted the invoice submitter role.\n * @param _burner Address to be granted the burner role.\n * @param _invoicePaymentReceiver Address to receive invoice payments.\n * @param _tokenBridge Address of the token bridge contract.\n * @param _messageService Address of the L2 message service contract.\n * @param _l1LineaTokenBurner Address of the L1 LINEA token burner contract.\n * @param _lineaToken Address of the LINEA token contract.\n * @param _dexSwapAdapter Address of the DEX swap adapter contract.\n */\n function initializeRolesAndStorageVariables(\n uint256 _lastInvoiceDate,\n address _defaultAdmin,\n address _invoiceSubmitter,\n address _burner,\n address _invoicePaymentReceiver,\n address _tokenBridge,\n address _messageService,\n address _l1LineaTokenBurner,\n address _lineaToken,\n address _dexSwapAdapter\n ) external reinitializer(2) {\n __AccessControl_init();\n __RollupRevenueVault_init(\n _lastInvoiceDate,\n _defaultAdmin,\n _invoiceSubmitter,\n _burner,\n _invoicePaymentReceiver,\n _tokenBridge,\n _messageService,\n _l1LineaTokenBurner,\n _lineaToken,\n _dexSwapAdapter\n );\n }\n\n function __RollupRevenueVault_init(\n uint256 _lastInvoiceDate,\n address _defaultAdmin,\n address _invoiceSubmitter,\n address _burner,\n address _invoicePaymentReceiver,\n address _tokenBridge,\n address _messageService,\n address _l1LineaTokenBurner,\n address _lineaToken,\n address _dexSwapAdapter\n ) internal onlyInitializing {\n require(_lastInvoiceDate != 0, ZeroTimestampNotAllowed());\n require(_lastInvoiceDate < block.timestamp, FutureInvoicesNotAllowed());\n\n require(_defaultAdmin != address(0), ZeroAddressNotAllowed());\n require(_invoiceSubmitter != address(0), ZeroAddressNotAllowed());\n require(_burner != address(0), ZeroAddressNotAllowed());\n require(_invoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n require(_tokenBridge != address(0), ZeroAddressNotAllowed());\n require(_messageService != address(0), ZeroAddressNotAllowed());\n require(_l1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n require(_lineaToken != address(0), ZeroAddressNotAllowed());\n require(_dexSwapAdapter != address(0), ZeroAddressNotAllowed());\n\n _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n _grantRole(INVOICE_SUBMITTER_ROLE, _invoiceSubmitter);\n _grantRole(BURNER_ROLE, _burner);\n\n lastInvoiceDate = _lastInvoiceDate;\n\n invoicePaymentReceiver = _invoicePaymentReceiver;\n tokenBridge = TokenBridge(_tokenBridge);\n messageService = L2MessageService(_messageService);\n l1LineaTokenBurner = _l1LineaTokenBurner;\n lineaToken = _lineaToken;\n dexSwapAdapter = _dexSwapAdapter;\n\n emit RollupRevenueVaultInitialized(\n _lastInvoiceDate,\n _invoicePaymentReceiver,\n _tokenBridge,\n _messageService,\n _l1LineaTokenBurner,\n _lineaToken,\n _dexSwapAdapter\n );\n }\n\n /**\n * @notice Submit invoice to pay to the designated receiver.\n * @param _startTimestamp Start of the period the invoice is covering.\n * @param _endTimestamp End of the period the invoice is covering.\n * @param _invoiceAmount New invoice amount.\n */\n function submitInvoice(\n uint256 _startTimestamp,\n uint256 _endTimestamp,\n uint256 _invoiceAmount\n ) external payable onlyRole(INVOICE_SUBMITTER_ROLE) {\n require(_startTimestamp == lastInvoiceDate + 1, TimestampsNotInSequence());\n require(_endTimestamp > _startTimestamp, EndTimestampMustBeGreaterThanStartTimestamp());\n require(_endTimestamp < block.timestamp, FutureInvoicesNotAllowed());\n require(_invoiceAmount != 0, ZeroInvoiceAmount());\n\n address payable receiver = payable(invoicePaymentReceiver);\n uint256 balanceAvailable = address(this).balance;\n\n uint256 totalAmountOwing = invoiceArrears + _invoiceAmount;\n uint256 amountToPay = (balanceAvailable < totalAmountOwing) ? balanceAvailable : totalAmountOwing;\n\n invoiceArrears = totalAmountOwing - amountToPay;\n lastInvoiceDate = _endTimestamp;\n\n if (amountToPay > 0) {\n (bool success, ) = receiver.call{ value: amountToPay }("");\n require(success, InvoiceTransferFailed());\n }\n\n emit InvoiceProcessed(receiver, _startTimestamp, _endTimestamp, amountToPay, _invoiceAmount);\n }\n\n /**\n * @notice Burns 20% of the ETH balance and uses the rest to buy LINEA tokens which are then bridged to L1 to be burned.\n * @param _swapData Encoded calldata for the DEX swap function.\n */\n function burnAndBridge(bytes calldata _swapData) external onlyRole(BURNER_ROLE) {\n _payArrears();\n\n uint256 minimumFee = messageService.minimumFeeInWei();\n\n if (address(this).balance > minimumFee) {\n uint256 balanceAvailable = address(this).balance - minimumFee;\n\n uint256 ethToBurn = (balanceAvailable * ETH_BURNT_PERCENTAGE) / 100;\n (bool success, ) = address(0).call{ value: ethToBurn }("");\n require(success, EthBurnFailed());\n\n (bool swapSuccess, ) = dexSwapAdapter.call{ value: balanceAvailable - ethToBurn }(_swapData);\n require(swapSuccess, DexSwapFailed());\n\n address lineaTokenAddress = lineaToken;\n TokenBridge tokenBridgeContract = tokenBridge;\n\n uint256 lineaTokenBalanceAfter = IERC20(lineaTokenAddress).balanceOf(address(this));\n\n IERC20(lineaTokenAddress).approve(address(tokenBridgeContract), lineaTokenBalanceAfter);\n\n tokenBridgeContract.bridgeToken{ value: minimumFee }(\n lineaTokenAddress,\n lineaTokenBalanceAfter,\n l1LineaTokenBurner\n );\n\n emit EthBurntSwappedAndBridged(ethToBurn, lineaTokenBalanceAfter);\n }\n }\n\n /**\n * @notice Update the invoice payment receiver.\n * @param _newInvoicePaymentReceiver New invoice payment receiver address.\n */\n function updateInvoicePaymentReceiver(address _newInvoicePaymentReceiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_newInvoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n\n address currentInvoicePaymentReceiver = invoicePaymentReceiver;\n require(_newInvoicePaymentReceiver != currentInvoicePaymentReceiver, ExistingAddressTheSame());\n\n invoicePaymentReceiver = _newInvoicePaymentReceiver;\n emit InvoicePaymentReceiverUpdated(currentInvoicePaymentReceiver, _newInvoicePaymentReceiver);\n }\n\n /**\n * @notice Update the invoice arrears.\n * @param _invoiceArrears New invoice arrears value.\n * @param _lastInvoiceDate Timestamp of the last invoice.\n */\n function updateInvoiceArrears(\n uint256 _invoiceArrears,\n uint256 _lastInvoiceDate\n ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_lastInvoiceDate >= lastInvoiceDate, InvoiceDateTooOld());\n require(_lastInvoiceDate < block.timestamp, FutureInvoicesNotAllowed());\n\n emit InvoiceArrearsUpdated(invoiceArrears, _invoiceArrears, lastInvoiceDate, _lastInvoiceDate);\n\n invoiceArrears = _invoiceArrears;\n lastInvoiceDate = _lastInvoiceDate;\n }\n\n /**\n * @notice Updates the address of the L1 LINEA token burner contract.\n * @param _newL1LineaTokenBurner Address of the new L1 LINEA token burner contract.\n */\n function updateL1LineaTokenBurner(address _newL1LineaTokenBurner) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_newL1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n\n address currentL1LineaTokenBurner = l1LineaTokenBurner;\n require(_newL1LineaTokenBurner != currentL1LineaTokenBurner, ExistingAddressTheSame());\n\n l1LineaTokenBurner = _newL1LineaTokenBurner;\n emit L1LineaTokenBurnerUpdated(currentL1LineaTokenBurner, _newL1LineaTokenBurner);\n }\n\n /**\n * @notice Updates the address of the DEX swap adapter contract.\n * @param _newDexSwapAdapter Address of the new DEX swap adapter contract.\n */\n function updateDexSwapAdapter(address _newDexSwapAdapter) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_newDexSwapAdapter != address(0), ZeroAddressNotAllowed());\n\n    address currentDexSwapAdapter = dexSwapAdapter;\n    require(_newDexSwapAdapter != currentDexSwapAdapter, ExistingAddressTheSame());\n\n    dexSwapAdapter = _newDexSwapAdapter;\n    emit DexSwapAdapterUpdated(currentDexSwapAdapter, _newDexSwapAdapter);\n  }\n\n  /**\n   * @notice Fallback function - Receives Funds.\n   */\n  fallback() external payable {\n    require(msg.value > 0, NoEthSent());\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Receive function - Receives Funds.\n   */\n  receive() external payable {\n    require(msg.value > 0, NoEthSent());\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Pays off arrears where applicable and balance permits.\n   */\n  function _payArrears() internal {\n    uint256 balanceAvailable = address(this).balance;\n\n    uint256 totalAmountOwing = invoiceArrears;\n    uint256 amountToPay = (balanceAvailable < totalAmountOwing) ? balanceAvailable : totalAmountOwing;\n\n    if (amountToPay > 0) {\n      uint256 remainingArrears = totalAmountOwing - amountToPay;\n      invoiceArrears = remainingArrears;\n\n      (bool success, ) = payable(invoicePaymentReceiver).call{ value: amountToPay }("");\n      require(success, InvoiceTransferFailed());\n      emit ArrearsPaid(amountToPay, remainingArrears);\n    }\n  }\n}",
      "vulnerable_lines": [
        282,
        283,
        284,
        285,
        286,
        287,
        288
      ],
      "vulnerable_functions": [
        "fallback"
      ]
    },
    "context_files": [
      {
        "path": "contracts/deploy/18_deploy_RollupRevenueVault.ts",
        "content": "import { DeployFunction } from "hardhat-deploy/types";\nimport { deployUpgradableFromFactory } from "../scripts/hardhat/utils";\nimport { tryVerifyContract, LogContractDeployment } from "../common/helpers";\nimport { ROLLUP_REVENUE_VAULT_INITIALIZE_SIGNATURE } from "../common/constants";\n\nconst func: DeployFunction = async function () {\n  const contractName = "RollupRevenueVault";\n\n  const lastInvoiceDate = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_LAST_INVOICE_DATE");\n  const securityCouncil = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_SECURITY_COUNCIL");\n  const invoiceSubmitter = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_INVOICE_SUBMITTER");\n  const burner = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_BURNER");\n  const invoicePaymentReceiver = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_INVOICE_PAYMENT_RECEIVER");\n  const tokenBridge = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_TOKEN_BRIDGE");\n  const messageService = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_MESSAGE_SERVICE");\n  const l1LineaTokenBurner = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_L1_LINEA_TOKEN_BURNER");\n  const lineaToken = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_LINEA_TOKEN");\n  const dexSwapAdapter = getRequiredEnvVar("ROLLUP_REVENUE_VAULT_DEX_SWAP_ADAPTER");\n\n  const contract = await deployUpgradableFromFactory(\n    contractName,\n    [\n      lastInvoiceDate,\n      securityCouncil,\n      invoiceSubmitter,\n      burner,\n      invoicePaymentReceiver,\n      tokenBridge,\n      messageService,\n      l1LineaTokenBurner,\n      lineaToken,\n      dexSwapAdapter,\n    ],\n    {\n      initializer: ROLLUP_REVENUE_VAULT_INITIALIZE_SIGNATURE,\n      unsafeAllow: ["constructor"],\n    },\n  );\n\n  await LogContractDeployment(contractName, contract);\n  const contractAddress = await contract.getAddress();\n\n  await tryVerifyContract(contractAddress, "src/operational/RollupRevenueVault.sol:RollupRevenueVault");\n};\n\nexport default func;\nfunc.tags = ["RollupRevenueVault"];",
        "relevance": "This deployment script contains the critical bug that causes the vulnerability. It attempts to call initialize() with no parameters, which doesn't match any function signature in the contract. OpenZeppelin's deployProxy executes this call, but since no matching function exists, it routes to the fallback() function. The fallback succeeds (emitting an event), making the deployment appear successful while the contract remains completely uninitialized and vulnerable to takeover."
      }
    ],
    "call_flow": "DeployScript.deployUpgradableFromFactory() -> OpenZeppelin deployProxy() -> calls proxy.initialize() with no params -> no matching function signature in implementation -> EVM routes call to fallback() -> fallback() emits EthReceived(0) and returns success -> deployment appears successful but contract is uninitialized -> Attacker.exploit() -> calls real initialize() with attacker parameters -> attacker gains full control",
    "context_hint": "This vulnerability combines two critical issues: (1) a deployment script bug that calls the wrong function signature, and (2) a permissive fallback function that doesn't validate its inputs. The deployment script's EMPTY_INITIALIZE_SIGNATURE constant creates a mismatch - it tries to call 'initialize()' but the contract only has 'initialize(uint256,address,address,address,address,address,address,address,address,address)'. In Solidity, when a function call doesn't match any signature, the fallback function is invoked. Since fallback() doesn't revert, the deployment succeeds from the script's perspective. However, the Initializable modifier's state remains untouched - the contract thinks it has never been initialized. This creates a critical window where anyone can call the real initialize() function and gain complete control. The severity is amplified because: (1) This is a revenue management contract handling ETH and token burns, (2) The attacker gains DEFAULT_ADMIN_ROLE enabling unlimited access, (3) They can set malicious DEX and bridge addresses to steal funds, (4) The bug is hidden because deployment \"succeeds\", (5) In production, this would likely be detected only after funds are at risk. The fallback's lack of msg.value > 0 validation is a secondary issue but contributes to hiding the bug.",
    "is_vulnerable": true,
    "expert_notes": "This represents a critical initialization vulnerability pattern that has caused major incidents in production. Key insights: (1) The bug demonstrates why initialization must happen atomically with deployment - any gap creates a front-running window, (2) OpenZeppelin's upgradeable proxies are powerful but require exact function signature matching - typos or mismatches can fail silently, (3) Fallback functions can mask initialization failures by succeeding when they shouldn't, (4) TypeScript/JavaScript deployment scripts lack compile-time type checking for Solidity function signatures, (5) The Initializable modifier's state management is separate from function routing - fallback calls don't trigger it. Historical parallels: Parity Wallet hack ($280M) where uninitialized wallets were taken over, Wormhole bridge attack ($320M) involved initialization issues. Defense strategies: (1) Use OpenZeppelin's hardhat-upgrades plugin which validates initializer signatures, (2) Add deployment verification tests that check state after deployment, (3) Use CREATE2 for deterministic deployment addresses, (4) Remove fallback functions from upgradeable contracts unless absolutely necessary, and if needed, add strict validation."
  },
  {
    "id": "gs_diligence_linea_002",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "ethereum",
    "source_platform": "consensys_diligence",
    "source_report": "Linea Burn Mechanism - October 2025",
    "source_finding_id": "4.2",
    "report_url": "https://diligence.consensys.io/audits/2025/10/linea-burn-mechanism/",
    "github_repo_url": "https://github.com/Consensys/linea-monorepo",
    "contest_date": "2025-10-13",
    "severity": "high",
    "vulnerability_type": "access_control",
    "difficulty_tier": 3,
    "context_level": "single_file",
    "finding_title": "Deployment and Initialization Flow Creates Front-Running Vulnerability",
    "finding_description": "The RollupRevenueVault contract implements two initialization functions: initialize() with the initializer modifier for initial deployment, and initializeRolesAndStorageVariables() with reinitializer(2) for upgrades. The reinitializer(2) function becomes available immediately after the first initialization, creating a critical vulnerability window. If the upgrade process doesn't atomically call the reinitializer in the same transaction as the upgrade, an attacker can front-run the reinitialization and gain control. Additionally, both functions call the same internal __RollupRevenueVault_init() logic, which inappropriately resets critical state variables and grants roles additively without revoking existing ones during upgrades. This can lead to privilege accumulation, state inconsistencies, and unauthorized access.",
    "attack_scenario": "1. RollupRevenueVault V1 is deployed and properly initialized with legitimate admin\n2. Protocol decides to upgrade to V2 with new features\n3. Admin executes upgradeTo(V2Implementation) transaction\n4. V2 implementation is now active, but not yet reinitialized\n5. Attacker monitors mempool and sees the upgrade transaction\n6. Attacker immediately submits initializeRolesAndStorageVariables() transaction with high gas price\n7. Attacker's transaction gets mined before the legitimate reinitialization\n8. Attacker passes their own addresses for all parameters:\n   - _defaultAdmin = attacker (grants DEFAULT_ADMIN_ROLE)\n   - _invoiceSubmitter = attacker (grants INVOICE_SUBMITTER_ROLE)\n   - _burner = attacker (grants BURNER_ROLE)\n9. __RollupRevenueVault_init() executes, granting roles to attacker\n10. Original admins still have their roles (roles are additive, not replaced)\n11. Attacker now has equal privileges to original admins\n12. Attacker can: submit fake invoices, execute burns to malicious DEX, update critical addresses\n13. Even worse, if attacker manages to call updateDex() first, they can redirect all burns\n14. The lastInvoiceDate gets reset, breaking invoice accounting continuity\n15. Token and bridge addresses get reset, potentially breaking integrations\n16. Protocol is compromised and requires emergency response",
    "fix_description": "The fix requires multiple changes to eliminate the vulnerability:\n\n1. **Atomic Upgrade and Reinitialization**:\n````solidity\n`/`/ Use upgradeToAndCall instead of separate transactions\nproxy.upgradeToAndCall`(`\n  newImplementation`,`\n  abi.encodeWithSelector`(`\n    RollupRevenueVault.initializeRolesAndStorageVariables.selector`,`\n    lastInvoiceDate`,`\n    defaultAdmin`,`\n    `/`/ ... all parameters\n  `)`\n`);`\n````\n\n2. **Separate Initialization Logic for Upgrades**:\n````solidity\n`/`/ Create upgrade-specific reinitialization that only updates necessary parameters\nfunction initializeV2Upgrade`(`\n  address _newDexIfNeeded`,`\n  address _newFeatureAddress\n`) external reinitializer(2) {`\n  `/`/ Only update what changed in V2\n  `/`/ Do NOT reset critical state like lastInvoiceDate\n  `/`/ Do NOT re-grant existing roles\n  if `(_newDexIfNeeded != address(0)) {`\n    dex `= _newDexIfNeeded;`\n  `}`\n  `/`/ Initialize only new V2 features\n`}`\n````\n\n3. **Role Management for Upgrades**:\n````solidity\n`/`/ Explicitly revoke old roles before granting new ones\nfunction _updateRoles`(`\n  address _oldAdmin`,`\n  address _newAdmin`,`\n  address _oldSubmitter`,`\n  address _newSubmitter`,`\n  address _oldBurner`,`\n  address _newBurner\n`) internal {`\n  `/`/ Revoke old roles first\n  if `(_oldAdmin != address(0)) {`\n    _revokeRole`(DEFAULT_ADMIN_ROLE, _oldAdmin);`\n  `}`\n  `/`/ Then grant new roles\n  _grantRole`(DEFAULT_ADMIN_ROLE, _newAdmin);`\n  `/`/ Repeat for other roles\n`}`\n````\n\n4. **Preserve Critical State**:\n````solidity\n`/`/ Do NOT reset these in reinitializer`:`\n`/`/ - lastInvoiceDate `(breaks accounting)`\n`/`/ - lineaToken `(breaks token operations)`\n`/`/ - tokenBridge `(breaks bridging)`\n`/`/ - messageService `(breaks messaging)`\n````\n\nImplemented fix (from commit 831c529479faebb380df1478e17f03bf0a3b9b80):\n- Modified deployment to call correct initialize function atomically\n- Changed upgrade flow to use upgradeAndCall with direct reinitializer call\n- Added require(msg.value > 0) to fallback\n- reinitializer(2) now prevents any future initialize() calls",
    "primary_file": {
      "path": "contracts/src/operational/RollupRevenueVault.sol",
      "content": "// SPDX-License-Identifier: Apache-2.0 OR MIT\npragma solidity 0.8.30;\n\nimport { AccessControlUpgradeable } from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";\nimport { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport { L2MessageService } from "../messaging/l2/L2MessageService.sol";\nimport { TokenBridge } from "../bridging/token/TokenBridge.sol";\nimport { IRollupRevenueVault } from "./interfaces/IRollupRevenueVault.sol";\n\n/**\n * @title Upgradeable Rollup Revenue Vault Contract.\n * @notice Accepts rollup revenue, and performs burning operations.\n * @author Consensys Software Inc.\n * @custom:security-contact security-report@linea.build\n */\ncontract RollupRevenueVault is AccessControlUpgradeable, IRollupRevenueVault {\n bytes32 public constant INVOICE_SUBMITTER_ROLE = keccak256("INVOICE_SUBMITTER_ROLE");\n bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");\n\n /// @notice Percentage of ETH to be burnt when performing the burn and bridge operation.\n uint256 public constant ETH_BURNT_PERCENTAGE = 20;\n\n /// @notice Decentralized exchange adapter contract for swapping ETH to LINEA tokens.\n address public dexSwapAdapter;\n /// @notice Address to receive invoice payments.\n address public invoicePaymentReceiver;\n /// @notice Amount of invoice arrears.\n uint256 public invoiceArrears;\n /// @notice Timestamp of the last invoice.\n uint256 public lastInvoiceDate;\n /// @notice Address of the token bridge contract.\n TokenBridge public tokenBridge;\n /// @notice Address of the L2 message service contract.\n L2MessageService public messageService;\n /// @notice Address of the L1 LINEA token burner contract to which LINEA tokens are bridged for burning.\n address public l1LineaTokenBurner;\n /// @notice Address of the LINEA token contract.\n address public lineaToken;\n\n /// @custom:oz-upgrades-unsafe-allow constructor\n constructor() {\n _disableInitializers();\n }\n\n /**\n * @notice Reinitializes the contract state for upgrade.\n * @param _lastInvoiceDate The default or starting timestamp for invoices less 1 second.\n * @param _defaultAdmin Address to be granted the default admin role.\n * @param _invoiceSubmitter Address to be granted the invoice submitter role.\n * @param _burner Address to be granted the burner role.\n * @param _invoicePaymentReceiver Address to receive invoice payments.\n * @param _tokenBridge Address of the token bridge contract.\n * @param _messageService Address of the L2 message service contract.\n * @param _l1LineaTokenBurner Address of the L1 LINEA token burner contract.\n * @param _lineaToken Address of the LINEA token contract.\n * @param _dexSwapAdapter Address of the DEX swap adapter contract.\n */\n function initializeRolesAndStorageVariables(\n uint256 _lastInvoiceDate,\n address _defaultAdmin,\n address _invoiceSubmitter,\n address _burner,\n address _invoicePaymentReceiver,\n address _tokenBridge,\n address _messageService,\n address _l1LineaTokenBurner,\n address _lineaToken,\n address _dexSwapAdapter\n ) external reinitializer(2) {\n __AccessControl_init();\n __RollupRevenueVault_init(\n _lastInvoiceDate,\n _defaultAdmin,\n _invoiceSubmitter,\n _burner,\n _invoicePaymentReceiver,\n _tokenBridge,\n _messageService,\n _l1LineaTokenBurner,\n _lineaToken,\n _dexSwapAdapter\n );\n }\n\n function __RollupRevenueVault_init(\n uint256 _lastInvoiceDate,\n address _defaultAdmin,\n address _invoiceSubmitter,\n address _burner,\n address _invoicePaymentReceiver,\n address _tokenBridge,\n address _messageService,\n address _l1LineaTokenBurner,\n address _lineaToken,\n address _dexSwapAdapter\n ) internal onlyInitializing {\n require(_lastInvoiceDate != 0, ZeroTimestampNotAllowed());\n require(_lastInvoiceDate < block.timestamp, FutureInvoicesNotAllowed());\n\n require(_defaultAdmin != address(0), ZeroAddressNotAllowed());\n require(_invoiceSubmitter != address(0), ZeroAddressNotAllowed());\n require(_burner != address(0), ZeroAddressNotAllowed());\n require(_invoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n require(_tokenBridge != address(0), ZeroAddressNotAllowed());\n require(_messageService != address(0), ZeroAddressNotAllowed());\n require(_l1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n require(_lineaToken != address(0), ZeroAddressNotAllowed());\n require(_dexSwapAdapter != address(0), ZeroAddressNotAllowed());\n\n _grantRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);\n _grantRole(INVOICE_SUBMITTER_ROLE, _invoiceSubmitter);\n _grantRole(BURNER_ROLE, _burner);\n\n lastInvoiceDate = _lastInvoiceDate;\n\n invoicePaymentReceiver = _invoicePaymentReceiver;\n tokenBridge = TokenBridge(_tokenBridge);\n messageService = L2MessageService(_messageService);\n l1LineaTokenBurner = _l1LineaTokenBurner;\n lineaToken = _lineaToken;\n dexSwapAdapter = _dexSwapAdapter;\n\n emit RollupRevenueVaultInitialized(\n _lastInvoiceDate,\n _invoicePaymentReceiver,\n _tokenBridge,\n _messageService,\n _l1LineaTokenBurner,\n _lineaToken,\n _dexSwapAdapter\n );\n }\n\n /**\n * @notice Submit invoice to pay to the designated receiver.\n * @param _startTimestamp Start of the period the invoice is covering.\n * @param _endTimestamp End of the period the invoice is covering.\n * @param _invoiceAmount New invoice amount.\n */\n function submitInvoice(\n uint256 _startTimestamp,\n uint256 _endTimestamp,\n uint256 _invoiceAmount\n ) external payable onlyRole(INVOICE_SUBMITTER_ROLE) {\n require(_startTimestamp == lastInvoiceDate + 1, TimestampsNotInSequence());\n require(_endTimestamp > _startTimestamp, EndTimestampMustBeGreaterThanStartTimestamp());\n require(_endTimestamp < block.timestamp, FutureInvoicesNotAllowed());\n require(_invoiceAmount != 0, ZeroInvoiceAmount());\n\n address payable receiver = payable(invoicePaymentReceiver);\n uint256 balanceAvailable = address(this).balance;\n\n uint256 totalAmountOwing = invoiceArrears + _invoiceAmount;\n uint256 amountToPay = (balanceAvailable < totalAmountOwing) ? balanceAvailable : totalAmountOwing;\n\n invoiceArrears = totalAmountOwing - amountToPay;\n lastInvoiceDate = _endTimestamp;\n\n if (amountToPay > 0) {\n (bool success, ) = receiver.call{ value: amountToPay }("");\n require(success, InvoiceTransferFailed());\n }\n\n emit InvoiceProcessed(receiver, _startTimestamp, _endTimestamp, amountToPay, _invoiceAmount);\n }\n\n /**\n * @notice Burns 20% of the ETH balance and uses the rest to buy LINEA tokens which are then bridged to L1 to be burned.\n * @param _swapData Encoded calldata for the DEX swap function.\n */\n function burnAndBridge(bytes calldata _swapData) external onlyRole(BURNER_ROLE) {\n _payArrears();\n\n uint256 minimumFee = messageService.minimumFeeInWei();\n\n if (address(this).balance > minimumFee) {\n uint256 balanceAvailable = address(this).balance - minimumFee;\n\n uint256 ethToBurn = (balanceAvailable * ETH_BURNT_PERCENTAGE) / 100;\n (bool success, ) = address(0).call{ value: ethToBurn }("");\n require(success, EthBurnFailed());\n\n (bool swapSuccess, ) = dexSwapAdapter.call{ value: balanceAvailable - ethToBurn }(_swapData);\n require(swapSuccess, DexSwapFailed());\n\n address lineaTokenAddress = lineaToken;\n TokenBridge tokenBridgeContract = tokenBridge;\n\n uint256 lineaTokenBalanceAfter = IERC20(lineaTokenAddress).balanceOf(address(this));\n\n IERC20(lineaTokenAddress).approve(address(tokenBridgeContract), lineaTokenBalanceAfter);\n\n tokenBridgeContract.bridgeToken{ value: minimumFee }(\n lineaTokenAddress,\n lineaTokenBalanceAfter,\n l1LineaTokenBurner\n );\n\n emit EthBurntSwappedAndBridged(ethToBurn, lineaTokenBalanceAfter);\n }\n }\n\n /**\n * @notice Update the invoice payment receiver.\n * @param _newInvoicePaymentReceiver New invoice payment receiver address.\n */\n function updateInvoicePaymentReceiver(address _newInvoicePaymentReceiver) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_newInvoicePaymentReceiver != address(0), ZeroAddressNotAllowed());\n\n address currentInvoicePaymentReceiver = invoicePaymentReceiver;\n require(_newInvoicePaymentReceiver != currentInvoicePaymentReceiver, ExistingAddressTheSame());\n\n invoicePaymentReceiver = _newInvoicePaymentReceiver;\n emit InvoicePaymentReceiverUpdated(currentInvoicePaymentReceiver, _newInvoicePaymentReceiver);\n }\n\n /**\n * @notice Update the invoice arrears.\n * @param _invoiceArrears New invoice arrears value.\n * @param _lastInvoiceDate Timestamp of the last invoice.\n */\n function updateInvoiceArrears(\n uint256 _invoiceArrears,\n uint256 _lastInvoiceDate\n ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_lastInvoiceDate >= lastInvoiceDate, InvoiceDateTooOld());\n require(_lastInvoiceDate < block.timestamp, FutureInvoicesNotAllowed());\n\n emit InvoiceArrearsUpdated(invoiceArrears, _invoiceArrears, lastInvoiceDate, _lastInvoiceDate);\n\n invoiceArrears = _invoiceArrears;\n lastInvoiceDate = _lastInvoiceDate;\n }\n\n /**\n * @notice Updates the address of the L1 LINEA token burner contract.\n * @param _newL1LineaTokenBurner Address of the new L1 LINEA token burner contract.\n */\n function updateL1LineaTokenBurner(address _newL1LineaTokenBurner) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_newL1LineaTokenBurner != address(0), ZeroAddressNotAllowed());\n\n address currentL1LineaTokenBurner = l1LineaTokenBurner;\n require(_newL1LineaTokenBurner != currentL1LineaTokenBurner, ExistingAddressTheSame());\n\n l1LineaTokenBurner = _newL1LineaTokenBurner;\n emit L1LineaTokenBurnerUpdated(currentL1LineaTokenBurner, _newL1LineaTokenBurner);\n }\n\n /**\n * @notice Updates the address of the DEX swap adapter contract.\n * @param _newDexSwapAdapter Address of the new DEX swap adapter contract.\n */\n function updateDexSwapAdapter(address _newDexSwapAdapter) external onlyRole(DEFAULT_ADMIN_ROLE) {\n require(_newDexSwapAdapter != address(0), ZeroAddressNotAllowed());\n\n    address currentDexSwapAdapter = dexSwapAdapter;\n    require(_newDexSwapAdapter != currentDexSwapAdapter, ExistingAddressTheSame());\n\n    dexSwapAdapter = _newDexSwapAdapter;\n    emit DexSwapAdapterUpdated(currentDexSwapAdapter, _newDexSwapAdapter);\n  }\n\n  /**\n   * @notice Fallback function - Receives Funds.\n   */\n  fallback() external payable {\n    require(msg.value > 0, NoEthSent());\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Receive function - Receives Funds.\n   */\n  receive() external payable {\n    require(msg.value > 0, NoEthSent());\n    emit EthReceived(msg.value);\n  }\n\n  /**\n   * @notice Pays off arrears where applicable and balance permits.\n   */\n  function _payArrears() internal {\n    uint256 balanceAvailable = address(this).balance;\n\n    uint256 totalAmountOwing = invoiceArrears;\n    uint256 amountToPay = (balanceAvailable < totalAmountOwing) ? balanceAvailable : totalAmountOwing;\n\n    if (amountToPay > 0) {\n      uint256 remainingArrears = totalAmountOwing - amountToPay;\n      invoiceArrears = remainingArrears;\n\n      (bool success, ) = payable(invoicePaymentReceiver).call{ value: amountToPay }("");\n      require(success, InvoiceTransferFailed());\n      emit ArrearsPaid(amountToPay, remainingArrears);\n    }\n  }\n}",
      "vulnerable_lines": [
        97,
        98,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        107,
        108,
        109,
        110,
        111,
        112,
        113,
        114,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        123,
        125,
        126,
        127,
        128,
        129,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        139,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        156,
        157,
        158,
        159,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168
      ],
      "vulnerable_functions": [
        "initializeRolesAndStorageVariables",
        "__RollupRevenueVault_init"
      ]
    },
    "context_files": [],
    "call_flow": "Admin executes `upgradeTo(V2_Implementation)` -> Window of opportunity opens post-upgrade but pre-reinitialization -> Attacker front-runs by calling `initializeRolesAndStorageVariables()` with malicious parameters -> Attacker is granted `DEFAULT_ADMIN_ROLE` and other roles -> Original admins and attacker now share privileges -> Attacker can execute malicious operations like updating the DEX to a malicious contract or submitting fake invoices.",
    "context_hint": "This vulnerability stems from the upgrade process for a proxy contract. The `reinitializer(2)` function is designed for upgrades but is left publicly callable after an upgrade transaction is completed. If the upgrade and reinitialization are not performed in a single, atomic transaction (using `upgradeToAndCall`), a front-running window is created. An attacker can watch the mempool for an `upgradeTo` transaction and immediately submit their own call to `initializeRolesAndStorageVariables`, granting themselves administrative roles. The problem is compounded because the internal `__RollupRevenueVault_init` function resets critical state variables (like `lastInvoiceDate`) and only grants new roles without revoking old ones, leading to both state corruption and privilege escalation where the attacker shares control with the legitimate admins.",
    "is_vulnerable": true,
    "expert_notes": "This is a classic vulnerability pattern in the management of upgradeable contracts, extending the well-known 'deploy-and-initialize' race condition to the 'upgrade-and-reinitialize' cycle. Key takeaways: 1) Upgrades must be atomic. The `upgradeTo` and re-initializer calls must be bundled into a single transaction (e.g., `upgradeToAndCall`) to prevent front-running. 2) Initialization logic should be version-specific. Re-using a broad initializer like `__RollupRevenueVault_init` for upgrades is dangerous as it can reset critical state and handle roles improperly. An upgrade should only touch the state it absolutely needs to. 3) Role management during upgrades must be explicit. To replace an admin, the old admin role should be revoked before the new one is granted. Additive role grants are a security risk. 4) The `reinitializer(N)` modifier from OpenZeppelin is a powerful tool, but it doesn't protect against front-running if the execution flow isn't atomic. This finding highlights that the security of upgradeable contracts depends heavily on secure off-chain deployment and upgrade procedures, not just the on-chain code itself."
  }
]