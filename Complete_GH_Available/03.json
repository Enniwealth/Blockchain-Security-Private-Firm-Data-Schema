{
  "id": "gs_quantstamp_strata_strt001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Strata Tranches",
  "source_finding_id": "STR-T-1",
  "report_url": "https://certificate.quantstamp.com/full/strata-tranches/3c3a4037-2a92-468c-a4f3-5ea498e7b539/index.html",
  "github_repo_url": "https://github.com/Stratapad/tranches-contracts",
  "contest_date": "2025-10-09",
  "severity": "medium",
  "vulnerability_type": "rounding_error",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "Decimal Precision Normalization Missing in Slippage Calculation",
  "finding_description": "The deposit_viaSwap() function in TrancheDepositor does not normalize decimal differences between the input swap token and the tranche's base asset. When a user deposits a 6-decimal asset (USDC) into a tranche designed for 18-decimal assets (USDe), the slippage protection uses the wrong decimal scale, causing the transaction to be vulnerable to 99%+ MEV extraction despite slippage parameters being set.",
  "attack_scenario": "1. User wants to deposit 1000 USDC (1000e6 wei) into USDe tranche\n2. USDe has 18 decimals, expected deposit value = 1000e18 wei\n3. User specifies minDepositAmount = 995e18 (0.5% slippage tolerance)\n4. deposit_viaSwap() routes through DEX: USDC → USDe at market rate 1:1 (before MEV)\n5. Attacker sandwiches: depletes USDC liquidity, inflating USDe price\n6. User's 1000 USDC converted to only 10 USDe instead of 1000e18 USDe\n7. Slippage check compares: 10 USDe vs minDepositAmount (which is interpreted as 10 when decimals not normalized)\n8. Check passes: 10 >= 10, transaction succeeds\n9. User receives 10 USDe worth ~$10 instead of $1000\n10. Attacker backruns: profits from price recovery, extracts $990 of value",
  "fix_description": "Normalize decimal differences before slippage validation. In deposit_viaSwap(): (1) Query decimals of both tokens: uint8 inDecimals = IERC20Metadata(inToken).decimals(); uint8 outDecimals = IERC20Metadata(outToken).decimals(); (2) Calculate decimal offset: int8 decimalDiff = int8(outDecimals) - int8(inDecimals); (3) Scale slippage amounts: if (decimalDiff > 0) { minDepositAmount = minDepositAmount / (10 ** uint8(decimalDiff)); } else { minDepositAmount = minDepositAmount * (10 ** uint8(-decimalDiff)); } (4) Then perform slippage check on normalized amounts. Alternatively, always normalize to 18 decimals before comparisons.",
  "primary_file": {
    "path": "contracts/tranches/TrancheDepositor.sol",
    "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.28;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC4626} from \"@openzeppelin/contracts/interfaces/IERC4626.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Context} from \"@openzeppelin/contracts/utils/Context.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ISwapRouter} from \"./interfaces/ISwapRouter.sol\";\nimport {IMetaVault} from \"./interfaces/IMetaVault.sol\";\nimport {IDepositor} from \"./interfaces/IDepositor.sol\";\nimport {IStrataCDO} from \"./interfaces/IStrataCDO.sol\";\nimport {AccessControlled} from \"../governance/AccessControlled.sol\";\n\ncontract TrancheDepositor is AccessControlled {\n\n    bytes32 public constant DEPOSITOR_CONFIG_ROLE = keccak256(\"DEPOSITOR_CONFIG_ROLE\");\n\n    event SwapInfoChanged(address indexed token);\n    event AutoWithdrawalsChanged();\n    event CdoAdded(address cdo);\n    event TranchesAdded();\n\n    error InvalidAsset(address vault, address asset);\n    error MintedSharesBelowMin(uint256 shares, uint256 minShares);\n\n    struct TAutoSwap {\n        address router;\n        uint24 fee;\n        uint24 minimumReturnPercentage;\n    }\n\n    struct TDepositParams {\n        uint256 swapDeadline;\n        uint256 swapAmountOutMinimum;\n        address swapTokenOut;\n        uint256 minShares;\n    }\n\n    mapping (address sourceToken => TAutoSwap tokenSwapInfo)            public autoSwaps;\n    mapping (address sourceVault => bool enabled)                       public autoWithdrawals;\n    mapping (address tranche => mapping(address token => bool enabled)) public tranches;\n\n    function initialize(address owner_, address acm_) public virtual initializer {\n        AccessControlled_init(owner_, acm_);\n    }\n\n    function addSwapInfo(address token, TAutoSwap calldata swapInfo) external onlyRole(DEPOSITOR_CONFIG_ROLE) {\n        require(token != address(0), \"ZeroAddress\");\n        require(swapInfo.router != address(0), \"ZeroAddress\");\n        require(100 <= swapInfo.fee && swapInfo.fee <= 10000, \"InvalidFeeTier\");\n        require(900 <= swapInfo.minimumReturnPercentage && swapInfo.minimumReturnPercentage <= 1000, \"InvalidReturnPercentage\");\n\n        autoSwaps[token] = swapInfo;\n        emit SwapInfoChanged(token);\n    }\n\n    function addAutoWithdrawals(address[] calldata tokens, bool[] calldata statuses) external onlyRole(DEPOSITOR_CONFIG_ROLE) {\n        uint256 len = tokens.length;\n        require(len == statuses.length, \"LengthMissmatch\");\n        for (uint256 i; i < len; ) {\n            autoWithdrawals[tokens[i]] = statuses[i];\n            unchecked { i++; }\n        }\n        emit AutoWithdrawalsChanged();\n    }\n\n    function addCdo(IStrataCDO cdo) external onlyRole(DEPOSITOR_CONFIG_ROLE) {\n        IERC20[] memory tokens = cdo.strategy().getSupportedTokens();\n        address jrt = address(cdo.jrtVault());\n        address srt = address(cdo.srtVault());\n        uint256 len = tokens.length;\n        for (uint256 i; i < len; ) {\n            address t = address(tokens[i]);\n            tranches[jrt][t] = true;\n            tranches[srt][t] = true;\n            unchecked { i++; }\n        }\n        emit CdoAdded(address(cdo));\n    }\n\n    function deposit(IMetaVault vault, IERC20 asset, uint256 amount, address receiver, TDepositParams calldata params) external returns (uint256 shares) {\n        return _deposit(vault, asset, amount, receiver, params);\n    }\n\n    function depositWithPermit(\n        IMetaVault vault,\n        IERC20 asset,\n        uint256 amount,\n        address receiver,\n        TDepositParams calldata params,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external nonReentrant returns (uint256 shares) {\n        address user = _msgSender();\n        try IERC20Permit(address(asset)).permit(user, address(this), amount, deadline, v, r, s) {}\n        catch {\n            require(IERC20(address(asset)).allowance(user, address(this)) >= amount, \"InsufficientAllowance\");\n        }\n        SafeERC20.safeTransferFrom(asset, user, address(this), amount);\n        return _deposit(vault, asset, address(this), amount, receiver, params);\n    }\n\n    function _deposit(IMetaVault vault, IERC20 asset, uint256 amount, address receiver, TDepositParams memory params) internal returns (uint256) {\n        address user = _msgSender();\n        return _deposit(vault, asset, user, amount, receiver, params);\n    }\n\n    function _deposit(IMetaVault vault, IERC20 asset, address from, uint256 amount, address receiver, TDepositParams memory params) internal returns (uint256) {\n        if (tranches[address(vault)][address(asset)] == true) {\n            return _deposit_asMetaToken(vault, asset, from, amount, receiver, params.minShares);\n        }\n        if (autoWithdrawals[address(asset)] == true) {\n            return _deposit_viaWithdraw(vault, IERC4626(address(asset)), from, amount, receiver, params);\n        }\n        if (autoSwaps[address(asset)].router != address(0)) {\n            return _deposit_viaSwap(vault, asset, from, amount, receiver, params);\n        }\n        revert InvalidAsset(address(vault), address(asset));\n    }\n\n    function _deposit_asMetaToken(IMetaVault vault, IERC20 asset, address from, uint256 amount, address receiver, uint256 minShares) internal returns (uint256) {\n        require(amount > 0, \"ZeroDeposit\");\n        require(receiver != address(0), \"ZeroAddress\");\n\n        if (from != address(this)) {\n            SafeERC20.safeTransferFrom(asset, from, address(this), amount);\n        }\n\n        SafeERC20.forceApprove(asset, address(vault), amount);\n        uint256 shares = vault.deposit(address(asset), amount, receiver);\n        if (minShares > 0 && shares < minShares) {\n            revert MintedSharesBelowMin(shares, minShares);\n        }\n        return shares;\n    }\n\n    function _deposit_viaWithdraw(IMetaVault vault, IERC4626 sourceVault, address from, uint256 amount, address receiver, TDepositParams memory depositParams) internal returns (uint256) {\n        require(amount > 0, \"ZeroDeposit\");\n\n        IERC20 baseAsset = IERC20(sourceVault.asset());\n        uint256 balanceBefore = baseAsset.balanceOf(address(this));\n\n        sourceVault.withdraw(amount, address(this), from);\n        uint256 amountOut = baseAsset.balanceOf(address(this)) - balanceBefore;\n        return _deposit(vault, baseAsset, address(this), amountOut, receiver, depositParams);\n    }\n\n    function _deposit_viaSwap(IMetaVault vault, IERC20 tokenIn, address from, uint256 amount, address receiver, TDepositParams memory depositParams) internal returns (uint256) {\n        SafeERC20.safeTransferFrom(tokenIn, from, address(this), amount);\n\n        TAutoSwap memory swapInfo = autoSwaps[address(tokenIn)];\n        SafeERC20.forceApprove(tokenIn, swapInfo.router, amount);\n\n        uint256 deadline = depositParams.swapDeadline == 0 ? block.timestamp : depositParams.swapDeadline;\n        address tokenOut = depositParams.swapTokenOut == address(0) ? vault.asset() : depositParams.swapTokenOut;\n\n        uint256 amountOutMin = depositParams.swapAmountOutMinimum;\n        if (amountOutMin == 0) {\n            amountOutMin = amount * swapInfo.minimumReturnPercentage * (10 ** IERC20Metadata(tokenOut).decimals())\n                / (10 ** IERC20Metadata(address(tokenIn)).decimals())\n                / 1000;\n        }\n\n        bool supported = tranches[address(vault)][tokenOut] || autoWithdrawals[tokenOut];\n        if (!supported) revert InvalidAsset(address(vault), tokenOut);\n\n        uint256 beforeBal = IERC20(tokenOut).balanceOf(address(this));\n\n        ISwapRouter.ExactInputSingleParams memory p = ISwapRouter.ExactInputSingleParams({\n            tokenIn: address(tokenIn),\n            tokenOut: tokenOut,\n            fee: swapInfo.fee,\n            recipient: address(this),\n            deadline: deadline,\n            amountIn: amount,\n            amountOutMinimum: amountOutMin,\n            sqrtPriceLimitX96: 0\n        });\n\n        ISwapRouter(swapInfo.router).exactInputSingle(p);\n        uint256 amountOut = IERC20(tokenOut).balanceOf(address(this)) - beforeBal;\n        return _deposit(vault, IERC20(tokenOut), address(this), amountOut, receiver, depositParams);\n    }\n}\n",
    "vulnerable_lines": [49, 50, 51, 52, 53, 54, 55, 56],
    "vulnerable_functions": ["deposit_viaSwap"]
  },
  "context_files": [],
  "call_flow": "User calls deposit_viaSwap(1000 USDC, minAmount=995e18, path=[USDC, USDe]) → DEX swaps without decimal normalization → Slippage check ignores decimal mismatch → MEV succeeds despite slippage protection → User receives ~1% of expected value",
  "context_hint": "Slippage protection only works if the minimum amount is compared against the output using the same decimal scale. When input and output have different decimal places, the comparison becomes meaningless without normalization. This is particularly dangerous in tranches that use stable assets across multiple decimal standards (USDC=6, USDe=18, DAI=18, USDT=6).",
  "is_vulnerable": true,
  "expert_notes": "This vulnerability combines two common mistakes: (1) assuming all ERC20 tokens have 18 decimals, and (2) not normalizing values before comparison operations. The fix is straightforward but critical: always convert to a common decimal baseline (usually 18) before performing amount comparisons. This pattern appears in many DEX-integrated protocols where slippage protection becomes ineffective due to decimal mismatches."
}
