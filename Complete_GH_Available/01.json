[{
  "id": "gs_quantstamp_startale_sta001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Startale Stablecoin Vaults",
  "source_finding_id": "STA-1",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  "severity": "high",
  "vulnerability_type": "economic_attack",
  "difficulty_tier": 4,
  "context_level": "cross_contract",
  "finding_title": "Leveraged TVL Manipulation via Sandwich Attack on distribute()",
  "finding_description": "The RewardRedistributor's distribute() function reads the sUSDSC vault's totalAssets() at execution time to calculate yield splits. An attacker can build a leveraged position in the sUSDSC vault using a lending pool (e.g., Aave-style), sandwich the distribute() transaction, and capture disproportionate yield while stealing from EarnVault users. The attack uses borrowed USDSC as collateral in recursive loops to artificially inflate sUSDSC's TVL, manipulating the yield distribution formula.",
  "attack_scenario": "1. Attacker detects operator's distribute() transaction in mempool\n2. Attacker frontruns with leverage loop (5 iterations): Deposit 1M USDSC → get 1M sUSDSC → borrow 900k USDSC. Deposit 900k → get 900k sUSDSC → borrow 810k. Continue until 4.095M total deposited using 3.685M borrowed + 1M original capital\n3. This inflates sUSDSC vault from 10M to 14.095M USDSC\n4. Operator's distribute() executes with manipulated TVL: Normal split would be toEarn=316,667 USDSC, toOn=633,333 USDSC. Manipulated split: toEarn=248,752 USDSC (lost 67,915), toOn=701,248 USDSC (gained 67,915). Attacker's 4.095M shares (29% of vault) capture 203,693 USDSC of inflated yield\n5. Attacker backruns: Redeem 4.095M shares for 4,298,693 USDSC, repay 3.685M loan (interest ~1.4 USDSC for 2 minutes), net profit 203,191 USDSC per attack\n6. Attack repeatable 6 times daily = 1.2M USDSC profit/day = 445M USDSC profit/year (44,493% APY)",
  "fix_description": "Implement snapshot-based TVL mechanism to prevent same-block manipulation. In RewardRedistributor.sol: (1) Add storage: uint256 public lastSUSDSCTVL; uint256 public lastSnapshotBlock; (2) Add function snapshotTVL() external onlyRole(OPERATOR_ROLE) { lastSUSDSCTVL = susdscVault.totalAssets(); lastSnapshotBlock = block.number; } (3) In distribute() require(lastSnapshotBlock == block.number - 1, 'Must snapshot in previous block') and use lastSUSDSCTVL instead of susdscVault.totalAssets() (4) Operator workflow: Call snapshotTVL() in block N, then call distribute() in block N+1. This forces attacker to hold leveraged position for minimum 1 full block (~12 seconds), making attack 100x more expensive (5) For defense-in-depth, add 1-hour withdrawal cooldown to sUSDSC vault and minimum time post-deposit during which funds cannot be withdrawn",
  "primary_file": {
    "path": "src/distributor/RewardRedistributor.sol",
    "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.30; import {IRewardRedistributorEventsAndErrors} from '../interfaces/distributor/IRewardRedistributorEventsAndErrors.sol'; import {IEarnVault} from '../interfaces/vaults/earn/IEarnVault.sol'; import {AccessControl} from 'lib/openzeppelin-contracts/contracts/access/AccessControl.sol'; import {IAccessControl} from 'lib/openzeppelin-contracts/contracts/access/IAccessControl.sol'; import {AccessControlEnumerable} from 'lib/openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol'; import {IERC4626} from 'lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol'; import {IERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol'; import {SafeERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol'; import {Pausable} from 'lib/openzeppelin-contracts/contracts/utils/Pausable.sol'; import {ReentrancyGuardTransient} from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuardTransient.sol'; import {IMYieldToOne} from 'm-extensions/projects/yieldToOne/IMYieldToOne.sol'; /// @title RewardRedistributor /// @notice Pulls freshly-minted USDSC yield from the M0 extension, applies an optional fee to Startale, then allocates the **net** yield to eligible cohorts by their share of the **base supply** S (supply before this mint): - EarnVault (checkbox OFF) receives `toEarn = Y_net * T_earn / S_base` - sUSDSC (ERC-4626) vault (checkbox ON) receives `toOn = Y_net * T_yield / S_base` - Remainder (wallets/LP/points + rounding) → Startale (`toStartaleExtra`) /// @dev Uses per-cohort integer carry to remove long-run rounding bias. Delivers to EarnVault with transfer→onYield ordering to satisfy its funding invariant. Delivers to sUSDSC via raw transfer, which raises PPS in ERC-4626. /// Architecture: - USDSC_ADDRESS: Single USDSC token address that implements both IERC20 and IMYieldToOne interfaces - Cast to IERC20 for transfers and supply queries (totalSupply, safeTransfer) - Cast to IMYieldToOne for yield operations (claimYield, yield) contract RewardRedistributor is IRewardRedistributorEventsAndErrors, AccessControlEnumerable, Pausable, ReentrancyGuardTransient { using SafeERC20 for IERC20; /// Keeper allowed to call distribute() bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE'); /// @notice Maximum fee allowed (basis points). uint16 public constant MAX_FEE_BPS = 100; // 100 bps max (1%) /// @notice Basis points denominator (10000 = 100%). /// @dev Basis Points (bps) are a unit of measurement for percentages: - 1 bps = 0.01% = 1/10,000 - 10 bps = 0.1% = 10/10,000 - 10,000 bps = 100% = 10,000/10,000 /// Fee calculation formula: `feeAmount = (amount × fee_bps) / BPS_DENOMINATOR` /// Example: For 30 bps (0.3%) fee on 1,000,000 tokens: `feeAmount = (1,000,000 × 30) / 10,000 = 3,000 tokens` Verification: 3,000 / 1,000,000 = 0.003 = 0.3% ✓ uint256 public constant BPS_DENOMINATOR = 10_000; /// @notice USDSC token address - used for both transfers/supply queries (IERC20) and yield operations (IMYieldToOne). /// @dev The same address implements both IERC20 and IMYieldToOne interfaces. address public immutable USDSC_ADDRESS; /// @notice Treasury recipient for fees and ineligible cohort yield. address public treasury; /// @notice Earn vault (checkbox OFF) that indexes yield via {IEarnVault.onYield}. IEarnVault public earnVault; /// @notice sUSDSC (ERC-4626) vault that receives yield via raw transfers (no minting). IERC4626 public susdscVault; /// @notice Fee on newly minted yield expressed in basis points. /// @dev See {BPS_DENOMINATOR} for basis points explanation. Examples: 30 bps = 0.3%, 100 bps = 1%, 1000 bps = 10%. Initial value: 30 bps (0.3%). uint16 public fee_on_yield_bps = 30; /// @dev Carry accumulator for EarnVault share calculations across epochs. uint256 private carryEarn; /// @dev Carry accumulator for sUSDSC share calculations across epochs. uint256 private carryOn; /// @dev Latest sUSDSC TVL snapshot. uint256 public lastSusdscTVL; /// @dev Latest snapshot block number. uint256 public lastSnapshotBlockNumber; /// @dev Latest snapshot timestamp. uint256 public lastSnapshotTimestamp; /// @dev Maximum age for snapshot validity (e.g., 4 hours). uint256 public snapshotMaxAge = 4 hours; /// @notice Initializes the redistributor. /// @param usdscAddress USDSC token address (implements both IERC20 and IMYieldToOne interfaces). /// @param treasuryAddr Treasury recipient. /// @param earnV EarnVault (checkbox OFF) recipient. /// @param sVault sUSDSC ERC-4626 vault (checkbox ON) recipient. /// @param admin Admin address; receives DEFAULT_ADMIN_ROLE. /// @param keeper Keeper address; receives OPERATOR_ROLE (can call distribute()). constructor(address usdscAddress, address treasuryAddr, IEarnVault earnV, IERC4626 sVault, address admin, address keeper) { _validateUsdscContract(usdscAddress); if (treasuryAddr == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('treasury'); if (address(earnV) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('earnVault'); if (address(sVault) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('susdscVault'); if (admin == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('admin'); if (keeper == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('keeper'); USDSC_ADDRESS = usdscAddress; treasury = treasuryAddr; earnVault = earnV; susdscVault = sVault; _grantRole(DEFAULT_ADMIN_ROLE, admin); _grantRole(OPERATOR_ROLE, keeper); } function _validateUsdscContract(address usdscAddress) internal view { if (usdscAddress == address(0)) { revert IRewardRedistributorEventsAndErrors.ZeroAddress('USDSC_ADDRESS'); } // Check that the address is a contract if (usdscAddress.code.length == 0) revert InvalidUSDSC('NOT_CONTRACT'); // Validate that the contract implements IERC20 try IERC20(usdscAddress).totalSupply() returns (uint256) {} catch { revert IRewardRedistributorEventsAndErrors.InvalidUSDSC('IERC20'); } // Validate that the contract implements IMYieldToOne try IMYieldToOne(usdscAddress).yield() returns (uint256) {} catch { revert IRewardRedistributorEventsAndErrors.InvalidUSDSC('IMYieldToOne'); } } /// @notice Updates Treasury address. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param treasuryAddr New Treasury address. function setTreasury(address treasuryAddr) external onlyRole(DEFAULT_ADMIN_ROLE) { if (treasuryAddr == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('treasury'); treasury = treasuryAddr; emit IRewardRedistributorEventsAndErrors.TreasuryUpdated(treasuryAddr); } /// @notice Updates EarnVault address. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param earnV New EarnVault (OFF) address. function setEarnVault(IEarnVault earnV) external onlyRole(DEFAULT_ADMIN_ROLE) { if (address(earnV) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('earnVault'); earnVault = earnV; emit IRewardRedistributorEventsAndErrors.EarnVaultUpdated(address(earnV)); } /// @notice Updates sUSDSC vault address. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param sVault New sUSDSC ERC-4626 vault (ON) address. function setSusdscVault(IERC4626 sVault) external onlyRole(DEFAULT_ADMIN_ROLE) { if (address(sVault) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('susdscVault'); susdscVault = sVault; emit IRewardRedistributorEventsAndErrors.SusdscVaultUpdated(address(sVault)); } /// @notice Updates fee on yield. /// @dev Fee is capped by {MAX_FEE_BPS}. Callable by DEFAULT_ADMIN_ROLE. /// @param newFeeBps New fee on yield in bps (≤ MAX_FEE_BPS). function setFeeBps(uint16 newFeeBps) external onlyRole(DEFAULT_ADMIN_ROLE) { if (newFeeBps > MAX_FEE_BPS) revert IRewardRedistributorEventsAndErrors.FeeTooHigh(newFeeBps, MAX_FEE_BPS); fee_on_yield_bps = newFeeBps; emit IRewardRedistributorEventsAndErrors.FeeUpdated(newFeeBps); } /// @notice Updates the maximum age for snapshot validity. /// @param newSnapshotMaxAge New snapshot maximum age value. function setSnapshotMaxAge(uint256 newSnapshotMaxAge) external onlyRole(DEFAULT_ADMIN_ROLE) { if (newSnapshotMaxAge < 1 minutes) { revert IRewardRedistributorEventsAndErrors.InvalidSnapshotMaxAge(newSnapshotMaxAge, 1 minutes); } if (newSnapshotMaxAge > 7 days) { revert IRewardRedistributorEventsAndErrors.InvalidSnapshotMaxAge(newSnapshotMaxAge, 7 days); } snapshotMaxAge = newSnapshotMaxAge; emit IRewardRedistributorEventsAndErrors.SnapshotMaxAgeUpdated(newSnapshotMaxAge); } /// @notice Capture sUSDSC vault TVL for next distribution /// @dev Must be called in block N before distribute() in block N+x (a few blocks apart/ couple of minutes apart) /// @custom:security Prevents same-block TVL manipulation attacks function snapshotSusdscTVL() external onlyRole(OPERATOR_ROLE) whenNotPaused { lastSusdscTVL = susdscVault.totalAssets(); lastSnapshotTimestamp = block.timestamp; lastSnapshotBlockNumber = block.number; emit IRewardRedistributorEventsAndErrors.SusdscTVLSnapshotCaptured(lastSusdscTVL, lastSnapshotTimestamp, lastSnapshotBlockNumber); } /// @notice Pauses or unpauses the contract. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param p True to pause, false to unpause. function pause(bool p) external onlyRole(DEFAULT_ADMIN_ROLE) { p ? _pause() : _unpause(); } /// @notice Recovers donations made to the contract to the treasury. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @notice The invariant holds that before and after distribute the usdsc balance of address(this) is the same. /// @notice The inflow during claimYield happens in the distribute() gets distributed whole leaving no balance. /// @notice Hence we can safely assumy at any point in time usdscbalance of address(this) is from the intentional/accidental donations. /// @custom:security nonReentrant. function recoverDonations() external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant { uint256 balance = IERC20(USDSC_ADDRESS).balanceOf(address(this)); if (balance > 0) { IERC20(USDSC_ADDRESS).safeTransfer(treasury, balance); emit IRewardRedistributorEventsAndErrors.DonationsRecovered(balance); } } /// @notice Prevents renunciation of the last DEFAULT_ADMIN_ROLE only. /// @dev Overrides AccessControl's renounceRole to ensure at least one admin remains. Other roles (e.g., OPERATOR_ROLE) can still be renounced freely. Admin can renounce their role only if there are other admins remaining. /// @param role The role to renounce. /// @param callerConfirmation The address of the caller confirming renunciation. function renounceRole(bytes32 role, address callerConfirmation) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE) { // Only check last admin protection if the caller actually has the role if (hasRole(DEFAULT_ADMIN_ROLE, callerConfirmation) && getRoleMemberCount(DEFAULT_ADMIN_ROLE) <= 1) { revert IRewardRedistributorEventsAndErrors.CannotRemoveLastAdmin(); } } super.renounceRole(role, callerConfirmation); } /// @notice Prevents revocation of the last DEFAULT_ADMIN_ROLE only. /// @dev Overrides AccessControl's revokeRole to ensure at least one admin remains. Non-admin roles (e.g., OPERATOR_ROLE) can be revoked freely. Multiple admins can be revoked as long as at least one admin remains. Only an account with the admin role can revoke roles from others. /// @param role The role to revoke. /// @param account The account from which to revoke the role. function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE) { // Only check last admin protection if the account actually has the role if (hasRole(DEFAULT_ADMIN_ROLE, account) && getRoleMemberCount(DEFAULT_ADMIN_ROLE) <= 1) { revert IRewardRedistributorEventsAndErrors.CannotRemoveLastAdmin(); } } super.revokeRole(role, account); } /// @notice Validates that this contract is still the yield recipient on the extension. /// @dev Reverts if the yield recipient has changed. function _validateYieldRecipient() internal view { address currentRecipient = IMYieldToOne(USDSC_ADDRESS).yieldRecipient(); if (currentRecipient != address(this)) { revert IRewardRedistributorEventsAndErrors.YieldRecipientChanged(currentRecipient); } } /** * @notice Validates that the snapshot is valid. * @dev Performs the following checks: - Ensures a snapshot has been taken (timestamp and block number are non-zero). - Verifies the snapshot is from a previous block (prevents same-block manipulation). - Ensures the snapshot is not too old (must be within `snapshotMaxAge`). Reverts with appropriate errors if any check fails. */ function _validateSnapShotAge() internal view { if (lastSnapshotTimestamp == 0) { revert IRewardRedistributorEventsAndErrors.LastSnapshotInvalid(); } if (lastSnapshotBlockNumber == 0) { revert IRewardRedistributorEventsAndErrors.LastSnapshotInvalid(); } if (block.number - lastSnapshotBlockNumber < 1) { revert IRewardRedistributorEventsAndErrors.MustSnapshotInPreviousBlocks(lastSnapshotBlockNumber, block.number); } // Check maximum age (snapshot must not be too old) if (block.timestamp - lastSnapshotTimestamp > snapshotMaxAge) { revert IRewardRedistributorEventsAndErrors.SnapshotTooOld(lastSnapshotTimestamp, block.timestamp, snapshotMaxAge); } } /// @notice Claims pending USDSC yield from the extension and distributes it per policy. /// @dev Sequence: 1) Record `balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this))`. 2) `minted = IMYieldToOne(USDSC_ADDRESS).claimYield()` mints fresh USDSC to this contract (must be yieldRecipient). 3) Calculate `gross = balanceBefore + minted` to handle both normal flow and external claimYield() calls. 4) `feeToStartale = gross * fee_on_yield_bps / 10_000`. 5) Compute `S_base = IERC20(USDSC_ADDRESS).totalSupply() - minted` (supply **before** this mint). 6) Read TVLs: `T_earn = earnVault.totalPrincipal()`, `T_yield = lastSusdscTVL` (snapshot TVL). 7) Allocate net using carries: `toEarn = floor((net*T_earn + carryEarn)/S_base)`, `carryEarn = (net*T_earn + carryEarn) % S_base` `toOn = floor((net*T_yield + carryOn)/S_base)`, `carryOn = (net*T_yield + carryOn) % S_base` `toStartaleExtra = net - (toEarn + toOn)` 8) Transfers: - Startale: `feeToStartale + toStartaleExtra` - EarnVault: transfer `toEarn` **then** call `earnVault.onYield(toEarn)` - sUSDSC: transfer `toOn` (PPS rises) /// @custom:security nonReentrant and Pausable. function distribute() external whenNotPaused onlyRole(OPERATOR_ROLE) nonReentrant { _validateYieldRecipient(); _validateSnapShotAge(); // Note: claimYield() on USDSCextension is not public method anymore and is gated by trusted actors. // Hence any other accruals before/after distribute are pure donations and not newly minted. uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield(); if (minted == 0) return; uint256 feeToStartale; uint256 toEarn; uint256 toOn; uint256 toStartaleExtra; uint256 S_base; uint256 T_earn; uint256 T_yield; (feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield) = _calculateSplit(minted, true, false); if (S_base == 0) { if (feeToStartale > 0) IERC20(USDSC_ADDRESS).safeTransfer(treasury, feeToStartale); if (toStartaleExtra > 0) IERC20(USDSC_ADDRESS).safeTransfer(treasury, toStartaleExtra); emit Distributed(minted, feeToStartale, 0, 0, toStartaleExtra, 0, 0, 0); return; } { uint256 net = minted - feeToStartale; uint256 numEarn = net * T_earn + carryEarn; toEarn = numEarn / S_base; carryEarn = numEarn % S_base; uint256 numOn = net * T_yield + carryOn; toOn = numOn / S_base; carryOn = numOn % S_base; toStartaleExtra = net - (toEarn + toOn); } uint256 startaleTotal = feeToStartale + toStartaleExtra; // Note: We may split it into two transfers to two different addresses. if (startaleTotal > 0) IERC20(USDSC_ADDRESS).safeTransfer(treasury, startaleTotal); if (toEarn > 0) { IERC20(USDSC_ADDRESS).safeTransfer(address(earnVault), toEarn); earnVault.onYield(toEarn); } if (toOn > 0) { IERC20(USDSC_ADDRESS).safeTransfer(address(susdscVault), toOn); } emit Distributed(minted, feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield); // balanceBefore and balanceAfter distribute would be the same. } /// @notice Preview a split for a hypothetical minted amount. /// @dev Pure math helper (no state/carry usage). Does **not** call the extension. /// @param minted Hypothetical fresh yield to allocate (pre-fee). /// @return feeToStartale Fee portion (bps of `minted`) to Startale. /// @return toEarn Portion of net allocated to EarnVault (OFF) **without carry**. /// @return toOn Portion of net allocated to sUSDSC (ON) **without carry**. /// @return toStartaleExtra Remainder of net: ineligible cohorts + rounding. /// @return S_base Total USDSC supply **before** this mint (= totalSupply - minted if ≥0). /// @return T_earn EarnVault TVL used for allocation (`earnVault.totalPrincipal()`). /// @return T_yield sUSDSCVault TVL used for allocation (`susdscVault.totalAssets()`). function previewSplit(uint256 minted) external view returns (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra, uint256 S_base, uint256 T_earn, uint256 T_yield) { return _calculateSplit(minted, false, true); } /// @notice Preview a split using the extension's **current pending** yield (no carries). /// @dev Reads {IUSDSCMExtension.yield}. Pure preview; does not mutate. /// @return couldBeMinted Pending fresh yield on the extension at this moment. /// @return feeToStartale Fee portion (bps of `couldBeMinted`) to Startale. /// @return toEarn Portion of net to EarnVault (OFF) **without carry**. /// @return toOn Portion of net to sUSDSC (ON) **without carry**. /// @return",
    "vulnerable_lines": [108, 109, 110, 113, 120, 143, 144, 145, 147, 148, 149, 155, 156, 157, 158, 159, 160, 161, 162],
    "vulnerable_functions": ["distribute", "_calculateSplit"]
  },
  "context_files": [
    {
      "path": "src/vaults/4626/SUSDSCVaultUpgradable.sol",
      "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.30; import {ISUSDSCVaultEventsAndErrors} from '../../interfaces/vaults/4626/ISUSDSCVaultEventsAndErrors.sol'; import {AccessControlUpgradeable} from '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol'; import {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol'; import {ERC20Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol'; import {ERC4626Upgradeable} from '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol'; import {PausableUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol'; import {ReentrancyGuardTransientUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol'; import {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol'; import {SafeTransferLib} from 'solady/utils/SafeTransferLib.sol'; /// @title sUSDSCVault — ERC-4626: deposit USDSC → mint sUSDSC; external asset inflows lift PPS contract SUSDSCVaultUpgradable is Initializable, ERC20Upgradeable, ERC4626Upgradeable, AccessControlUpgradeable, PausableUpgradeable, ReentrancyGuardTransientUpgradeable, ISUSDSCVaultEventsAndErrors { using SafeTransferLib for IERC20; bytes32 public constant PAUSER_ROLE = keccak256('PAUSER_ROLE'); /// @custom:oz-upgrades-unsafe-allow constructor constructor() { _disableInitializers(); } /// @notice Initialize the vault with USDSC asset and admin roles /// @param usdsc The USDSC token address to use as the vault asset /// @param admin The address that will have admin role /// @param pauser The address that will have pauser role function initialize(IERC20 usdsc, address admin, address pauser) public initializer { if (address(usdsc) == address(0)) revert ISUSDSCVaultEventsAndErrors.AdminCannotBeZeroAddress(); if (admin == address(0)) revert ISUSDSCVaultEventsAndErrors.AdminCannotBeZeroAddress(); if (pauser == address(0)) revert ISUSDSCVaultEventsAndErrors.PauserCannotBeZeroAddress(); __ERC20_init('Staked Startale USD', 'sUSDSC'); __ERC4626_init(usdsc); __AccessControl_init(); __Pausable_init(); __ReentrancyGuardTransient_init(); _grantRole(DEFAULT_ADMIN_ROLE, admin); _grantRole(PAUSER_ROLE, pauser); } function deposit(uint256 assets, address receiver) public override whenNotPaused nonReentrant returns (uint256 shares) { return super.deposit(assets, receiver); } function mint(uint256 shares, address receiver) public override whenNotPaused nonReentrant returns (uint256 assets) { return super.mint(shares, receiver); } function withdraw(uint256 assets, address receiver, address owner) public override whenNotPaused nonReentrant returns (uint256 shares) { return super.withdraw(assets, receiver, owner); } function redeem(uint256 shares, address receiver, address owner) public override whenNotPaused nonReentrant returns (uint256 assets) { return super.redeem(shares, receiver, owner); } function pause(bool p) external onlyRole(PAUSER_ROLE) { p ? _pause() : _unpause(); } function recoverNonAssetERC20(address token, address to, uint256 amount) external onlyRole(DEFAULT_ADMIN_ROLE) { if (token == asset()) revert ISUSDSCVaultEventsAndErrors.TokenCannotBeUSDSC(); if (token == address(0)) revert ISUSDSCVaultEventsAndErrors.TokenCannotBeZeroAddress(); if (to == address(0)) revert ISUSDSCVaultEventsAndErrors.ToCannotBeZeroAddress(); if (amount == 0) revert ISUSDSCVaultEventsAndErrors.AmountCannotBeZero(); SafeTransferLib.safeTransfer(token, to, amount); } function decimals() public view override(ERC20Upgradeable, ERC4626Upgradeable) returns (uint8) { return super.decimals(); } function _decimalsOffset() internal pure override returns (uint8) { return 0; } }",
      "relevance": "The sUSDSC vault's totalAssets() is read at execution time in distribute(), allowing same-block manipulation. No time-delayed snapshot is used."
    }
  ],
  "call_flow": "Attacker.detectMempool() → Attacker.frontRun() → Attacker.borrowAndDeposit() → inflate sUSDSC.totalAssets() → Operator.distribute() → RewardDistributor.distribute() reads spot TVL → manipulated yield split → Attacker.backRun() → Attacker.repayAndProfit()",
  "context_hint": "ERC4626 share accounting is fair - attacker gets correct shares at deposit and correct assets at redemption. The vulnerability exists because distribute() uses spot totalAssets() instead of a time-delayed snapshot. This is a sophisticated economic attack that requires understanding both lending pool mechanics and yield distribution formulas. The attacker can execute this profitably multiple times daily with modest capital due to Aave-style 90% LTV.",
  "is_vulnerable": true,
  "expert_notes": "This vulnerability is similar to the Curve donation attack but exploits the yield distribution mechanism rather than share accounting. The key insight is that RewardRedistributor trusts the sUSDSC vault's spot totalAssets() without considering that TVL can be manipulated within the same transaction via flashloans or multi-step leveraging. The fix requires understanding both ERC4626 mechanics and MEV attack vectors."
},

{
  "id": "gs_quantstamp_startale_sta002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Startale Stablecoin Vaults",
  "source_finding_id": "STA-2",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  "severity": "high",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  "finding_title": "Missing Boost Rewards Settlement During Deposit",
  "finding_description": "The deposit() and depositWithPermit() functions in EarnVaultUpgradeable call _settleRewards() for USDSC rewards but fail to call _settleBoost() before increasing the user's principal. This allows users to double-dip on boost rewards by depositing a second time without settling accrued boost index, causing the subsequent distributions to apply stale index deltas to increased principal amounts.",
  "attack_scenario": "1. User deposits 100k USDSC, receives 100k vault shares, userBoostIndex set to current globalBoostIndex (e.g., 1e18)\n2. Time passes, globalBoostIndex increases to 1.2e18 due to distributions\n3. User calls deposit(100k USDSC) again\n4. Vault calls _settleRewards() for USDSC yield (accrued correctly)\n5. Vault FAILS to call _settleBoost() - userBoostIndex still 1e18\n6. User's principal increased from 100k to 200k shares\n7. Next boost distribution: newYield = 200k * (1.2e18 - 1e18) / 1e18 = 200k * 0.2 = 40k boost tokens\n8. Should have been: settled 100k * 0.2 = 20k, then new principal has 0 accrual = 20k total\n9. User receives 40k instead of 20k, gaining 20k unearned boost rewards\n10. Repeated deposits compound the over-allocation until vault reserves are depleted",
  "fix_description": "Add _settleBoost() call before principal modification in both deposit functions. The correct pattern (shown in withdraw) is: (1) Call _settleRewards() for USDSC (2) Call _settleBoost() for external tokens (3) Then modify principal (4) Then emit events. Code fix: Add 'earnVault._settleBoost(msg.sender);' after line 36 in deposit() and line 64 in depositWithPermit() before principal is increased. This ensures boost index deltas are captured with old principal before new shares are minted.",
  "primary_file": {
    "path": "src/vaults/earn/EarnVaultUpgradeable.sol",
    "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.30; import {IEarnVault} from '../../interfaces/vaults/earn/IEarnVault.sol'; import {IEarnVaultEventsAndErrors} from '../../interfaces/vaults/earn/IEarnVaultEventsAndErrors.sol'; import {BoostRewardsLib} from './BoostRewardsLib.sol'; import {EarnVaultStorageBase} from './EarnVaultStorageBase.sol'; import {Initializable} from '@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol'; import {Ownable2StepUpgradeable} from 'lib/openzeppelin-contracts-upgradeable/contracts/access/Ownable2StepUpgradeable.sol'; import {PausableUpgradeable} from 'lib/openzeppelin-contracts-upgradeable/contracts/utils/PausableUpgradeable.sol'; import {ReentrancyGuardTransientUpgradeable} from 'lib/openzeppelin-contracts-upgradeable/contracts/utils/ReentrancyGuardTransientUpgradeable.sol'; import {IERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol'; import {IERC20Permit} from 'lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol'; import {SafeERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol'; import {Math} from 'lib/openzeppelin-contracts/contracts/utils/math/Math.sol'; /// @title EarnVaultUpgradeable (claimable yield) /// @notice Users deposit USDSC, accrue claimable USDSC via index accounting, and can claim/withdraw anytime. A distributor pushes yield: transfer USDSC to this contract, then call onYield(amount). /// Accounting: - globalIndex is in RAY (1e27) for precision. - User state: principal, userIndex, accrued. - When yield arrives and totalPrincipal>0: globalIndex += amount*RAY/totalPrincipal. - If totalPrincipal==0 at yield time: amount is transferred directly to treasury. Invariant (funding): USDSC balance >= claimReserve. contract EarnVaultUpgradeable is Initializable, Ownable2StepUpgradeable, PausableUpgradeable, ReentrancyGuardTransientUpgradeable, EarnVaultStorageBase, IEarnVault { using SafeERC20 for IERC20; // -------- Events and Errors -------- // All events and errors are inherited from IEarnVaultEventsAndErrors interface // -------- Modifiers -------- /// @dev Modifier to check if caller is the yield redistributor modifier onlyYieldRedistributor() { _onlyYieldRedistributor(); _; } /// @dev Modifier to check if caller is the boost reward keeper modifier onlyBoostRewardKeeper() { _onlyBoostRewardKeeper(); _; } /// @dev Modifier to check if caller is the pauser modifier onlyPauser() { _onlyPauser(); _; } // -------- Constructor / Initializer -------- /// @custom:oz-upgrades-unsafe-allow constructor constructor() { _disableInitializers(); } /// @notice Initialize the upgradeable EarnVault /// @param usdsc USDSC token contract address /// @param owner Initial owner address /// @param yieldRedistributorAddr Yield redistributor address /// @param treasuryAddr Treasury address /// @param pauserAddr Pauser address /// @param boostRewardKeeperAddr Boost reward keeper address function initialize(address usdsc, address owner, address yieldRedistributorAddr, address treasuryAddr, address pauserAddr, address boostRewardKeeperAddr) public initializer { if (usdsc == address(0) || owner == address(0)) { revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); } if (yieldRedistributorAddr == address(0) || treasuryAddr == address(0)) { revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); } if (pauserAddr == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); if (boostRewardKeeperAddr == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); // Initialize upgradeable contracts __Ownable2Step_init(); __Pausable_init(); __ReentrancyGuardTransient_init(); // Set owner _transferOwnership(owner); // Initialize storage EarnVaultStorage storage $ = _getStorage(); $.RAY = 1e27; $.USDSC = IERC20(usdsc); $.treasury = treasuryAddr; $.yieldRedistributor = yieldRedistributorAddr; $.boostRewardKeeper = boostRewardKeeperAddr; $.pauser = pauserAddr; $.globalIndex = $.RAY; // Initialize to RAY } // -------- Receive / Fallback -------- /// @dev Reject ETH transfers to prevent accidental loss receive() external payable { revert IEarnVaultEventsAndErrors.EthNotAccepted(); } /// @dev Reject ETH transfers to prevent accidental loss fallback() external payable { revert IEarnVaultEventsAndErrors.EthNotAccepted(); } // -------- External Functions (State-changing) -------- /// @notice Set the yield redistributor address /// @param who New yield redistributor address function setYieldRedistributor(address who) external onlyOwner { if (who == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); EarnVaultStorage storage $ = _getStorage(); address oldRedistributor = $.yieldRedistributor; $.yieldRedistributor = who; emit YieldRedistributorChanged(msg.sender, oldRedistributor, who); } /// @notice Set the boost reward keeper address /// @param who New boost reward keeper address function setBoostRewardKeeper(address who) external onlyOwner { if (who == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); EarnVaultStorage storage $ = _getStorage(); address oldKeeper = $.boostRewardKeeper; $.boostRewardKeeper = who; emit BoostRewardKeeperChanged(msg.sender, oldKeeper, who); } /// @notice Set the treasury address /// @param who New treasury address function setTreasury(address who) external onlyOwner { if (who == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); EarnVaultStorage storage $ = _getStorage(); address oldTreasury = $.treasury; if (oldTreasury == who) return; $.treasury = who; emit TreasuryChanged(msg.sender, oldTreasury, who); } /// @notice Set the pauser address /// @param who New pauser address function setPauser(address who) external onlyOwner { if (who == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); EarnVaultStorage storage $ = _getStorage(); address oldPauser = $.pauser; if (oldPauser == who) return; $.pauser = who; emit PauserChanged(msg.sender, oldPauser, who); } /// @notice Set blacklist status for an address /// @param who Address to update blacklist status for /// @param blacklisted Whether address should be blacklisted function setBlacklisted(address who, bool blacklisted) external onlyOwner { EarnVaultStorage storage $ = _getStorage(); bool oldStatus = $.isBlacklisted[who]; if (oldStatus == blacklisted) return; $.isBlacklisted[who] = blacklisted; emit BlacklistStatusChanged(msg.sender, who, oldStatus, blacklisted); } /// @notice Pause the contract (emergency stop) /// @dev Can be called by designated pauser only function pause() external onlyPauser { _pause(); } /// @notice Unpause the contract /// @dev Can be called by designated pauser only function unpause() external onlyPauser { _unpause(); } /// @notice Prevents renunciation of ownership. /// @dev Overrides Ownable2Step's renounceOwnership to protect against accidental loss of ownership. Owner can still transfer ownership using the 2-step process (transferOwnership + acceptOwnership). function renounceOwnership() public view override onlyOwner { revert IEarnVaultEventsAndErrors.OwnershipRenunciationDisabled(); } /// @notice Deposit USDSC tokens to earn yield /// @dev Reserves principal 1:1 in claimReserve to ensure withdrawals are always possible /// @param amount Amount of USDSC tokens to deposit function deposit(uint256 amount) external virtual whenNotPaused nonReentrant { EarnVaultStorage storage $ = _getStorage(); _checkNotBlacklisted(msg.sender); if (amount == 0) revert IEarnVaultEventsAndErrors.ZeroAmount(); _deposit(msg.sender, amount); } /// @notice Deposit USDSC tokens using permit (gasless approval) /// @dev Allows token owner to deposit via permit signature, with optional relayer execution /// @dev Token owner signs permit, relayer (msg.sender) pays gas and executes /// @dev Safely handles tokens that may not implement IERC20Permit /// @param tokenOwner Address of token owner (who signs permit and receives deposit credit) /// @param amount Amount of USDSC tokens to deposit /// @param deadline Permit deadline timestamp /// @param v Permit signature parameter v /// @param r Permit signature parameter r /// @param s Permit signature parameter s function depositWithPermit(address tokenOwner, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external whenNotPaused nonReentrant { EarnVaultStorage storage $ = _getStorage(); if (tokenOwner == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); _checkNotBlacklisted(tokenOwner); if (amount == 0) revert IEarnVaultEventsAndErrors.ZeroAmount(); // Permit is signed by tokenOwner, allowing this contract to transfer tokens try IERC20Permit(address($.USDSC)).permit(tokenOwner, address(this), amount, deadline, v, r, s) { // Permit succeeded, continue with deposit } catch { revert IEarnVaultEventsAndErrors.PermitFailed(); } _deposit(tokenOwner, amount); } /// @notice Withdraw any amount up to principal amount /// @param amount Amount of principal to withdraw (max: user's principal) /// @dev Automatically claims ALL accrued interest (USDSC + boost rewards) when withdrawing /// @dev User can only withdraw their principal, but gets all rewards automatically function withdraw(uint256 amount) external virtual whenNotPaused nonReentrant { EarnVaultStorage storage $ = _getStorage(); _checkNotBlacklisted(msg.sender); if (amount == 0) revert IEarnVaultEventsAndErrors.ZeroAmount(); _settle(msg.sender); uint256 p = $.principal[msg.sender]; if (amount > p) revert IEarnVaultEventsAndErrors.InsufficientPrincipal(); // Settle and claim ALL boost rewards _claimBoostRewards(msg.sender); // Update state AFTER settling all rewards $.principal[msg.sender] = p - amount; $.totalPrincipal -= amount; $.claimReserve -= amount; // Reduce claim reserve by withdrawn principal // Transfer principal $.USDSC.safeTransfer(msg.sender, amount); // Automatically claim ALL USDSC yield _claimUSDSC(msg.sender); // Emit events emit Withdraw(msg.sender, amount); } /// @notice Claim all accrued interest to caller's address /// @dev Settles user's position and transfers all accrued yield (USDSC + boost rewards) function claim() external virtual whenNotPaused nonReentrant { EarnVaultStorage storage $ = _getStorage(); _checkNotBlacklisted(msg.sender); _settle(msg.sender); uint256 usdscAmt = $.accrued[msg.sender]; bool hasUSDSCClaim = usdscAmt > 0; bool hasBoostClaim = false; // Claim USDSC interest (original order: USDSC first, then boost rewards) if (hasUSDSCClaim) { _claimUSDSC(msg.sender); } // Settle and claim all boost rewards hasBoostClaim = _claimBoostRewards(msg.sender); if (!hasUSDSCClaim && !hasBoostClaim) revert IEarnVaultEventsAndErrors.NothingToClaim(); } /// @notice Distribute yield to vault users (callable only by yield redistributor) /// @dev MUST be called AFTER transferring `amount` USDSC to this contract /// @dev Enforces funding invariant: USDSC.balance >= claimReserve + amount /// @param amount Amount of USDSC yield to distribute function onYield(uint256 amount) external virtual onlyYieldRedistributor nonReentrant { EarnVaultStorage storage $ = _getStorage(); if (amount == 0) return; // Verify actual balance before updating accounting uint256 bal = $.USDSC.balanceOf(address(this)); if ($.totalPrincipal == 0) { // No deposits: just need enough for treasury transfer if (bal < amount) revert IEarnVaultEventsAndErrors.InsufficientFunding(); $.USDSC.safeTransfer($.treasury, amount); emit YieldTransferredToTreasury(amount); return; } // Deposits exist: need enough for claimReserve + new yield if (bal < $.claimReserve + amount) revert IEarnVaultEventsAndErrors.InsufficientFunding(); // Exact, immediate index update with Ray remainder carry // delta = floor( (amount*RAY + _carryRay) / totalPrincipal ) // _carryRay = (amount*RAY + _carryRay) % totalPrincipal unchecked { uint256 num = amount * $.RAY + $._carryRay; uint256 delta = num / $.totalPrincipal; $._carryRay = num % $.totalPrincipal; $.globalIndex += delta; } $.claimReserve += amount; emit YieldIndexed(amount, $.globalIndex, $.claimReserve); } /// @notice Distribute boost rewards (ASTR, DOT, etc.) to vault users /// @dev MUST be called AFTER transferring `amount` of `token` to this contract /// @dev Uses same logic as USDSC yield - distributed proportionally based on principal /// @dev USDT is NOT supported as a boost reward token - it does not return a value on transfer()/transferFrom() /// @param token Token address to distribute as boost rewards (must be ERC20-compliant, not USDT) /// @param amount Amount of boost tokens to distribute function onBoostReward(address token, uint256 amount) external whenNotPaused onlyBoostRewardKeeper nonReentrant { EarnVaultStorage storage $ = _getStorage(); BoostRewardsLib.distributeBoostReward(token, amount, $.totalPrincipal, $.treasury, $.boostGlobalIndex, $.boostClaimReserve, $.activeBoostTokens, $.boostTokenIndex); } /// @notice Recover ERC20 tokens sent to this contract /// @dev For non-USDSC tokens or USDSC surplus when paused /// @param token Token address to recover /// @param to Address to send tokens to /// @param amount Amount to recover function recoverERC20(address token, address to, uint256 amount) external onlyOwner nonReentrant { EarnVaultStorage storage $ = _getStorage(); if (to == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); if (token == address($.USDSC)) { if (!paused()) revert IEarnVaultEventsAndErrors.ContractNotPaused(); // allow sweeping only true surplus uint256 bal = $.USDSC.balanceOf(address(this)); uint256 minRequired = $.claimReserve; if (bal <= minRequired) revert IEarnVaultEventsAndErrors.InsufficientFunding(); uint256 maxSweep = bal - minRequired; if (amount > maxSweep) revert IEarnVaultEventsAndErrors.ExceedsSurplus(); } else { // For non-USDSC tokens, check actual balance and boost reserves uint256 tokenBalance = IERC20(token).balanceOf(address(this)); if (amount > tokenBalance) revert IEarnVaultEventsAndErrors.ExceedsSurplus(); // For boost tokens, ensure we don't recover reserved amounts if ($.boostClaimReserve[token] > 0) { uint256 availableAmount = tokenBalance - $.boostClaimReserve[token]; if (amount > availableAmount) revert IEarnVaultEventsAndErrors.ExceedsSurplus(); } } IERC20(token).safeTransfer(to, amount); emit TokenRecovered(token, to, amount); } /// @notice Sweep excess USDSC yield to treasury (when vault has surplus above reserves) /// @dev Sweeps all surplus above minimum required reserves function sweepSurplusToTreasury() external onlyOwner nonReentrant { EarnVaultStorage storage $ = _getStorage(); uint256 bal = $.USDSC.balanceOf(address(this)); uint256 minRequired = $.claimReserve; if (bal <= minRequired) return; // No surplus to sweep uint256 surplus = bal - minRequired; $.USDSC.safeTransfer($.treasury, surplus); emit SurplusSweptToTreasury(surplus); } /// @notice Sweep native ETH from contract (only owner) /// @dev Allows recovery of ETH sent via selfdestruct or other means /// @param to Address to send ETH to /// @param amount Amount of ETH to sweep function sweepNative(address payable to, uint256 amount) external onlyOwner nonReentrant { if (to == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); (bool success,) = to.call{value: amount}(''); if (!success) revert IEarnVaultEventsAndErrors.SweepFailed(); emit NativeSwept(to, amount); } /// @notice Remove a boost reward token from activeBoostTokens array (only owner) /// @dev Can be used to clean up tokens that are frozen or no longer used /// @dev Only allows removal if boostClaimReserve[token] == 0 (no pending claims) /// @param token Token address to remove from activeBoostTokens array function removeBoostRewardToken(address token) external onlyOwner nonReentrant { EarnVaultStorage storage $ = _getStorage(); if (token == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); uint256 index = $.boostTokenIndex[token]; if (index == 0) return; if ($.boostClaimReserve[token] > 0) { revert IEarnVaultEventsAndErrors.InsufficientBoostClaimReserve(); } uint256 lastIndex = $.activeBoostTokens.length - 1; if (index != lastIndex + 1) { address lastToken = $.activeBoostTokens[lastIndex]; $.activeBoostTokens[index - 1] = lastToken; $.boostTokenIndex[lastToken] = index; } $.activeBoostTokens.pop(); delete $.boostTokenIndex[token]; emit IEarnVaultEventsAndErrors.BoostRewardTokenRemoved(token); } // -------- External Functions (View) -------- function asset() external view returns (address) { EarnVaultStorage storage $ = _getStorage(); return address($.USDSC); } function totalPrincipal() external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); return $.totalPrincipal; } function globalIndex() external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); return $.globalIndex; } function claimReserve() external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); return $.claimReserve; } function principal(address user) external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); return $.principal[user]; } function accrued(address user) external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); return $.accrued[user]; } function userIndex(address user) external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); return $.userIndex[user]; } function yieldRedistributor() external view returns (address) { EarnVaultStorage storage $ = _getStorage(); return $.yieldRedistributor; } function treasury() external view returns (address) { EarnVaultStorage storage $ = _getStorage(); return $.treasury; } function pauser() external view returns (address) { EarnVaultStorage storage $ = _getStorage(); return $.pauser; } function isBlacklisted(address user) external view returns (bool) { EarnVaultStorage storage $ = _getStorage(); return $.isBlacklisted[user]; } function claimable(address user) external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); uint256 p = $.principal[user]; if (p == 0) return $.accrued[user]; uint256 ui = $.userIndex[user]; uint256 gi = $.globalIndex; if (gi > ui) { uint256 owed = Math.mulDiv(p, gi - ui, $.RAY); return $.accrued[user] + owed; } return $.accrued[user]; } /// @notice Get user's total value (principal + claimable interest) function totalValue(address user) external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); uint256 p = $.principal[user]; return p + this.claimable(user); } /// @notice Get user's complete account info in one call function getUserInfo(address user) external view returns (uint256 userPrincipal, uint256 userClaimable, uint256 userTotal, uint256 userLastIndex) { EarnVaultStorage storage $ = _getStorage(); userPrincipal = $.principal[user]; userLastIndex = $.userIndex[user]; // Inline claimable logic to avoid expensive external call uint256 p = userPrincipal; uint256 ui = userLastIndex; uint256 gi = $.globalIndex; if (p == 0) { userClaimable = $.accrued[user]; } else if (gi > ui) { uint256 owed = Math.mulDiv(p, gi - ui, $.RAY); userClaimable = $.accrued[user] + owed; } else { userClaimable = $.accrued[user]; } userTotal = userPrincipal + userClaimable; } /// @notice Get vault's overall statistics function getVaultStats() external view returns (uint256 vaultTotalPrincipal, uint256 vaultClaimReserve, uint256 vaultGlobalIndex, uint256 vaultBalance, uint256 vaultCarryRay) { EarnVaultStorage storage $ = _getStorage(); vaultTotalPrincipal = $.totalPrincipal; vaultClaimReserve = $.claimReserve; vaultGlobalIndex = $.globalIndex; vaultBalance = $.USDSC.balanceOf(address(this)); vaultCarryRay = $._carryRay; } /// @notice Get user's claimable boost rewards for a specific token /// @param user User address to check /// @param token Token address to check boost rewards for function getClaimableBoostReward(address user, address token) external view returns (uint256) { EarnVaultStorage storage $ = _getStorage(); _checkNotBlacklisted(user); return BoostRewardsLib.getClaimableBoostReward(user, token, $.principal[user], $.userBoostIndex[user][token], $.boostGlobalIndex[token], $.userBoostAccrued); } /// @notice Get all claimable rewards for a user (USDSC yield + all boost rewards) /// @param user User address to check /// @return usdscClaimable Claimable USDSC yield /// @return boostTokens Array of boost token addresses /// @return boostAmounts Array of claimable amounts for each boost token function getAllClaimables(address user) external view returns (uint256 usdscClaimable, address[] memory boostTokens, uint256[] memory boostAmounts) { EarnVaultStorage storage $ = _getStorage(); _checkNotBlacklisted(user); // Get USDSC claimable yield usdscClaimable = this.claimable(user); // Get all active boost tokens boostTokens = new address[]($.activeBoostTokens.length); boostAmounts = new uint256[]($.activeBoostTokens.length); // Calculate claimable amounts for each boost token for (uint256 i = 0; i < $.activeBoostTokens.length; i++) { address token = $.activeBoostTokens[i]; boostTokens[i] = token; boostAmounts[i] = BoostRewardsLib.getClaimableBoostReward(user, token, $.principal[user], $.userBoostIndex[user][token], $.boostGlobalIndex[token], $.userBoostAccrued); } } // -------- External Functions (Pure) -------- /// @notice Get version info (virtual for overrides) function getVersion() external pure virtual returns (string memory) { return 'EarnVaultV1'; } // -------- Internal Functions (State-changing) -------- /// @dev Internal helper to handle deposit logic (shared by deposit() and depositWithPermit()) /// @param user Address of the user depositing /// @param amount Amount of USDSC tokens to deposit function _deposit(address user, uint256 amount) internal { EarnVaultStorage storage $ = _getStorage(); _settle(user); // Settle boost rewards for all active tokens BEFORE updating principal for (uint256 i = 0; i < $.activeBoostTokens.length; i++) { address token = $.activeBoostTokens[i]; BoostRewardsLib.settleBoost(user, token, $.principal[user], $.boostGlobalIndex[token], $.userBoostIndex, $.userBoostAccrued); } $.USDSC.safeTransferFrom(user, address(this), amount); $.principal[user] += amount; $.totalPrincipal += amount; $.claimReserve += amount; // reserve principal 1:1 emit Deposit(user, amount); } /// @dev Internal helper to claim USDSC interest for a user /// @param user Address of the user claiming function _claimUSDSC(address user) internal { EarnVaultStorage storage $ = _getStorage(); uint256 usdscYield = $.accrued[user]; if (usdscYield > 0) { if ($.claimReserve < usdscYield) revert IEarnVaultEventsAndErrors.InsufficientFunding(); $.accrued[user] = 0; $.claimReserve -= usdscYield; $.USDSC.safeTransfer(user, usdscYield); emit InterestClaimed(user, usdscYield); } } /// @dev Internal helper to claim all boost rewards for a user /// @param user Address of the user claiming /// @return hasBoostClaim Whether any boost rewards were claimed function _claimBoostRewards(address user) internal returns (bool hasBoostClaim) { EarnVaultStorage storage $ = _getStorage(); uint256 p = $.principal[user]; for (uint256 i = 0; i < $.activeBoostTokens.length; i++) { address token = $.activeBoostTokens[i]; // settleBoost is called internally by claimBoostReward uint256 claimedAmount = BoostRewardsLib.claimBoostReward(user, token, p, $.boostGlobalIndex[token], $.userBoostIndex, $.userBoostAccrued, $.boostClaimReserve); if (claimedAmount > 0) { hasBoostClaim = true; } } } /// @dev Settles user's accrued yield based on globalIndex difference /// @dev Must ALWAYS be called before modifying principal[user] or accrued[user] /// @dev For first-time users, sets userIndex to current globalIndex to prevent over-allocation /// @param user Address to settle function _settle(address user) internal virtual { EarnVaultStorage storage $ = _getStorage(); uint256 p = $.principal[user]; if (p == 0) { $.userIndex[user] = $.globalIndex; return; } uint256 ui = $.userIndex[user]; uint256 gi = $.globalIndex; if (gi > ui) { uint256 owed = Math.mulDiv(p, gi - ui, $.RAY); $.accrued[user] += owed; } $.userIndex[user] = gi; // Always update index for consistency } // -------- Internal Functions (View) -------- function _onlyYieldRedistributor() internal view { EarnVaultStorage storage $ = _getStorage(); if (msg.sender != $.yieldRedistributor) revert IEarnVaultEventsAndErrors.NotYieldRedistributor(); } function _onlyBoostRewardKeeper() internal view { EarnVaultStorage storage $ = _getStorage(); if (msg.sender != $.boostRewardKeeper) revert IEarnVaultEventsAndErrors.NotBoostRewardKeeper(); } function _onlyPauser() internal view { EarnVaultStorage storage $ = _getStorage(); if (msg.sender != $.pauser) revert IEarnVaultEventsAndErrors.NotAuthorizedToPause(); } /// @dev Check if user is not blacklisted, revert if they are /// @param user Address to check blacklist status for function _checkNotBlacklisted(address user) internal view virtual { EarnVaultStorage storage $ = _getStorage(); if ($.isBlacklisted[user]) revert IEarnVaultEventsAndErrors.AddressBlacklisted(); } }",
    "vulnerable_lines": [34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 62, 63, 64, 65, 66, 67, 68, 69],
    "vulnerable_functions": ["deposit", "depositWithPermit"]
  },
  "context_files": [
    {
      "path": "src/vaults/earn/BoostRewardsLib.sol",
      "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.30; import {IEarnVaultEventsAndErrors} from '../../interfaces/vaults/earn/IEarnVaultEventsAndErrors.sol'; import {IERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol'; import {SafeERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol'; import {Math} from 'lib/openzeppelin-contracts/contracts/utils/math/Math.sol'; /// @title BoostRewardsLib - Library for handling boost rewards distribution /// @notice Handles boost rewards logic separately from main EarnVault contract /// @dev Uses same logic as USDSC yield - distributed proportionally based on principal /// @dev IMPORTANT: USDT is NOT supported as a boost reward token. USDT's transfer() and transferFrom() methods do not return a boolean value, which is incompatible with the standard IERC20 interface expected by this library. Attempting to use USDT will result in transaction failures. library BoostRewardsLib { using SafeERC20 for IERC20; // -------- Constants -------- uint256 public constant RAY = 1e27; uint256 public constant MAX_BOOST_TOKENS = 10; /// @notice Distribute boost rewards to vault users /// @dev Uses same logic as USDSC yield - distributed proportionally based on principal /// @dev USDT is NOT supported - see library-level documentation for details /// @param token Token address to distribute as boost rewards (must be ERC20-compliant, not USDT) /// @param amount Amount of boost tokens to distribute /// @param totalPrincipal Total principal amount in vault /// @param treasury Treasury address for when no deposits exist /// @param boostGlobalIndex Global boost index for this token /// @param boostClaimReserve Claimable boost reserves for this token /// @param activeBoostTokens Array of active boost tokens /// @param boostTokenIndex Mapping of token to index in activeBoostTokens array function distributeBoostReward(address token, uint256 amount, uint256 totalPrincipal, address treasury, mapping(address => uint256) storage boostGlobalIndex, mapping(address => uint256) storage boostClaimReserve, address[] storage activeBoostTokens, mapping(address => uint256) storage boostTokenIndex) internal { if (token == address(0)) { revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); } if (amount == 0) return; // Verify actual balance before updating accounting uint256 bal = IERC20(token).balanceOf(address(this)); if (totalPrincipal == 0) { // No deposits: transfer to treasury if (bal < amount) revert IEarnVaultEventsAndErrors.InsufficientBoostTokenBalance(); try IERC20(token).transfer(treasury, amount) returns (bool success) { if (!success) { revert IEarnVaultEventsAndErrors.InsufficientBoostTokenBalance(); } emit IEarnVaultEventsAndErrors.BoostRewardTransferredToTreasury(token, amount); return; } catch { // Transfer failed (token may be frozen, paused, etc.) // Revert the operation - treasury transfer failure should be handled by keeper revert IEarnVaultEventsAndErrors.InsufficientBoostTokenBalance(); } } // Deposits exist: distribute proportionally based on principal (same as USDSC yield) if (bal < boostClaimReserve[token] + amount) revert IEarnVaultEventsAndErrors.InsufficientBoostClaimReserve(); // Update boost global index for this token (same logic as USDSC yield) uint256 carryRay = 0; // We use 0 for boost rewards as precision loss is negligible unchecked { uint256 num = amount * RAY + carryRay; uint256 delta = num / totalPrincipal; boostGlobalIndex[token] += delta; } boostClaimReserve[token] += amount; // Track active boost tokens (only add if not already tracked) if (boostTokenIndex[token] == 0) { // Check maximum limit before adding new token if (activeBoostTokens.length >= MAX_BOOST_TOKENS) { revert IEarnVaultEventsAndErrors.TooManyBoostTokens(); } // Token not tracked yet, add to array and set index activeBoostTokens.push(token); boostTokenIndex[token] = activeBoostTokens.length; // 1-based index } emit IEarnVaultEventsAndErrors.BoostRewardIndexed(token, amount, boostGlobalIndex[token], boostClaimReserve[token]); } /// @notice Settle user's accrued boost rewards for a specific token /// @param user User address to settle /// @param token Token address to settle boost rewards for /// @param principal User's principal amount /// @param boostGlobalIndex Global boost index for this token /// @param userBoostIndex Mapping of user => token => boost index /// @param userBoostAccrued User's accrued boost rewards for this token function settleBoost(address user, address token, uint256 principal, uint256 boostGlobalIndex, mapping(address => mapping(address => uint256)) storage userBoostIndex, mapping(address => mapping(address => uint256)) storage userBoostAccrued) public { if (principal == 0) { // User has no principal, just update index userBoostIndex[user][token] = boostGlobalIndex; return; } uint256 ui = userBoostIndex[user][token]; // Settle accrued rewards if global index has increased if (boostGlobalIndex > ui) { uint256 owed = Math.mulDiv(principal, boostGlobalIndex - ui, RAY); userBoostAccrued[user][token] += owed; } // Always update index for consistency userBoostIndex[user][token] = boostGlobalIndex; } /// @notice Claim boost rewards for a specific token /// @dev USDT is NOT supported - see library-level documentation for details /// @param user User address claiming rewards /// @param token Token address to claim boost rewards for (must be ERC20-compliant, not USDT) /// @param principal User's principal amount /// @param boostGlobalIndex Global boost index for this token /// @param userBoostIndex Mapping of user => token => boost index /// @param userBoostAccrued User's accrued boost rewards for this token /// @param boostClaimReserve Claimable boost reserves for this token function claimBoostReward(address user, address token, uint256 principal, uint256 boostGlobalIndex, mapping(address => mapping(address => uint256)) storage userBoostIndex, mapping(address => mapping(address => uint256)) storage userBoostAccrued, mapping(address => uint256) storage boostClaimReserve) internal returns (uint256 claimedAmount) { if (token == address(0)) revert IEarnVaultEventsAndErrors.CanNotBeZeroAddress(); // Settle user's boost rewards settleBoost(user, token, principal, boostGlobalIndex, userBoostIndex, userBoostAccrued); claimedAmount = userBoostAccrued[user][token]; if (claimedAmount == 0) return 0; if (boostClaimReserve[token] < claimedAmount) revert IEarnVaultEventsAndErrors.InsufficientBoostClaimReserve(); userBoostAccrued[user][token] = 0; boostClaimReserve[token] -= claimedAmount; try IERC20(token).transfer(user, claimedAmount) returns (bool success) { if (!success) { // Transfer returned false - revert accounting changes userBoostAccrued[user][token] = claimedAmount; boostClaimReserve[token] += claimedAmount; emit IEarnVaultEventsAndErrors.BoostRewardTransferFailed(user, token, claimedAmount); return 0; } emit IEarnVaultEventsAndErrors.BoostRewardClaimed(user, token, claimedAmount); } catch { // Transfer failed (token may be frozen, paused, etc.) // Revert accounting changes to maintain consistency userBoostAccrued[user][token] = claimedAmount; boostClaimReserve[token] += claimedAmount; // Emit failure event for monitoring emit IEarnVaultEventsAndErrors.BoostRewardTransferFailed(user, token, claimedAmount); // Returning 0 to indicate failure, allowing other tokens to still be claimed return 0; } } /// @notice Get user's claimable boost rewards for a specific token /// @param user User address to check /// @param token Token address to check boost rewards for /// @param principal User's principal amount /// @param userBoostIndex User's last boost index for this token /// @param boostGlobalIndex Global boost index for this token /// @param userBoostAccrued User's accrued boost rewards for this token function getClaimableBoostReward(address user, address token, uint256 principal, uint256 userBoostIndex, uint256 boostGlobalIndex, mapping(address => mapping(address => uint256)) storage userBoostAccrued) internal view returns (uint256) { if (principal == 0) { return userBoostAccrued[user][token]; } if (boostGlobalIndex > userBoostIndex) { uint256 owed = Math.mulDiv(principal, boostGlobalIndex - userBoostIndex, RAY); return userBoostAccrued[user][token] + owed; } return userBoostAccrued[user][token]; } }",
      "relevance": "Contains boost index accounting. Settlement captures the delta between user's last recorded index and global index. If settlement doesn't occur before principal increases, the delta applies to a larger base."
    }
  ],
  "call_flow": "User.deposit() → EarnVault.deposit() → _settleRewards() (✓) but NOT _settleBoost() (✗) → Principal increased → Next distribution → BoostRewardsLib.distributeBoostReward() → Over-allocation occurs",
  "context_hint": "Index-based reward accounting requires settlement at all state-change points. The EarnVault correctly settles USDSC rewards but misses boost settlement. The withdraw() function shows the correct pattern - it calls both _settleRewards() and _settleBoost() before modifying principal. This is likely a refactoring oversight where boost reward support was added to an existing pattern without updating all deposit paths.",
  "is_vulnerable": true,
  "expert_notes": "Index-based reward systems (similar to Aave's index updates) must be settled before any operation that changes a user's balance. This is a subtle but critical invariant. The fact that withdraw() correctly calls _settleBoost() while deposit() doesn't suggests this was introduced during a code merge or refactoring. Good security practice would be to enforce this invariant with comments or asserts in critical functions."
},

{
  "id": "gs_quantstamp_startale_sta003",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Startale Stablecoin Vaults",
  "source_finding_id": "STA-3",
  "report_url": "https://certificate.quantstamp.com/full/startale-stablecoin-vaults/402c94ac-7cc8-4b28-94b0-83876f38cf56/index.html",
  "github_repo_url": "https://github.com/StartaleGroup/stablecoin-contracts",
  "contest_date": "2025-11-03",
  "severity": "medium",
  "vulnerability_type": "rounding_error",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "finding_title": "Incorrect S_base Calculation with Donations",
  "finding_description": "The _calculateSplit() function includes accidental token transfers (donations) in the gross amount used to compute S_base (supply basis). When the contract holds a balance before distribute() is called, this balance is included in the gross calculation, causing S_base to be understated and yield to be misdistributed between vaults and treasury.",
  "attack_scenario": "1. Someone accidentally sends 1M USDSC directly to RewardRedistributor contract (common user error)\n2. Operator calls distribute(), which claims 5M USDSC yield from M0\n3. balanceBefore = 1M (the donation), minted = 5M, gross = 6M\n4. _calculateSplit() receives gross = 6M\n5. S_base calculation: SNow = 1,050,000,000 (1.05B USDSC total supply), sBase = 1.05B - 6M = 1.044B\n6. Yield split using S_base = 1.044B instead of correct 1.05B\n7. Distribution: toEarn = (5M * 2M) / 1.044B = 9.54M (should be 9.52M)\n8. Distribution: toOn = (5M * 1.05B) / 1.044B = 5.02B (should be 5B)\n9. toStartaleExtra gets 0 instead of 19.2k\n10. Vault profit: 19.2k USDSC lost per donation\n11. With $1M donation: ~190 USDSC impact. With multiple donations accumulating: 157k+ USDSC lost per distribution cycle",
  "fix_description": "Use minted yield only in S_base calculation, not balanceBefore. Change line 110 from 'uint256 gross = balanceBefore + minted;' to 'uint256 yieldAmount = minted;' and in _calculateSplit, calculate S_base as 'sBase = SNow - yieldAmount' instead of 'SNow - gross'. Also add recoverDonations() function: function recoverDonations() external onlyRole(ADMIN_ROLE) { uint256 balance = IERC20(USDSC_ADDRESS).balanceOf(address(this)); if (balance > 0) IERC20(USDSC_ADDRESS).transfer(treasury, balance); } This allows manual recovery of unexpected transfers without affecting distribution formulas.",
  "primary_file": {
    "path": "src/distributor/RewardRedistributor.sol",
    "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.30; import {IRewardRedistributorEventsAndErrors} from '../interfaces/distributor/IRewardRedistributorEventsAndErrors.sol'; import {IEarnVault} from '../interfaces/vaults/earn/IEarnVault.sol'; import {AccessControl} from 'lib/openzeppelin-contracts/contracts/access/AccessControl.sol'; import {IAccessControl} from 'lib/openzeppelin-contracts/contracts/access/IAccessControl.sol'; import {AccessControlEnumerable} from 'lib/openzeppelin-contracts/contracts/access/extensions/AccessControlEnumerable.sol'; import {IERC4626} from 'lib/openzeppelin-contracts/contracts/interfaces/IERC4626.sol'; import {IERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol'; import {SafeERC20} from 'lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol'; import {Pausable} from 'lib/openzeppelin-contracts/contracts/utils/Pausable.sol'; import {ReentrancyGuardTransient} from 'lib/openzeppelin-contracts/contracts/utils/ReentrancyGuardTransient.sol'; import {IMYieldToOne} from 'm-extensions/projects/yieldToOne/IMYieldToOne.sol'; /// @title RewardRedistributor /// @notice Pulls freshly-minted USDSC yield from the M0 extension, applies an optional fee to Startale, then allocates the **net** yield to eligible cohorts by their share of the **base supply** S (supply before this mint): - EarnVault (checkbox OFF) receives `toEarn = Y_net * T_earn / S_base` - sUSDSC (ERC-4626) vault (checkbox ON) receives `toOn = Y_net * T_yield / S_base` - Remainder (wallets/LP/points + rounding) → Startale (`toStartaleExtra`) /// @dev Uses per-cohort integer carry to remove long-run rounding bias. Delivers to EarnVault with transfer→onYield ordering to satisfy its funding invariant. Delivers to sUSDSC via raw transfer, which raises PPS in ERC-4626. /// Architecture: - USDSC_ADDRESS: Single USDSC token address that implements both IERC20 and IMYieldToOne interfaces - Cast to IERC20 for transfers and supply queries (totalSupply, safeTransfer) - Cast to IMYieldToOne for yield operations (claimYield, yield) contract RewardRedistributor is IRewardRedistributorEventsAndErrors, AccessControlEnumerable, Pausable, ReentrancyGuardTransient { using SafeERC20 for IERC20; /// Keeper allowed to call distribute() bytes32 public constant OPERATOR_ROLE = keccak256('OPERATOR_ROLE'); /// @notice Maximum fee allowed (basis points). uint16 public constant MAX_FEE_BPS = 100; // 100 bps max (1%) /// @notice Basis points denominator (10000 = 100%). /// @dev Basis Points (bps) are a unit of measurement for percentages: - 1 bps = 0.01% = 1/10,000 - 10 bps = 0.1% = 10/10,000 - 10,000 bps = 100% = 10,000/10,000 /// Fee calculation formula: `feeAmount = (amount × fee_bps) / BPS_DENOMINATOR` /// Example: For 30 bps (0.3%) fee on 1,000,000 tokens: `feeAmount = (1,000,000 × 30) / 10,000 = 3,000 tokens` Verification: 3,000 / 1,000,000 = 0.003 = 0.3% ✓ uint256 public constant BPS_DENOMINATOR = 10_000; /// @notice USDSC token address - used for both transfers/supply queries (IERC20) and yield operations (IMYieldToOne). /// @dev The same address implements both IERC20 and IMYieldToOne interfaces. address public immutable USDSC_ADDRESS; /// @notice Treasury recipient for fees and ineligible cohort yield. address public treasury; /// @notice Earn vault (checkbox OFF) that indexes yield via {IEarnVault.onYield}. IEarnVault public earnVault; /// @notice sUSDSC (ERC-4626) vault that receives yield via raw transfers (no minting). IERC4626 public susdscVault; /// @notice Fee on newly minted yield expressed in basis points. /// @dev See {BPS_DENOMINATOR} for basis points explanation. Examples: 30 bps = 0.3%, 100 bps = 1%, 1000 bps = 10%. Initial value: 30 bps (0.3%). uint16 public fee_on_yield_bps = 30; /// @dev Carry accumulator for EarnVault share calculations across epochs. uint256 private carryEarn; /// @dev Carry accumulator for sUSDSC share calculations across epochs. uint256 private carryOn; /// @dev Latest sUSDSC TVL snapshot. uint256 public lastSusdscTVL; /// @dev Latest snapshot block number. uint256 public lastSnapshotBlockNumber; /// @dev Latest snapshot timestamp. uint256 public lastSnapshotTimestamp; /// @dev Maximum age for snapshot validity (e.g., 4 hours). uint256 public snapshotMaxAge = 4 hours; /// @notice Initializes the redistributor. /// @param usdscAddress USDSC token address (implements both IERC20 and IMYieldToOne interfaces). /// @param treasuryAddr Treasury recipient. /// @param earnV EarnVault (checkbox OFF) recipient. /// @param sVault sUSDSC ERC-4626 vault (checkbox ON) recipient. /// @param admin Admin address; receives DEFAULT_ADMIN_ROLE. /// @param keeper Keeper address; receives OPERATOR_ROLE (can call distribute()). constructor(address usdscAddress, address treasuryAddr, IEarnVault earnV, IERC4626 sVault, address admin, address keeper) { _validateUsdscContract(usdscAddress); if (treasuryAddr == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('treasury'); if (address(earnV) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('earnVault'); if (address(sVault) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('susdscVault'); if (admin == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('admin'); if (keeper == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('keeper'); USDSC_ADDRESS = usdscAddress; treasury = treasuryAddr; earnVault = earnV; susdscVault = sVault; _grantRole(DEFAULT_ADMIN_ROLE, admin); _grantRole(OPERATOR_ROLE, keeper); } function _validateUsdscContract(address usdscAddress) internal view { if (usdscAddress == address(0)) { revert IRewardRedistributorEventsAndErrors.ZeroAddress('USDSC_ADDRESS'); } // Check that the address is a contract if (usdscAddress.code.length == 0) revert InvalidUSDSC('NOT_CONTRACT'); // Validate that the contract implements IERC20 try IERC20(usdscAddress).totalSupply() returns (uint256) {} catch { revert IRewardRedistributorEventsAndErrors.InvalidUSDSC('IERC20'); } // Validate that the contract implements IMYieldToOne try IMYieldToOne(usdscAddress).yield() returns (uint256) {} catch { revert IRewardRedistributorEventsAndErrors.InvalidUSDSC('IMYieldToOne'); } } /// @notice Updates Treasury address. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param treasuryAddr New Treasury address. function setTreasury(address treasuryAddr) external onlyRole(DEFAULT_ADMIN_ROLE) { if (treasuryAddr == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('treasury'); treasury = treasuryAddr; emit IRewardRedistributorEventsAndErrors.TreasuryUpdated(treasuryAddr); } /// @notice Updates EarnVault address. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param earnV New EarnVault (OFF) address. function setEarnVault(IEarnVault earnV) external onlyRole(DEFAULT_ADMIN_ROLE) { if (address(earnV) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('earnVault'); earnVault = earnV; emit IRewardRedistributorEventsAndErrors.EarnVaultUpdated(address(earnV)); } /// @notice Updates sUSDSC vault address. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param sVault New sUSDSC ERC-4626 vault (ON) address. function setSusdscVault(IERC4626 sVault) external onlyRole(DEFAULT_ADMIN_ROLE) { if (address(sVault) == address(0)) revert IRewardRedistributorEventsAndErrors.ZeroAddress('susdscVault'); susdscVault = sVault; emit IRewardRedistributorEventsAndErrors.SusdscVaultUpdated(address(sVault)); } /// @notice Updates fee on yield. /// @dev Fee is capped by {MAX_FEE_BPS}. Callable by DEFAULT_ADMIN_ROLE. /// @param newFeeBps New fee on yield in bps (≤ MAX_FEE_BPS). function setFeeBps(uint16 newFeeBps) external onlyRole(DEFAULT_ADMIN_ROLE) { if (newFeeBps > MAX_FEE_BPS) revert IRewardRedistributorEventsAndErrors.FeeTooHigh(newFeeBps, MAX_FEE_BPS); fee_on_yield_bps = newFeeBps; emit IRewardRedistributorEventsAndErrors.FeeUpdated(newFeeBps); } /// @notice Updates the maximum age for snapshot validity. /// @param newSnapshotMaxAge New snapshot maximum age value. function setSnapshotMaxAge(uint256 newSnapshotMaxAge) external onlyRole(DEFAULT_ADMIN_ROLE) { if (newSnapshotMaxAge < 1 minutes) { revert IRewardRedistributorEventsAndErrors.InvalidSnapshotMaxAge(newSnapshotMaxAge, 1 minutes); } if (newSnapshotMaxAge > 7 days) { revert IRewardRedistributorEventsAndErrors.InvalidSnapshotMaxAge(newSnapshotMaxAge, 7 days); } snapshotMaxAge = newSnapshotMaxAge; emit IRewardRedistributorEventsAndErrors.SnapshotMaxAgeUpdated(newSnapshotMaxAge); } /// @notice Capture sUSDSC vault TVL for next distribution /// @dev Must be called in block N before distribute() in block N+x (a few blocks apart/ couple of minutes apart) /// @custom:security Prevents same-block TVL manipulation attacks function snapshotSusdscTVL() external onlyRole(OPERATOR_ROLE) whenNotPaused { lastSusdscTVL = susdscVault.totalAssets(); lastSnapshotTimestamp = block.timestamp; lastSnapshotBlockNumber = block.number; emit IRewardRedistributorEventsAndErrors.SusdscTVLSnapshotCaptured(lastSusdscTVL, lastSnapshotTimestamp, lastSnapshotBlockNumber); } /// @notice Pauses or unpauses the contract. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @param p True to pause, false to unpause. function pause(bool p) external onlyRole(DEFAULT_ADMIN_ROLE) { p ? _pause() : _unpause(); } /// @notice Recovers donations made to the contract to the treasury. /// @dev Callable by DEFAULT_ADMIN_ROLE. /// @notice The invariant holds that before and after distribute the usdsc balance of address(this) is the same. /// @notice The inflow during claimYield happens in the distribute() gets distributed whole leaving no balance. /// @notice Hence we can safely assumy at any point in time usdscbalance of address(this) is from the intentional/accidental donations. /// @custom:security nonReentrant. function recoverDonations() external onlyRole(DEFAULT_ADMIN_ROLE) nonReentrant { uint256 balance = IERC20(USDSC_ADDRESS).balanceOf(address(this)); if (balance > 0) { IERC20(USDSC_ADDRESS).safeTransfer(treasury, balance); emit IRewardRedistributorEventsAndErrors.DonationsRecovered(balance); } } /// @notice Prevents renunciation of the last DEFAULT_ADMIN_ROLE only. /// @dev Overrides AccessControl's renounceRole to ensure at least one admin remains. Other roles (e.g., OPERATOR_ROLE) can still be renounced freely. Admin can renounce their role only if there are other admins remaining. /// @param role The role to renounce. /// @param callerConfirmation The address of the caller confirming renunciation. function renounceRole(bytes32 role, address callerConfirmation) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE) { // Only check last admin protection if the caller actually has the role if (hasRole(DEFAULT_ADMIN_ROLE, callerConfirmation) && getRoleMemberCount(DEFAULT_ADMIN_ROLE) <= 1) { revert IRewardRedistributorEventsAndErrors.CannotRemoveLastAdmin(); } } super.renounceRole(role, callerConfirmation); } /// @notice Prevents revocation of the last DEFAULT_ADMIN_ROLE only. /// @dev Overrides AccessControl's revokeRole to ensure at least one admin remains. Non-admin roles (e.g., OPERATOR_ROLE) can be revoked freely. Multiple admins can be revoked as long as at least one admin remains. Only an account with the admin role can revoke roles from others. /// @param role The role to revoke. /// @param account The account from which to revoke the role. function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) { if (role == DEFAULT_ADMIN_ROLE) { // Only check last admin protection if the account actually has the role if (hasRole(DEFAULT_ADMIN_ROLE, account) && getRoleMemberCount(DEFAULT_ADMIN_ROLE) <= 1) { revert IRewardRedistributorEventsAndErrors.CannotRemoveLastAdmin(); } } super.revokeRole(role, account); } /// @notice Validates that this contract is still the yield recipient on the extension. /// @dev Reverts if the yield recipient has changed. function _validateYieldRecipient() internal view { address currentRecipient = IMYieldToOne(USDSC_ADDRESS).yieldRecipient(); if (currentRecipient != address(this)) { revert IRewardRedistributorEventsAndErrors.YieldRecipientChanged(currentRecipient); } } /** * @notice Validates that the snapshot is valid. * @dev Performs the following checks: - Ensures a snapshot has been taken (timestamp and block number are non-zero). - Verifies the snapshot is from a previous block (prevents same-block manipulation). - Ensures the snapshot is not too old (must be within `snapshotMaxAge`). Reverts with appropriate errors if any check fails. */ function _validateSnapShotAge() internal view { if (lastSnapshotTimestamp == 0) { revert IRewardRedistributorEventsAndErrors.LastSnapshotInvalid(); } if (lastSnapshotBlockNumber == 0) { revert IRewardRedistributorEventsAndErrors.LastSnapshotInvalid(); } if (block.number - lastSnapshotBlockNumber < 1) { revert IRewardRedistributorEventsAndErrors.MustSnapshotInPreviousBlocks(lastSnapshotBlockNumber, block.number); } // Check maximum age (snapshot must not be too old) if (block.timestamp - lastSnapshotTimestamp > snapshotMaxAge) { revert IRewardRedistributorEventsAndErrors.SnapshotTooOld(lastSnapshotTimestamp, block.timestamp, snapshotMaxAge); } } /// @notice Claims pending USDSC yield from the extension and distributes it per policy. /// @dev Sequence: 1) Record `balanceBefore = IERC20(USDSC_ADDRESS).balanceOf(address(this))`. 2) `minted = IMYieldToOne(USDSC_ADDRESS).claimYield()` mints fresh USDSC to this contract (must be yieldRecipient). 3) Calculate `gross = balanceBefore + minted` to handle both normal flow and external claimYield() calls. 4) `feeToStartale = gross * fee_on_yield_bps / 10_000`. 5) Compute `S_base = IERC20(USDSC_ADDRESS).totalSupply() - minted` (supply **before** this mint). 6) Read TVLs: `T_earn = earnVault.totalPrincipal()`, `T_yield = lastSusdscTVL` (snapshot TVL). 7) Allocate net using carries: `toEarn = floor((net*T_earn + carryEarn)/S_base)`, `carryEarn = (net*T_earn + carryEarn) % S_base` `toOn = floor((net*T_yield + carryOn)/S_base)`, `carryOn = (net*T_yield + carryOn) % S_base` `toStartaleExtra = net - (toEarn + toOn)` 8) Transfers: - Startale: `feeToStartale + toStartaleExtra` - EarnVault: transfer `toEarn` **then** call `earnVault.onYield(toEarn)` - sUSDSC: transfer `toOn` (PPS rises) /// @custom:security nonReentrant and Pausable. function distribute() external whenNotPaused onlyRole(OPERATOR_ROLE) nonReentrant { _validateYieldRecipient(); _validateSnapShotAge(); // Note: claimYield() on USDSCextension is not public method anymore and is gated by trusted actors. // Hence any other accruals before/after distribute are pure donations and not newly minted. uint256 minted = IMYieldToOne(USDSC_ADDRESS).claimYield(); if (minted == 0) return; uint256 feeToStartale; uint256 toEarn; uint256 toOn; uint256 toStartaleExtra; uint256 S_base; uint256 T_earn; uint256 T_yield; (feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield) = _calculateSplit(minted, true, false); if (S_base == 0) { if (feeToStartale > 0) IERC20(USDSC_ADDRESS).safeTransfer(treasury, feeToStartale); if (toStartaleExtra > 0) IERC20(USDSC_ADDRESS).safeTransfer(treasury, toStartaleExtra); emit Distributed(minted, feeToStartale, 0, 0, toStartaleExtra, 0, 0, 0); return; } { uint256 net = minted - feeToStartale; uint256 numEarn = net * T_earn + carryEarn; toEarn = numEarn / S_base; carryEarn = numEarn % S_base; uint256 numOn = net * T_yield + carryOn; toOn = numOn / S_base; carryOn = numOn % S_base; toStartaleExtra = net - (toEarn + toOn); } uint256 startaleTotal = feeToStartale + toStartaleExtra; // Note: We may split it into two transfers to two different addresses. if (startaleTotal > 0) IERC20(USDSC_ADDRESS).safeTransfer(treasury, startaleTotal); if (toEarn > 0) { IERC20(USDSC_ADDRESS).safeTransfer(address(earnVault), toEarn); earnVault.onYield(toEarn); } if (toOn > 0) { IERC20(USDSC_ADDRESS).safeTransfer(address(susdscVault), toOn); } emit Distributed(minted, feeToStartale, toEarn, toOn, toStartaleExtra, S_base, T_earn, T_yield); // balanceBefore and balanceAfter distribute would be the same. } /// @notice Preview a split for a hypothetical minted amount. /// @dev Pure math helper (no state/carry usage). Does **not** call the extension. /// @param minted Hypothetical fresh yield to allocate (pre-fee). /// @return feeToStartale Fee portion (bps of `minted`) to Startale. /// @return toEarn Portion of net allocated to EarnVault (OFF) **without carry**. /// @return toOn Portion of net allocated to sUSDSC (ON) **without carry**. /// @return toStartaleExtra Remainder of net: ineligible cohorts + rounding. /// @return S_base Total USDSC supply **before** this mint (= totalSupply - minted if ≥0). /// @return T_earn EarnVault TVL used for allocation (`earnVault.totalPrincipal()`). /// @return T_yield sUSDSCVault TVL used for allocation (`susdscVault.totalAssets()`). function previewSplit(uint256 minted) external view returns (uint256 feeToStartale, uint256 toEarn, uint256 toOn, uint256 toStartaleExtra, uint256 S_base, uint256 T_earn, uint256 T_yield) { return _calculateSplit(minted, false, true); } /// @notice Preview a split using the extension's **current pending** yield (no carries). /// @dev Reads {IUSDSCMExtension.yield}. Pure preview; does not mutate. /// @return couldBeMinted Pending fresh yield on the extension at this moment. /// @return feeToStartale Fee portion (bps of `couldBeMinted`) to Startale. /// @return toEarn Portion of net to EarnVault (OFF) **without carry**. /// @return toOn Portion of net to sUSDSC (ON) **without carry**. /// @return",
    "vulnerable_lines": [106, 107, 108, 109, 110, 145, 146, 147, 148],
    "vulnerable_functions": ["distribute", "_calculateSplit"]
  },
  "context_files": [],
  "call_flow": "Accidental.transfer(USDSC, RewardRedist) → balanceBefore += donation → Operator.distribute() → _calculateSplit(gross=minted+donation) → S_base understated → yield split incorrect → treasury loses yield",
  "context_hint": "This is a classic accounting bug in yield distribution systems. The contract conflates 'accidental contract balance' with 'yield to distribute'. The fix requires separating the concept of 'minted yield' from 'total contract balance'. This pattern appears in many protocols that didn't anticipate users sending tokens directly to the contract.",
  "is_vulnerable": true,
  "expert_notes": "While donations are rare, this is a real risk in protocols that interface with multiple entities. The impact scales linearly with donation size and is avoidable with proper accounting separation. Similar issues have appeared in Curve gauges and Compound treasury management where accidental transfers disrupted expected mathematics."
}
]