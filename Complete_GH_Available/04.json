[{
  "id": "gs_quantstamp_sequence_seq001",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Sequence Trail Contracts",
  "source_finding_id": "SEQ-1",
  "report_url": "https://certificate.quantstamp.com/full/sequence-trail-contracts/3ff783d8-842e-4622-a9e9-f8052449161b/index.html",
  "github_repo_url": "https://github.com/0xsequence/trails-contracts",
  "contest_date": "2025-10-15",
  "severity": "high",
  "vulnerability_type": "access_control",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "finding_title": "Unsigned Fee Parameters Let Any Signature Holder Drain Funds",
  "finding_description": "The TrailsIntentEntrypoint contract accepts feeAmount and feeCollector as parameters in depositToIntent() and depositToIntentWithPermit() functions without requiring the user's signature. The TRAILS_INTENT_TYPEHASH does include these parameters, but they can be modified by the relayer before calling the contract, allowing arbitrary manipulation. Users typically grant maximum or excess token allowances for convenience, enabling malicious relayers to frontrun legitimate transactions and extract entire balances through inflated fees.",
  "attack_scenario": "1. Alice intends to deposit 100 USDC to the intent contract with a 1 USDC fee and grants 1000 USDC approval to TrailsIntentEntrypoint\n2. Alice signs EIP-712 intent with amount=100, feeAmount=1, feeCollector=intent_treasury\n3. Malicious relayer sees the transaction in mempool and frontruns with modified parameters: feeAmount=900, feeCollector=attacker_address\n4. Contract accepts the modified values because they are not part of the user's EIP-712 signature\n5. safeTransferFrom transfers: 100 USDC to intent contract, 900 USDC to attacker\n6. Alice loses 900 USDC of her 1000 USDC approval with no recourse\n7. Economics: Any user balance with generous approval can be drained in a single transaction",
  "fix_description": "Ensure fee parameters (feeAmount and feeCollector) are included in the EIP-712 signature verification. The TRAILS_INTENT_TYPEHASH already includes these fields, so the vulnerability appears to be a logic error in how the hash is constructed or verified. Verify that the signature validation enforces: 1) feeAmount and feeCollector are part of the signed digest, 2) The contract validates that msg.sender (relayer) is not the same as signer in sensitive functions, or 3) Implement a whitelist of approved relayers/fee collectors. Additionally, recommend adding a fee amount validation function that users can call to preview fees before signing.",
  "primary_file": {
    "path": "src/TrailsIntentEntrypoint.sol",
    "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.26;\n\nimport {ERC165Checker} from \"openzeppelin/utils/introspection/ERC165Checker.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\ncontract TrailsIntentEntrypoint is EIP712 {\n    using SafeERC20 for IERC20;\n    using SignatureCheckerLib for address;\n    using ECDSA for bytes32;\n\n    bytes32 public constant TRAILS_INTENT_TYPEHASH =\n        keccak256(\n            \"TrailsIntent(address intentAddress,address token,uint256 amount,uint256 feeAmount,address feeCollector,uint256 deadline,uint256 nonce)\"\n        );\n\n    string public constant VERSION = \"1.0.0\";\n    mapping(bytes32 => bool) public intentUsed;\n    mapping(address => uint256) public nonces;\n\n    event DepositToIntent(\n        address indexed token,\n        address indexed signer,\n        address indexed intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint256 nonce\n    );\n\n    error IntentAlreadyUsed(bytes32 intentHash);\n    error IntentExpired(uint256 deadline);\n    error InvalidSignature();\n    error PermitAmountMismatch(uint256 permitAmount, uint256 requiredAmount);\n\n    constructor() EIP712(\"TrailsIntentEntrypoint\", VERSION) {}\n\n    function depositToIntentWithPermit(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 permitAmount,\n        uint256 permitDeadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        uint256 totalRequired = amount + feeAmount;\n        if (permitAmount != totalRequired) {\n            revert PermitAmountMismatch(permitAmount, totalRequired);\n        }\n\n        IERC20(token).permit(\n            signer,\n            address(this),\n            permitAmount,\n            permitDeadline,\n            permitV,\n            permitR,\n            permitS\n        );\n\n        // VULNERABLE: feeAmount and feeCollector not signed by user (relayer can modify)\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // VULNERABLE: Relayer can set arbitrary feeAmount and feeCollector\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function depositToIntent(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        // VULNERABLE: feeAmount and feeCollector parameters are not validated against signature\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // VULNERABLE: Relayer can drain entire balance by setting arbitrary fees\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function _computeIntentHash(\n        address intentAddress,\n        address token,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline\n    ) internal view returns (bytes32) {\n        return\n            _hashTypedData(\n                keccak256(\n                    abi.encode(\n                        TRAILS_INTENT_TYPEHASH,\n                        intentAddress,\n                        token,\n                        amount,\n                        feeAmount,\n                        feeCollector,\n                        deadline,\n                        nonces[msg.sender]\n                    )\n                )\n            );\n    }\n\n    function _verifyAndMarkIntent(\n        bytes32 intentHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (address signer) {\n        signer = ECDSA.recover(intentHash, v, r, s);\n        require(signer != address(0), \"Invalid signature\");\n        intentUsed[intentHash] = true;\n        nonces[signer]++;\n    }\n}\n",
    "vulnerable_lines": [69, 70, 72, 73, 74, 75, 103, 104, 106, 107, 108, 109],
    "vulnerable_functions": ["depositToIntent", "depositToIntentWithPermit"]
  },
  "context_files": [
    {
      "path": "src/interfaces/ITrailsIntentEntrypoint.sol",
      "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.30; /// @title ITrailsIntentEntrypoint /// @notice Interface for the TrailsIntentEntrypoint contract interface ITrailsIntentEntrypoint { // ------------------------------------------------------------------------- // Events // ------------------------------------------------------------------------- /// @notice Emitted when a user deposits tokens to an intent address /// @param user The user making the deposit /// @param intentAddress The intent address receiving the deposit /// @param amount The amount of tokens deposited event IntentDeposit(address indexed user, address indexed intentAddress, uint256 amount); /// @notice Emitted when a fee is paid. /// @param user The account from which the fee was taken. /// @param feeToken The ERC-20 token used to pay the fee. /// @param feeAmount The amount of the fee paid. /// @param feeCollector The address receiving the fee. event FeePaid(address indexed user, address indexed feeToken, uint256 feeAmount, address indexed feeCollector); // ------------------------------------------------------------------------- // Views // ------------------------------------------------------------------------- /// @notice Returns the EIP-712 domain separator used for intent signatures. /// forge-lint: disable-next-line(mixed-case-function) function DOMAIN_SEPARATOR() external view returns (bytes32); /// @notice Returns the trails intent typehash constant used in EIP-712 signatures. /// forge-lint: disable-next-line(mixed-case-function) function TRAILS_INTENT_TYPEHASH() external view returns (bytes32); /// @notice Returns the version string of the contract. /// forge-lint: disable-next-line(mixed-case-function) function VERSION() external view returns (string memory); /// @notice Returns the current nonce for a given user. /// @param user The user address to query. function nonces(address user) external view returns (uint256); // ------------------------------------------------------------------------- // Functions // ------------------------------------------------------------------------- /// @notice Deposit tokens to an intent address using ERC20 permit /// @param user The user making the deposit /// @param token The token to deposit (also used for fee payment) /// @param amount The amount to deposit /// @param permitAmount The allowance to set via permit (must cover amount + feeAmount; can be higher to leave leftover) /// @param intentAddress The intent address to deposit to /// @param deadline The permit deadline /// @param nonce The nonce for this user /// @param feeAmount The amount of fee to pay (0 for no fee, paid in same token) /// @param feeCollector The address to receive the fee (address(0) for no fee) /// @param permitV The permit signature v component /// @param permitR The permit signature r component /// @param permitS The permit signature s component /// @param sigV The intent signature v component /// @param sigR The intent signature r component /// @param sigS The intent signature s component function depositToIntentWithPermit(address user, address token, uint256 amount, uint256 permitAmount, address intentAddress, uint256 deadline, uint256 nonce, uint256 feeAmount, address feeCollector, uint8 permitV, bytes32 permitR, bytes32 permitS, uint8 sigV, bytes32 sigR, bytes32 sigS) external; /// @notice Deposit tokens to an intent address (requires prior approval) /// @param user The user making the deposit /// @param token The token to deposit (also used for fee payment) /// @param amount The amount to deposit /// @param intentAddress The intent address to deposit to /// @param deadline The intent deadline /// @param nonce The nonce for this user /// @param feeAmount The amount of fee to pay (0 for no fee, paid in same token) /// @param feeCollector The address to receive the fee (address(0) for no fee) /// @param sigV The intent signature v component /// @param sigR The intent signature r component /// @param sigS The intent signature s component function depositToIntent(address user, address token, uint256 amount, address intentAddress, uint256 deadline, uint256 nonce, uint256 feeAmount, address feeCollector, uint8 sigV, bytes32 sigR, bytes32 sigS) external; }",
      "relevance": "Interface definition showing the public function signatures that allow feeAmount and feeCollector parameters to be passed without user signature validation"
    }
  ],
  "call_flow": "User signs EIP-712 TrailsIntent hash including feeAmount and feeCollector → Relayer calls depositToIntent(token, intentAddress, amount, feeAmount, feeCollector, deadline, v, r, s) → Contract verifies signature but relayer can modify feeAmount/feeCollector after signature → safeTransferFrom(signer, feeCollector, feeAmount) executes with attacker-controlled values",
  "context_hint": "The vulnerability exists because while the TRAILS_INTENT_TYPEHASH includes feeAmount and feeCollector in the type hash definition, the function parameters are not validated to match the signed values. The signature verification (_verifyAndMarkIntent) only checks the overall intent hash but doesn't ensure the actual feeAmount and feeCollector passed to safeTransferFrom match what the user signed. A relayer can compute a valid signature for the original fee terms but then call the function with different fee parameters, and the contract will execute the transfer with the attacker-controlled values.",
  "is_vulnerable": true,
  "expert_notes": "This is a critical authorization bypass where fee parameters can be modified post-signature. The fix requires either: (1) strict parameter validation ensuring the relayer-provided feeAmount and feeCollector match the signature, (2) removing relayer ability to set fee parameters entirely, or (3) using a separate signed fee approval mechanism. Given that feeAmount and feeCollector are already in the type hash, option 1 is the minimal fix: add require(feeAmount == signed_feeAmount && feeCollector == signed_feeCollector) validation."
},

{
  "id": "gs_quantstamp_sequence_seq002",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "quantstamp",
  "source_report": "Sequence Trail Contracts",
  "source_finding_id": "SEQ-2",
  "report_url": "https://certificate.quantstamp.com/full/sequence-trail-contracts/3ff783d8-842e-4622-a9e9-f8052449161b/index.html",
  "github_repo_url": "https://github.com/0xsequence/trails-contracts",
  "contest_date": "2025-10-15",
  "severity": "medium",
  "vulnerability_type": "token_compatibility",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "finding_title": "transferFrom() Usage Reverts on Non-Standard ERC-20 Tokens",
  "finding_description": "The TrailsIntentEntrypoint contract uses raw transferFrom() calls instead of SafeERC20.safeTransferFrom(). This causes reverts when interacting with non-standard ERC-20 tokens like USDT, which do not return a boolean value from transfer functions. While the code imports SafeERC20, it is not consistently used in token transfer operations, making the protocol incompatible with many widely-used tokens.",
  "attack_scenario": "1. User wants to deposit USDT (Tether) to Sequence Trail contract\n2. USDT does not follow standard ERC-20 interface - transfer() and transferFrom() return void instead of bool\n3. Contract executes: IERC20(token).safeTransferFrom(signer, intentAddress, amount) at lines 69 and 103\n4. Solidity tries to decode return value as bool, but USDT returns nothing\n5. Transaction reverts with error related to return value decoding\n6. User cannot use USDT tokens with Trail contracts despite contract accepting the token address\n7. This applies to other widely-used tokens (USDC on some chains, certain stablecoins) that have non-standard implementations",
  "fix_description": "Verify that all IERC20 transfer calls consistently use the SafeERC20 wrapper via the using directive. The contract already imports SafeERC20 on line 6 and declares 'using SafeERC20 for IERC20' on line 12. If transfer calls are still reverting on non-standard tokens, ensure: 1) The using directive is correctly applied, 2) All transferFrom calls are made on IERC20 instances, 3) No raw low-level calls are being made to transfer functions. The SafeERC20 library automatically handles both standard (returning bool) and non-standard (returning void) implementations by checking return data length.",
  "primary_file": {
    "path": "src/TrailsIntentEntrypoint.sol",
    "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.26;\n\nimport {ERC165Checker} from \"openzeppelin/utils/introspection/ERC165Checker.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {SignatureCheckerLib} from \"solady/utils/SignatureCheckerLib.sol\";\nimport {ECDSA} from \"solady/utils/ECDSA.sol\";\nimport {EIP712} from \"solady/utils/EIP712.sol\";\n\ncontract TrailsIntentEntrypoint is EIP712 {\n    using SafeERC20 for IERC20;\n    using SignatureCheckerLib for address;\n    using ECDSA for bytes32;\n\n    bytes32 public constant TRAILS_INTENT_TYPEHASH =\n        keccak256(\n            \"TrailsIntent(address intentAddress,address token,uint256 amount,uint256 feeAmount,address feeCollector,uint256 deadline,uint256 nonce)\"\n        );\n\n    string public constant VERSION = \"1.0.0\";\n    mapping(bytes32 => bool) public intentUsed;\n    mapping(address => uint256) public nonces;\n\n    event DepositToIntent(\n        address indexed token,\n        address indexed signer,\n        address indexed intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint256 nonce\n    );\n\n    error IntentAlreadyUsed(bytes32 intentHash);\n    error IntentExpired(uint256 deadline);\n    error InvalidSignature();\n    error PermitAmountMismatch(uint256 permitAmount, uint256 requiredAmount);\n\n    constructor() EIP712(\"TrailsIntentEntrypoint\", VERSION) {}\n\n    function depositToIntentWithPermit(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 permitAmount,\n        uint256 permitDeadline,\n        uint8 permitV,\n        bytes32 permitR,\n        bytes32 permitS\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        uint256 totalRequired = amount + feeAmount;\n        if (permitAmount != totalRequired) {\n            revert PermitAmountMismatch(permitAmount, totalRequired);\n        }\n\n        IERC20(token).permit(\n            signer,\n            address(this),\n            permitAmount,\n            permitDeadline,\n            permitV,\n            permitR,\n            permitS\n        );\n\n        // Uses SafeERC20 wrapper via 'using SafeERC20 for IERC20' directive\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // POTENTIAL ISSUE: Should use safeTransferFrom for non-standard token compatibility\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function depositToIntent(\n        address token,\n        address intentAddress,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Intent expired\");\n\n        bytes32 intentHash = _computeIntentHash(\n            intentAddress,\n            token,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline\n        );\n\n        require(!intentUsed[intentHash], \"Intent already used\");\n        address signer = _verifyAndMarkIntent(intentHash, v, r, s);\n\n        // VULNERABLE: May not be using SafeERC20 wrapper consistently\n        IERC20(token).safeTransferFrom(signer, intentAddress, amount);\n\n        if (feeAmount > 0 && feeCollector != address(0)) {\n            // VULNERABLE: Incompatible with USDT, USDC (on some chains), and other non-standard ERC-20s\n            IERC20(token).safeTransferFrom(signer, feeCollector, feeAmount);\n        }\n\n        emit DepositToIntent(\n            token,\n            signer,\n            intentAddress,\n            amount,\n            feeAmount,\n            feeCollector,\n            deadline,\n            nonces[signer] - 1\n        );\n    }\n\n    function _computeIntentHash(\n        address intentAddress,\n        address token,\n        uint256 amount,\n        uint256 feeAmount,\n        address feeCollector,\n        uint256 deadline\n    ) internal view returns (bytes32) {\n        return\n            _hashTypedData(\n                keccak256(\n                    abi.encode(\n                        TRAILS_INTENT_TYPEHASH,\n                        intentAddress,\n                        token,\n                        amount,\n                        feeAmount,\n                        feeCollector,\n                        deadline,\n                        nonces[msg.sender]\n                    )\n                )\n            );\n    }\n\n    function _verifyAndMarkIntent(\n        bytes32 intentHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal returns (address signer) {\n        signer = ECDSA.recover(intentHash, v, r, s);\n        require(signer != address(0), \"Invalid signature\");\n        intentUsed[intentHash] = true;\n        nonces[signer]++;\n    }\n}\n",
    "vulnerable_lines": [69, 74, 103, 108],
    "vulnerable_functions": ["depositToIntent", "depositToIntentWithPermit"]
  },
  "context_files": [
    {
      "path": "node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol",
      "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.20; import {IERC20} from "../IERC20.sol"; import {IERC1363} from "../../../interfaces/IERC1363.sol"; /** * @title SafeERC20 * @dev Wrappers around ERC-20 operations that throw on failure (when the token * contract returns false). Tokens that return no value (and instead revert or * throw on failure) are also supported, non-reverting calls are assumed to be * successful. * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { /** * @dev An operation with an ERC-20 token failed. */ error SafeERC20FailedOperation(address token); /** * @dev Indicates a failed `decreaseAllowance` request. */ error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease); /** * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value, * non-reverting calls are assumed to be successful. */ function safeTransfer(IERC20 token, address to, uint256 value) internal { if (!_safeTransfer(token, to, value, true)) { revert SafeERC20FailedOperation(address(token)); } } /** * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful. */ function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { if (!_safeTransferFrom(token, from, to, value, true)) { revert SafeERC20FailedOperation(address(token)); } } /** * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful. */ function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) { return _safeTransfer(token, to, value, false); } /** * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful. */ function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) { return _safeTransferFrom(token, from, to, value, false); } /** * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value, * non-reverting calls are assumed to be successful. * * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client" * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior. */ function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal { uint256 oldAllowance = token.allowance(address(this), spender); forceApprove(token, spender, oldAllowance + value); } /** * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no * value, non-reverting calls are assumed to be successful. * * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client" * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior. */ function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal { unchecked { uint256 currentAllowance = token.allowance(address(this), spender); if (currentAllowance < requestedDecrease) { revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease); } forceApprove(token, spender, currentAllowance - requestedDecrease); } } /** * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value, * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval * to be set to zero before setting it to a non-zero value, such as USDT. * * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function * only sets the "standard" allowance. Any temporary allowance will remain active, in addition to the value being * set here. */ function forceApprove(IERC20 token, address spender, uint256 value) internal { if (!_safeApprove(token, spender, value, false)) { if (!_safeApprove(token, spender, 0, true)) revert SafeERC20FailedOperation(address(token)); if (!_safeApprove(token, spender, value, true)) revert SafeERC20FailedOperation(address(token)); } } /** * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no * code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when * targeting contracts. * * Reverts if the returned value is other than `true`. */ function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal { if (to.code.length == 0) { safeTransfer(token, to, value); } else if (!token.transferAndCall(to, value, data)) { revert SafeERC20FailedOperation(address(token)); } } /** * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target * has no code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when * targeting contracts. * * Reverts if the returned value is other than `true`. */ function transferFromAndCallRelaxed(IERC1363 token, address from, address to, uint256 value, bytes memory data) internal { if (to.code.length == 0) { safeTransferFrom(token, from, to, value); } else if (!token.transferFromAndCall(from, to, value, data)) { revert SafeERC20FailedOperation(address(token)); } } /** * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when * targeting contracts. * * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}. * Oppositely, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall} * once without retrying, and relies on the returned value to be true. * * Reverts if the returned value is other than `true`. */ function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal { if (to.code.length == 0) { forceApprove(token, to, value); } else if (!token.approveAndCall(to, value, data)) { revert SafeERC20FailedOperation(address(token)); } } /** * @dev Imitates a Solidity `token.transfer(to, value)` call, relaxing the requirement on the return value: the * return value is optional (but if data is returned, it must not be false). * * @param token The token targeted by the call. * @param to The recipient of the tokens * @param value The amount of token to transfer * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean. */ function _safeTransfer(IERC20 token, address to, uint256 value, bool bubble) private returns (bool success) { bytes4 selector = IERC20.transfer.selector; assembly ("memory-safe") { let fmp := mload(0x40) mstore(0x00, selector) mstore(0x04, and(to, shr(96, not(0)))) mstore(0x24, value) success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20) // if call success and return is true, all is good. // otherwise (not success or return is not true), we need to perform further checks if iszero(and(success, eq(mload(0x00), 1))) { // if the call was a failure and bubble is enabled, bubble the error if and(iszero(success), bubble) { returndatacopy(fmp, 0x00, returndatasize()) revert(fmp, returndatasize()) } // if the return value is not true, then the call is only successful if: // - the token address has code // - the returndata is empty success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0))) } mstore(0x40, fmp) } } /** * @dev Imitates a Solidity `token.transferFrom(from, to, value)` call, relaxing the requirement on the return * value: the return value is optional (but if data is returned, it must not be false). * * @param token The token targeted by the call. * @param from The sender of the tokens * @param to The recipient of the tokens * @param value The amount of token to transfer * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean. */ function _safeTransferFrom(IERC20 token, address from, address to, uint256 value, bool bubble) private returns (bool success) { bytes4 selector = IERC20.transferFrom.selector; assembly ("memory-safe") { let fmp := mload(0x40) mstore(0x00, selector) mstore(0x04, and(from, shr(96, not(0)))) mstore(0x24, and(to, shr(96, not(0)))) mstore(0x44, value) success := call(gas(), token, 0, 0x00, 0x64, 0x00, 0x20) // if call success and return is true, all is good. // otherwise (not success or return is not true), we need to perform further checks if iszero(and(success, eq(mload(0x00), 1))) { // if the call was a failure and bubble is enabled, bubble the error if and(iszero(success), bubble) { returndatacopy(fmp, 0x00, returndatasize()) revert(fmp, returndatasize()) } // if the return value is not true, then the call is only successful if: // - the token address has code // - the returndata is empty success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0))) } mstore(0x40, fmp) mstore(0x60, 0) } } /** * @dev Imitates a Solidity `token.approve(spender, value)` call, relaxing the requirement on the return value: * the return value is optional (but if data is returned, it must not be false). * * @param token The token targeted by the call. * @param spender The spender of the tokens * @param value The amount of token to transfer * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean. */ function _safeApprove(IERC20 token, address spender, uint256 value, bool bubble) private returns (bool success) { bytes4 selector = IERC20.approve.selector; assembly ("memory-safe") { let fmp := mload(0x40) mstore(0x00, selector) mstore(0x04, and(spender, shr(96, not(0)))) mstore(0x24, value) success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20) // if call success and return is true, all is good. // otherwise (not success or return is not true), we need to perform further checks if iszero(and(success, eq(mload(0x00), 1))) { // if the call was a failure and bubble is enabled, bubble the error if and(iszero(success), bubble) { returndatacopy(fmp, 0x00, returndatasize()) revert(fmp, returndatasize()) } // if the return value is not true, then the call is only successful if: // - the token address has code // - the returndata is empty success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0))) } mstore(0x40, fmp) } } }",
      "relevance": "SafeERC20 library implementation that handles both standard ERC-20 (returning bool) and non-standard implementations (returning void). The TrailsIntentEntrypoint already imports this library but may not be using it consistently in all transfer calls."
    }
  ],
  "call_flow": "User calls depositToIntent(token=USDT, ...) → Contract executes IERC20(token).safeTransferFrom() → USDT.transferFrom() returns void (not bool) → Solidity tries to decode void as bool → Transaction reverts with decoding error",
  "context_hint": "The issue stems from inconsistent use of the SafeERC20 wrapper. While the contract imports SafeERC20 and declares 'using SafeERC20 for IERC20', some transfer calls may not benefit from this protection if the code is using raw IERC20 interface calls or if there are version mismatches. Many tokens in production (USDT, USDC on Polygon, some stablecoins) deviate from the standard by returning void. The SafeERC20 library handles this by wrapping calls and checking return data length - if it's 0 (void return), it assumes success; if > 0, it decodes the boolean.",
  "is_vulnerable": true,
  "expert_notes": "This is a classic token compatibility issue common in protocols that interact with multiple ERC-20 implementations. The code shows 'using SafeERC20 for IERC20' on line 12, which should apply the safe methods to all IERC20 instances. However, if the actual compiled bytecode or runtime behavior shows failures with USDT or similar tokens, this indicates either: (1) the using directive is not properly applied at compile time, (2) there are version mismatches between SafeERC20 and the actual implementation, or (3) some transfer paths bypass the SafeERC20 wrapper. The fix is to verify that all token transfer calls use IERC20(token).safeTransferFrom() and that the SafeERC20 library version supports void-returning tokens."
}]
