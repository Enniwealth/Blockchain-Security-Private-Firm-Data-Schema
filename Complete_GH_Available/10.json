[
  {
    "id": "gs_cantina_kyber_001",
    "report_url": "https://cantina.xyz/portfolio/eb59f23b-ef3c-4b3c-9d28-3455d5337d3f",
    "project_name": "Kyber Hook",
    "github_url": "https://github.com/KyberNetwork/kyber-exclusive-amm-sc",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-03",
    "vulnerability_type": "signature_validation",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "cross_contract",
    "is_vulnerable": true,
    "title": "Signed Swap Digest Lacks a Domain Separator Enabling Cross-Chain Signature Replay",
    "description": "The Kyber hooks (UniswapV4KEMHook and PancakeSwapInfinityKEMHook) rebuild a quote digest by hashing sender, pool key, trade parameters, nonce, and expiry time without including a domain separator. This omission allows valid signatures from one blockchain to be replayed on another where the same hook instance is deployed, breaking the single-instance authorization guarantee.",
    "primary_file": {
      "name": "UniswapV4KEMHook.sol",
      "path": "src/UniswapV4KEMHook.sol",
      "lines": "45-65",
      "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.26; import {BaseKEMHook} from './base/BaseKEMHook.sol'; import {IKEMHook} from './interfaces/IKEMHook.sol'; import {HookDataDecoder} from './libraries/HookDataDecoder.sol'; import {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol'; import {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol'; import {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol'; import {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol'; import {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol'; import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol'; import {Currency} from 'uniswap/v4-core/src/types/Currency.sol'; import {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol'; import {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol'; import {SignatureChecker} from 'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol'; /// @title UniswapV4KEMHook contract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback { /// @notice Thrown when the caller is not PoolManager error NotPoolManager(); /// @notice The address of the PoolManager contract IPoolManager public immutable poolManager; constructor(IPoolManager _poolManager, address initialOwner, address[] memory initialClaimableAccounts, address initialQuoteSigner, address initialEgRecipient) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) { poolManager = _poolManager; Hooks.validateHookPermissions(IHooks(address(this)), getHookPermissions()); } /// @notice Only allow calls from the PoolManager contract modifier onlyPoolManager() { if (msg.sender != address(poolManager)) revert NotPoolManager(); _; } /// @inheritdoc IKEMHook function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public { require(claimable[msg.sender], NonClaimableAccount(msg.sender)); require(tokens.length == amounts.length, MismatchedArrayLengths()); poolManager.unlock(abi.encode(tokens, amounts)); } function unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) { (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[])); for (uint256 i = 0; i < tokens.length; i++) { uint256 id = uint256(uint160(tokens[i])); if (amounts[i] == 0) { amounts[i] = poolManager.balanceOf(address(this), id); } if (amounts[i] > 0) { poolManager.burn(address(this), id, amounts[i]); poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]); } } emit ClaimEgTokens(egRecipient, tokens, amounts); } function getHookPermissions() public pure returns (Hooks.Permissions memory) { return Hooks.Permissions({ beforeInitialize: false, afterInitialize: false, beforeAddLiquidity: false, afterAddLiquidity: false, beforeRemoveLiquidity: false, afterRemoveLiquidity: false, beforeSwap: true, afterSwap: true, beforeDonate: false, afterDonate: false, beforeSwapReturnDelta: false, afterSwapReturnDelta: true, afterAddLiquidityReturnDelta: false, afterRemoveLiquidityReturnDelta: false }); } function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) { require(params.amountSpecified < 0, ExactOutputDisabled()); ( int256 maxAmountIn, int256 maxExchangeRate, int256 exchangeRateDenom, uint256 nonce, uint256 expiryTime, bytes memory signature ) = HookDataDecoder.decodeAllHookData(hookData); require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp)); require(-params.amountSpecified <= maxAmountIn, ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)); _useUnorderedNonce(nonce); bytes32 digest = keccak256(abi.encode(sender, key, params.zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, expiryTime)); require(SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()); return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0); } function afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta, bytes calldata hookData) external onlyPoolManager returns (bytes4, int128) { (int256 maxExchangeRate, int256 exchangeRateDenom) = HookDataDecoder.decodeExchangeRate(hookData); int128 amountIn; int128 amountOut; Currency currencyOut; unchecked { if (params.zeroForOne) { amountIn = -delta.amount0(); amountOut = delta.amount1(); currencyOut = key.currency1; } else { amountIn = -delta.amount1(); amountOut = delta.amount0(); currencyOut = key"
    },
    "context_files": [
      {
        "name": "PancakeSwapInfinityKEMHook.sol",
        "path": "src/PancakeSwapInfinityKEMHook.sol",
        "relevance": "Identical vulnerable digest construction without domain separator",
        "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.26; import {BaseKEMHook} from './base/BaseKEMHook.sol'; import {IKEMHook} from './interfaces/IKEMHook.sol'; import {HookDataDecoder} from './libraries/HookDataDecoder.sol'; import {IVault} from 'pancakeswap/infinity-core/src/interfaces/IVault.sol'; import {ICLPoolManager} from 'pancakeswap/infinity-core/src/pool-cl/interfaces/ICLPoolManager.sol'; import {BalanceDelta} from 'pancakeswap/infinity-core/src/types/BalanceDelta.sol'; import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from 'pancakeswap/infinity-core/src/types/BeforeSwapDelta.sol'; import {Currency} from 'pancakeswap/infinity-core/src/types/Currency.sol'; import {PoolId} from 'pancakeswap/infinity-core/src/types/PoolId.sol'; import {PoolKey} from 'pancakeswap/infinity-core/src/types/PoolKey.sol'; import {HOOKS_AFTER_SWAP_OFFSET, HOOKS_AFTER_SWAP_RETURNS_DELTA_OFFSET, HOOKS_BEFORE_SWAP_OFFSET} from 'pancakeswap/infinity-core/src/pool-cl/interfaces/ICLHooks.sol'; import {SignatureChecker} from 'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol'; /// @title PancakeSwapInfinityKEMHook contract PancakeSwapInfinityKEMHook is BaseKEMHook { /// @notice Thrown when the caller is not PoolManager error NotPoolManager(); /// @notice Thrown when the caller is not Vault error NotVault(); /// @notice The address of the PoolManager contract ICLPoolManager public immutable poolManager; /// @notice The address of the Vault contract IVault public immutable vault; constructor(ICLPoolManager _poolManager, address initialOwner, address[] memory initialClaimableAccounts, address initialQuoteSigner, address initialEgRecipient) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) { poolManager = _poolManager; vault = _poolManager.vault(); } /// @notice Only allow calls from the PoolManager contract modifier onlyPoolManager() { if (msg.sender != address(poolManager)) revert NotPoolManager(); _; } /// @notice Only allow calls from the Vault contract modifier onlyVault() { if (msg.sender != address(vault)) revert NotVault(); _; } /// @inheritdoc IKEMHook function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public { require(claimable[msg.sender], NonClaimableAccount(msg.sender)); require(tokens.length == amounts.length, MismatchedArrayLengths()); vault.lock(abi.encode(tokens, amounts)); } function lockAcquired(bytes calldata data) public onlyVault returns (bytes memory) { (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[])); for (uint256 i = 0; i < tokens.length; i++) { Currency currency = Currency.wrap(tokens[i]); if (amounts[i] == 0) { amounts[i] = vault.balanceOf(address(this), currency); } if (amounts[i] > 0) { vault.burn(address(this), currency, amounts[i]); vault.take(currency, egRecipient, amounts[i]); } } emit ClaimEgTokens(egRecipient, tokens, amounts); } function getHooksRegistrationBitmap() external pure returns (uint16) { return uint16((1 << HOOKS_BEFORE_SWAP_OFFSET) | (1 << HOOKS_AFTER_SWAP_OFFSET) | (1 << HOOKS_AFTER_SWAP_RETURNS_DELTA_OFFSET)); } function beforeSwap(address sender, PoolKey calldata key, ICLPoolManager.SwapParams calldata params, bytes calldata hookData) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) { require(params.amountSpecified < 0, ExactOutputDisabled()); ( int256 maxAmountIn, int256 maxExchangeRate, int256 exchangeRateDenom, uint256 nonce, uint256 expiryTime, bytes memory signature ) = HookDataDecoder.decodeAllHookData(hookData); require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp)); require(-params.amountSpecified <= maxAmountIn, ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)); _useUnorderedNonce(nonce); bytes32 digest = keccak256(abi.encode(sender, key, params.zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, expiryTime)); require(SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()); return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0); } function afterSwap(address, PoolKey calldata key, ICLPoolManager.SwapParams calldata params, BalanceDelta delta, bytes calldata hookData) external onlyPoolManager returns (bytes4, int128) { (int256 maxExchangeRate, int256 exchangeRateDenom) = HookDataDecoder.decodeExchangeRate(hookData); int128 amountIn; int128 amountOut; Currency currencyOut; unchecked { if (params.zeroForOne) { amountIn = -delta.amount0(); amountOut = delta.amount1(); currencyOut = key.currency1; } else { amountIn = -delta.amount1(); amountOut = delta.amount0(); currencyOut = key.currency0; } } int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom; unchecked { int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0); if (egAmount > 0) { vault.mint(address(this), currencyOut, uint256(egAmount)); emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount); } return (this.afterSwap.selector, int128(egAmount)); } } }"
      },
      {
        "name": "EIP-712 Domain Specification",
        "path": "reference/EIP-712",
        "relevance": "Standard for domain separation in cryptographic signatures",
        "content": "struct EIP712Domain {\n    string name;\n    string version;\n    uint256 chainId;\n    address verifyingContract;\n}\n\n// Domain separator should be computed and included in signed payload\nbytes32 domainSeparator = keccak256(\n    abi.encode(\n        EIP712_TYPEHASH,\n        keccak256(bytes(\"Kyber\n\")),\n        keccak256(bytes(\"1\")),\n        block.chainid,\n        address(this)\n    )\n);"
      }
    ],
    "call_flow": [
      "1. Attacker obtains valid signature and nonce from Chain A (Ethereum mainnet)",
      "2. Kyber deploys identical hook to Chain B (Polygon) using CREATE3 salt mining",
      "3. Same PoolKey exists on Chain B (same tokens, same hook address via CREATE3)",
      "4. Attacker broadcasts same signature + calldata on Chain B",
      "5. SwapDigest computed identically (no chainId or contract identity in hash)",
      "6. SignatureChecker.isValidSignatureNow() validates successfully",
      "7. Swap executes without original signer's authorization on Chain B",
      "8. Attack repeats across all chains where hook is deployed"
    ],
    "context_hint": "The vulnerability exploits the lack of domain separation in EIP-712 signature construction. By omitting chainId, verifying contract address, and deployment salt from the digest, the same signed payload becomes valid across all networks. This breaks the intended authorization model where each network should have independent quote validation.",
    "expert_notes": "This is a critical EIP-712 pattern violation. The digest construction fails to commit to: (1) chain identity (block.chainid), (2) contract identity (address(this)), and (3) deployment context (salt). CREATE3 enables deterministic addresses across chains, making this replay vector practical. The fix requires adopting proper EIP-712 domain separation with at minimum block.chainid inclusion. Kyber's mitigation of chain-specific operator signing keys reduces but does not eliminate the attack surface if signatures are ever shared or if the operator key is compromised.",
    "fix_description": "Implement EIP-712 domain separation by computing and including a domain separator in the signed payload.",
    "fix_code": "bytes32 DOMAIN_SEPARATOR = keccak256(\n    abi.encode(\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n        keccak256(bytes(\"KyberHook\")),\n        keccak256(bytes(\"1\")),\n        block.chainid,\n        address(this)\n    )\n);\n\nfunction beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData) external override returns (bytes4) {\n    (bytes memory sig, uint256 nonce, uint256 expiryTime) = abi.decode(hookData, (bytes, uint256, uint256));\n    \n    bytes32 swapDigest = keccak256(\n        abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR,\n            keccak256(\n                abi.encode(\n                    keccak256(\"SwapQuote(address sender,PoolKey key,bool zeroForOne,int256 amountSpecified,uint160 sqrtPriceLimitX96,uint256 nonce,uint256 expiryTime)\"),\n                    sender,\n                    key,\n                    params.zeroForOne,\n                    params.amountSpecified,\n                    params.sqrtPriceLimitX96,\n                    nonce,\n                    expiryTime\n                )\n            )\n        )\n    );\n    \n    require(SignatureChecker.isValidSignatureNow(quoteSigner, swapDigest, sig), \"Invalid signature\");\n    _useUnorderedNonce(nonce);\n    return IHooks.beforeSwap.selector;\n}"
  },
  {
    "id": "gs_cantina_kyber_002",
    "report_url": "https://cantina.xyz/portfolio/eb59f23b-ef3c-4b3c-9d28-3455d5337d3f",
    "project_name": "Kyber Hook",
    "github_url": "https://github.com/KyberNetwork/kyber-exclusive-amm-sc",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-10-03",
    "vulnerability_type": "frontrunning_nonce_invalidation",
    "severity": "medium",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Quotes Can Be Frontrun and Invalidated by MEV Bots Through Router-Level Nonce Consumption",
    "description": "The Kyber hooks validate signatures by checking that the sender field matches the router contract address, restricting execution to the Kyber router but not to any specific user. This allows MEV bots to copy any signed swap calldata from the mempool, replay it through the public router before the original transaction, consume the nonce, and invalidate the original quote with a dust transaction.",
    "primary_file": {
      "name": "UniswapV4KEMHook.sol",
      "path": "src/UniswapV4KEMHook.sol",
      "lines": "40-70",
      "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.26; import {BaseKEMHook} from './base/BaseKEMHook.sol'; import {IKEMHook} from './interfaces/IKEMHook.sol'; import {HookDataDecoder} from './libraries/HookDataDecoder.sol'; import {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol'; import {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol'; import {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol'; import {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol'; import {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol'; import {BeforeSwapDelta, BeforeSwapDeltaLibrary} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol'; import {Currency} from 'uniswap/v4-core/src/types/Currency.sol'; import {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol'; import {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol'; import {SignatureChecker} from 'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol'; /// @title UniswapV4KEMHook contract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback { /// @notice Thrown when the caller is not PoolManager error NotPoolManager(); /// @notice The address of the PoolManager contract IPoolManager public immutable poolManager; constructor(IPoolManager _poolManager, address initialOwner, address[] memory initialClaimableAccounts, address initialQuoteSigner, address initialEgRecipient) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) { poolManager = _poolManager; Hooks.validateHookPermissions(IHooks(address(this)), getHookPermissions()); } /// @notice Only allow calls from the PoolManager contract modifier onlyPoolManager() { if (msg.sender != address(poolManager)) revert NotPoolManager(); _; } /// @inheritdoc IKEMHook function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public { require(claimable[msg.sender], NonClaimableAccount(msg.sender)); require(tokens.length == amounts.length, MismatchedArrayLengths()); poolManager.unlock(abi.encode(tokens, amounts)); } function unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) { (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[])); for (uint256 i = 0; i < tokens.length; i++) { uint256 id = uint256(uint160(tokens[i])); if (amounts[i] == 0) { amounts[i] = poolManager.balanceOf(address(this), id); } if (amounts[i] > 0) { poolManager.burn(address(this), id, amounts[i]); poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]); } } emit ClaimEgTokens(egRecipient, tokens, amounts); } function getHookPermissions() public pure returns (Hooks.Permissions memory) { return Hooks.Permissions({ beforeInitialize: false, afterInitialize: false, beforeAddLiquidity: false, afterAddLiquidity: false, beforeRemoveLiquidity: false, afterRemoveLiquidity: false, beforeSwap: true, afterSwap: true, beforeDonate: false, afterDonate: false, beforeSwapReturnDelta: false, afterSwapReturnDelta: true, afterAddLiquidityReturnDelta: false, afterRemoveLiquidityReturnDelta: false }); } function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) { require(params.amountSpecified < 0, ExactOutputDisabled()); ( int256 maxAmountIn, int256 maxExchangeRate, int256 exchangeRateDenom, uint256 nonce, uint256 expiryTime, bytes memory signature ) = HookDataDecoder.decodeAllHookData(hookData); require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp)); require(-params.amountSpecified <= maxAmountIn, ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)); _useUnorderedNonce(nonce); bytes32 digest = keccak256(abi.encode(sender, key, params.zeroForOne, maxAmountIn, maxExchangeRate, exchangeRateDenom, nonce, expiryTime)); require(SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()); return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0); } function afterSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta, bytes calldata hookData) external onlyPoolManager returns (bytes4, int128) { (int256 maxExchangeRate, int256 exchangeRateDenom) = HookDataDecoder.decodeExchangeRate(hookData); int128 amountIn; int128 amountOut; Currency currencyOut; unchecked { if (params.zeroForOne) { amountIn = -delta.amount0(); amountOut = delta.amount1(); currencyOut = key.currency1; } else { amountIn = -delta.amount1(); amountOut = delta.amount0(); currencyOut = key.currency0; } } int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom; unchecked { int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0); if (egAmount > 0) { poolManager.mint(address(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)); emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount); } return (this.afterSwap.selector, int128(egAmount)); } } }"
    },
    "context_files": [
      {
        "name": "SimpleSwapRouter.sol",
        "path": "src/SimpleSwapRouter.sol",
        "relevance": "Public router that forwards all signed swap data without user authentication",
        "content": "contract SimpleSwapRouter {\n    IPoolManager public poolManager;\n    \n    // Public function - anyone can submit swaps on behalf of any signed calldata\n    function swap(\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata hookData\n    ) external payable {\n        // hookData contains signature + nonce + expiryTime\n        // No check that msg.sender is authorized to use this signature\n        poolManager.swap(key, params, hookData);\n    }\n}\n\n// MEV bot can extract and re-submit\nfunction frontrun(bytes calldata originalCalldata) external {\n    // Parse original transaction\n    (PoolKey memory key, IPoolManager.SwapParams memory params, bytes memory hookData) = abi.decode(originalCalldata, (PoolKey, IPoolManager.SwapParams, bytes));\n    \n    // Re-submit with same signature (sender field points to router)\n    router.swap{value: params.amountSpecified}(key, params, hookData);\n    // Nonce is consumed, original swap reverts\n}"
      },
      {
        "name": "NonceStorage.sol",
        "path": "src/NonceStorage.sol",
        "relevance": "Tracks used nonces, reverts on reuse",
        "content": "function _useUnorderedNonce(uint256 nonce) internal {\n    if (nonce == 0) return;  // Zero nonce special case\n    \n    uint256 wordPos = nonce >> 8;\n    uint256 bitPos = uint8(nonce);\n    uint256 bit = 1 << bitPos;\n    uint256 flipped = nonces[wordPos] ^= bit;\n    \n    if (flipped & bit == 0) revert NonceAlreadyUsed(nonce);  // Already used\n    emit UseNonce(nonce);\n}"
      }
    ],
    "call_flow": [
      "1. Alice broadcasts signed swap: signature(router, PoolKey, swapParams, amount, nonce=42, expiry=T+1h)",
      "2. MEV bot detects transaction in mempool",
      "3. Bot extracts calldata and signature (sender field = router address)",
      "4. Bot calls router.swap() with identical calldata, including nonce=42",
      "5. Hook validates signature: sender matches router ✓, signature valid ✓",
      "6. Hook calls _useUnorderedNonce(42) - marks nonce 42 as consumed",
      "7. Bot's transaction succeeds, consuming minimal liquidity (dust swap)",
      "8. Alice's original transaction arrives at mempool",
      "9. Hook validates signature again: sender ✓, signature ✓",
      "10. Hook calls _useUnorderedNonce(42) - reverts with NonceAlreadyUsed(42)",
      "11. Alice's transaction reverts, quote invalidated"
    ],
    "context_hint": "The vulnerability stems from router-level nonce validation instead of user-level validation. The signature commits to the router address (sender), not to the original caller (msg.sender within router). Since the Kyber router is a public contract accepting arbitrary callers, any mempool observer can re-execute the same swapData with the same signature before the original caller. This design treats the router as the single authorized party, exposing individual users to frontrunning and nonce consumption attacks.",
    "expert_notes": "This is a fundamental authorization scope error. The signed payload should commit to the original end-user (obtained via router.msgSender() per Uniswap V4 hook documentation), not the router contract itself. The current design exposes every quote to: (1) Dust swap frontrunning that invalidates legitimate orders, (2) MEV bot mempool sniping without providing protective guarantees to takers, (3) Denial of service where attackers force users to re-sign new nonces. While Kyber notes that taker protection occurs at the Aggregator contract level, this places critical routing security outside the hook scope. The fix requires including the original msg.sender in the signed digest.",
    "fix_description": "Include the original caller in the signature by retrieving it via router.msgSender() as specified in Uniswap V4 hook guidelines.",
    "fix_code": "function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata hookData) external override returns (bytes4) {\n    (bytes memory sig, uint256 nonce, uint256 expiryTime) = abi.decode(hookData, (bytes, uint256, uint256));\n    \n    // Get the original msg.sender who initiated the swap\n    address originalCaller = router.msgSender();\n    \n    bytes32 swapDigest = keccak256(\n        abi.encode(\n            sender,              // router address\n            originalCaller,      // original end-user (prevents frontrunning)\n            key,\n            params.zeroForOne,\n            params.amountSpecified,\n            params.sqrtPriceLimitX96,\n            nonce,\n            expiryTime\n        )\n    );\n    \n    require(SignatureChecker.isValidSignatureNow(quoteSigner, swapDigest, sig), \"Invalid signature\");\n    _useUnorderedNonce(nonce);\n    return IHooks.beforeSwap.selector;\n}"
  }
]