{
  "id": "gs_auditors_arcadia_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Arcadia Accounts V2 Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Arcadia-security-review-October.pdf",
  "github_repo_url": "https://github.com/arcadia-finance/accounts-v2/tree/08bc2a06dcc73ec13d326fe812179d865e3c67c5",
  "contest_date": "2025-10-24",
  
  "severity": "medium",
  "vulnerability_type": "incorrect_transfer_recipient",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "ETH withdrawn is sent to msg.sender instead of the to address",
  "finding_description": "In the AccountSpot contract, the `_withdraw` function does not use the `to` address as the recipient of the withdrawn funds in the case of an ETH withdrawal but instead uses `msg.sender` as the recipient. This removes the ability of the withdrawer to specify a different address to receive the funds and, what is more, can lead to the loss of funds if the caller is expecting the funds to be sent to the `to` address, as the NatSpec comment explicitly states that the `to` address is the recipient of the withdrawn funds.",
  "attack_scenario": "A user or contract calls the `_withdraw` function and specifies a custom recipient address in the `to` parameter (e.g., a cold wallet or a relayer contract). However, when withdrawing native ETH (`assetAddresses[i] == address(0)`), the function sends the ETH to `msg.sender` instead of the specified `to` address. This violates the documented behavior, potentially causing the calling contract to hold unexpected funds or the user to lose track of the assets if they were expecting them at the specified `to` address.",
  "fix_description": "Use the `to` address as the recipient of the withdrawn funds in the case of an ETH withdrawal. Change the vulnerable line from `payable(msg.sender).call{value: assetAmounts[i]}(\"\")` to `payable(to).call{value: assetAmounts[i]}(\"\")`. If the expected behavior is that funds can only be withdrawn to the caller, add a condition to check that `to == msg.sender` and revert otherwise.",
  
  "primary_file": {
    "path": "src/accounts/AccountSpot.sol",
    "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AccountErrors } from "../libraries/Errors.sol";\nimport { AccountStorageV1 } from "./AccountStorageV1.sol";\nimport { ActionData, IActionBase } from "../interfaces/IActionBase.sol";\nimport { ERC20, SafeTransferLib } from "../../lib/solmate/src/utils/SafeTransferLib.sol";\nimport { IAccount } from "../interfaces/IAccount.sol";\nimport { IERC721 } from "../interfaces/IERC721.sol";\nimport { IERC1155 } from "../interfaces/IERC1155.sol";\nimport { IPermit2 } from "../interfaces/IPermit2.sol";\n\n/**\n * @title Arcadia Spot Account\n * @author Pragma Labs\n * @notice Arcadia Spot Accounts enables individuals, DAOs, and other protocols to deposit and manage a variety of assets easily through Asset Managers.\n * Asset Managers are selected by Spot Account holders and can facilitate automation for tasks such as Liquidity Management and Compounding, among others.\n */\ncontract AccountSpot is AccountStorageV1, IAccount {\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The current Account Version.\n    uint256 public constant ACCOUNT_VERSION = 2;\n    // The cool-down period after an account action, that might be disadvantageous for a new Owner,\n    // during which ownership cannot be transferred to prevent the old Owner from frontrunning a transferFrom().\n    uint256 public constant COOL_DOWN_PERIOD = 5 minutes;\n    // Storage slot with the address of the current implementation.\n    // This is the hardcoded keccak-256 hash of: "eip1967.proxy.implementation" subtracted by 1.\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    // The contract address of the Arcadia Accounts Factory.\n    address public immutable FACTORY;\n    // Uniswap Permit2 contract\n    IPermit2 internal immutable PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    // Storage slot for the Account implementation, a struct to avoid storage conflict when dealing with upgradeable contracts.\n    struct AddressSlot {\n        address value;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AssetManagerSet(address indexed owner, address indexed assetManager, bool value);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @dev Throws if function is reentered.\n     */\n    modifier nonReentrant() {\n        if (locked != 1) revert AccountErrors.NoReentry();\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /**\n     * @dev Throws if called by any address other than an Asset Manager or the owner.\n     */\n    modifier onlyAssetManager() {\n        // A custom error would need to read out owner + isAssetManager storage\n        require(msg.sender == owner || isAssetManager[owner][msg.sender], "A: Only Asset Manager");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the Factory address.\n     */\n    modifier onlyFactory() {\n        if (msg.sender != FACTORY) revert AccountErrors.OnlyFactory();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the owner.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert AccountErrors.OnlyOwner();\n        _;\n    }\n\n    /**\n     * @dev Starts the cool-down period during which ownership cannot be transferred.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    modifier updateActionTimestamp() {\n        lastActionTimestamp = uint32(block.timestamp);\n        _;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @param factory The contract address of the Arcadia Accounts Factory.\n     */\n    constructor(address factory) {\n        // This will only be the owner of the Account implementation.\n        // and will not affect any subsequent proxy implementation using this Account implementation.\n        owner = msg.sender;\n\n        FACTORY = factory;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          ACCOUNT MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Initiates the variables of the Account.\n     * @param owner_ The sender of the 'createAccount' on the Factory\n     * @param registry_ The 'beacon' contract with the external logic to price assets.\n     * @dev A proxy will be used to interact with the Account implementation.\n     * This function will only be called (once) in the same transaction as the proxy Account creation through the Factory.\n     * @dev initialize has implicitly a nonReentrant guard, since the "locked" variable has value zero until the end of the function.\n     * @dev The Registry is not used in spot accounts, but a valid registry must be set to be compatible with V1 Accounts.\n     */\n    function initialize(address owner_, address registry_, address) external onlyFactory {\n        if (registry_ == address(0)) revert AccountErrors.InvalidRegistry();\n        owner = owner_;\n        registry = registry_;\n\n        locked = 1;\n    }\n\n    /**\n     * @notice Upgrades the Account version and stores a new address in the EIP1967 implementation slot.\n     * @param newImplementation The new contract address of the Account implementation.\n     * @param newRegistry The Registry for this specific newImplementation.\n     * @param data Arbitrary data, can contain instructions to execute when updating Account to new implementation.\n     * @dev This function MUST be added to new Account implementations.\n     */\n    function upgradeAccount(address newImplementation, address newRegistry, uint256, bytes calldata data)\n        external\n        onlyFactory\n        nonReentrant\n        updateActionTimestamp\n    {\n        // Cache old parameters.\n        address oldImplementation = _getAddressSlot(IMPLEMENTATION_SLOT).value;\n        uint256 oldVersion = ACCOUNT_VERSION;\n\n        // Store new parameters.\n        _getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n        registry = newRegistry;\n\n        // Hook on the new logic to finalize upgrade.\n        // Used to eg. Remove exposure from old Registry and add exposure to the new Registry.\n        // Extra data can be added by the Factory for complex instructions.\n        this.upgradeHook(oldImplementation, address(0), oldVersion, data);\n\n        // Event emitted by Factory.\n    }\n\n    /**\n     * @notice Returns the "AddressSlot" with member "value" located at "slot".\n     * @param slot The slot where the address of the Logic contract is stored.\n     * @return r The address stored in slot.\n     */\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @notice Finalizes the Upgrade from a different Account version to this version.\n     * param oldImplementation The old contract address of the Account implementation.\n     * param oldRegistry The Registry of the old version (might be identical to the new registry)\n     * param oldVersion The old version of the Account implementation.\n     * param data Arbitrary data, can contain instructions to execute in this function.\n     * @dev If upgradeHook() is implemented, it MUST verify that msg.sender == address(this).\n     * @dev We delete the deprecated AccountStorageV1 variables.\n     */\n    function upgradeHook(address, address, uint256, bytes calldata) external {\n        if (msg.sender != address(this)) revert AccountErrors.OnlySelf();\n        if (registry == address(0)) revert AccountErrors.InvalidRegistry();\n\n        // Require that no creditor is set and no auctions are ongoing.\n        // (This should always be enforced in the old Version we upgrade from, but we do a redundant safety check).\n        if (creditor != address(0) || inAuction) revert AccountErrors.InvalidUpgrade();\n\n        // Delete margin account related storage data (should normally already be empty).\n        delete liquidator;\n        delete minimumMargin;\n        delete numeraire;\n\n        // Delete asset related storage data.\n        uint256 erc20StoredLength = erc20Stored.length;\n        for (uint256 i = 0; i < erc20StoredLength; ++i) {\n            delete erc20Balances[erc20Stored[i]];\n        }\n        delete erc20Stored;\n\n        delete erc721Stored;\n        delete erc721TokenIds;\n\n        uint256 erc1155StoredLength = erc1155Stored.length;\n        for (uint256 j = 0; j < erc1155StoredLength; ++j) {\n            delete erc1155Balances[erc1155Stored[j]][erc1155TokenIds[j]];\n        }\n        delete erc1155Stored;\n        delete erc1155TokenIds;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        OWNERSHIP MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Transfers ownership of the contract to a new Account.\n     * @param newOwner The new owner of the Account.\n     * @dev Can only be called by the current owner via the Factory.\n     * A transfer of ownership of the Account is triggered by a transfer\n     * of ownership of the accompanying ERC721 Account NFT, issued by the Factory.\n     * Owner of Account NFT = owner of Account\n     * @dev Function uses a cool-down period during which ownership cannot be transferred.\n     * Cool-down period is triggered after any account action, that might be disadvantageous for a new Owner.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    function transferOwnership(address newOwner) external onlyFactory {\n        if (block.timestamp <= lastActionTimestamp + COOL_DOWN_PERIOD) revert AccountErrors.CoolDownPeriodNotPassed();\n\n        // The Factory will check that the new owner is not address(0).\n        owner = newOwner;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       ASSET MANAGER ACTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or remove an Asset Manager.\n     * @param assetManager The address of the Asset Manager.\n     * @param value A boolean giving permissions to or taking permissions from an Asset Manager.\n     * @dev Only set trusted addresses as Asset Manager. Asset Managers have full control over assets in the Account.\n     * @dev No need to set the Owner as Asset Manager as they will automatically have all permissions of an Asset Manager.\n     * @dev Potential use-cases of the Asset Manager might be to:\n     * - Liquidity Management.\n     * - Do flash actions (optimistic actions).\n     * - Compounding.\n     * - Chain multiple interactions together.\n     * @dev Anyone can set the Asset Manager for themselves, this will not impact the current owner of the Account\n     * since the combination of "stored owner -> asset manager" is used in authentication checks.\n     * This guarantees that when the ownership of the Account is transferred, the asset managers of the old owner have no\n     * impact on the new owner. But the new owner can still remove any existing asset managers before the transfer.\n     */\n    function setAssetManager(address assetManager, bool value) external {\n        emit AssetManagerSet(msg.sender, assetManager, isAssetManager[msg.sender][assetManager] = value);\n    }\n\n    /**\n     * @notice Executes a flash action.\n     * @param actionTarget The contract address of the actionTarget to execute external logic.\n     * @param actionData A bytes object containing three structs and two bytes objects.\n     * The first struct contains the info about the assets to withdraw from this Account to the actionTarget.\n     * The second struct contains the info about the owner's assets that need to be transferred from the owner to the actionTarget.\n     * The third struct contains the permit for the Permit2 transfer.\n     * The first bytes object contains the signature for the Permit2 transfer.\n     * The second bytes object contains the encoded input for the actionTarget.\n     * @dev This function optimistically chains multiple actions together (= do a flash action):\n     * - It can optimistically withdraw assets from the Account to the actionTarget.\n     * - It can transfer assets directly from the owner to the actionTarget.\n     * - It can execute external logic on the actionTarget, and interact with any DeFi protocol to swap, stake, claim...\n     * - It can deposit all recipient tokens from the actionTarget back into the Account.\n     */\n    function flashAction(address actionTarget, bytes calldata actionData)\n        external\n        payable\n        onlyAssetManager\n        nonReentrant\n        updateActionTimestamp\n    {\n        // Decode flash action data.\n        (\n            ActionData memory withdrawData,\n            ActionData memory transferFromOwnerData,\n            IPermit2.PermitBatchTransferFrom memory permit,\n            bytes memory signature,\n            bytes memory actionTargetData\n        ) = abi.decode(actionData, (ActionData, ActionData, IPermit2.PermitBatchTransferFrom, bytes, bytes));\n\n        // Withdraw assets to the actionTarget.\n        _withdraw(\n            withdrawData.assets, withdrawData.assetIds, withdrawData.assetAmounts, withdrawData.assetTypes, actionTarget\n        );\n\n        // Transfer assets from owner (that are not assets in this account) to the actionTarget.\n        if (transferFromOwnerData.assets.length > 0) {\n            _transferFromOwner(transferFromOwnerData, actionTarget);\n        }\n\n        // If the function input includes a signature and non-empty token permissions,\n        // initiate a transfer from the owner to the actionTarget via Permit2.\n        if (signature.length > 0 && permit.permitted.length > 0) {\n            _transferFromOwnerWithPermit(permit, signature, actionTarget);\n        }\n\n        // Execute external logic on the actionTarget.\n        ActionData memory depositData = IActionBase(actionTarget).executeAction(actionTargetData);\n\n        // Deposit assets from actionTarget into Account.\n        _deposit(\n            depositData.assets, depositData.assetIds, depositData.assetAmounts, depositData.assetTypes, actionTarget\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Deposits assets into the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     */\n    function deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes\n    ) external payable onlyOwner nonReentrant {\n        _deposit(assetAddresses, assetIds, assetAmounts, assetTypes, msg.sender);\n    }\n\n    /**\n     * @notice Deposits assets into the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     * @param from The assets deposited into the Account will come from this address.\n     */\n    function _deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes,\n        address from\n    ) internal {\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent transferring addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetTypes[i] == 1) {\n                ERC20(assetAddresses[i]).safeTransferFrom(from, address(this), assetAmounts[i]);\n            } else if (assetTypes[i] == 2) {\n                IERC721(assetAddresses[i]).safeTransferFrom(from, address(this), assetIds[i]);\n            } else if (assetTypes[i] == 3) {\n                IERC1155(assetAddresses[i]).safeTransferFrom(from, address(this), assetIds[i], assetAmounts[i], "");\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws assets from the Account to the owner.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     */\n    function withdraw(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes\n    ) public onlyOwner nonReentrant updateActionTimestamp {\n        _withdraw(assetAddresses, assetIds, assetAmounts, assetTypes, msg.sender);\n    }\n\n    /**\n     * @notice Withdraws assets from the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     * @param to The address to withdraw to.\n     */\n    function _withdraw(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes,\n        address to\n    ) internal {\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent transferring addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetAddresses[i] == address(0)) {\n                (bool success, bytes memory result) = payable(msg.sender).call{ value: assetAmounts[i] }("");\n                require(success, string(result));\n            } else if (assetTypes[i] == 1) {\n                ERC20(assetAddresses[i]).safeTransfer(to, assetAmounts[i]);\n            } else if (assetTypes[i] == 2) {\n                IERC721(assetAddresses[i]).safeTransferFrom(address(this), to, assetIds[i]);\n            } else if (assetTypes[i] == 3) {\n                IERC1155(assetAddresses[i]).safeTransferFrom(address(this), to, assetIds[i], assetAmounts[i], "");\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers assets directly from the owner to the actionTarget contract.\n     * @param transferFromOwnerData A struct containing the info of all assets transferred from the owner that are not in this account.\n     * @param to The address to withdraw to.\n     */\n    function _transferFromOwner(ActionData memory transferFromOwnerData, address to) internal {\n        uint256 assetAddressesLength = transferFromOwnerData.assets.length;\n        address owner_ = owner;\n        for (uint256 i; i < assetAddressesLength; ++i) {\n            // Skip if amount is 0 to prevent transferring 0 balances.\n            if (transferFromOwnerData.assetAmounts[i] == 0) continue;\n\n            if (transferFromOwnerData.assetTypes[i] == 1) {\n                ERC20(transferFromOwnerData.assets[i]).safeTransferFrom(\n                    owner_, to, transferFromOwnerData.assetAmounts[i]\n                );\n            } else if (transferFromOwnerData.assetTypes[i] == 2) {\n                IERC721(transferFromOwnerData.assets[i]).safeTransferFrom(owner_, to, transferFromOwnerData.assetIds[i]);\n            } else if (transferFromOwnerData.assetTypes[i] == 3) {\n                IERC1155(transferFromOwnerData.assets[i]).safeTransferFrom(\n                    owner_, to, transferFromOwnerData.assetIds[i], transferFromOwnerData.assetAmounts[i], ""\n                );\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers assets from the owner to the actionTarget contract via Permit2.\n     * @param permit Data specifying the terms of the transfer.\n     * @param signature The signature to verify.\n     * @param to_ The address to withdraw to.\n     */\n    function _transferFromOwnerWithPermit(\n        IPermit2.PermitBatchTransferFrom memory permit,\n        bytes memory signature,\n        address to_\n    ) internal {\n        uint256 tokenPermissionsLength = permit.permitted.length;\n        IPermit2.SignatureTransferDetails[] memory transferDetails =\n            new IPermit2.SignatureTransferDetails[](tokenPermissionsLength);\n\n        for (uint256 i; i < tokenPermissionsLength; ++i) {\n            transferDetails[i].to = to_;\n            transferDetails[i].requestedAmount = permit.permitted[i].amount;\n        }\n\n        PERMIT2.permitTransferFrom(permit, transferDetails, owner, signature);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        HELPER FUNCTIONS\n    /////////////////////////////////////////////////////////////// */\n\n    /* \n    @notice Returns the onERC721Received selector.\n    @dev Needed to receive ERC721 tokens.\n    */\n    function onERC721Received(address, address, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /*\n    @notice Returns the onERC1155Received selector.\n    @dev Needed to receive ERC1155 tokens.\n    */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /*\n    @notice Called when function selector doesn't match any other.\n    @dev No fallback allowed.\n    */\n    fallback() external {\n        revert AccountErrors.NoFallback();\n    }\n\n    /*\n    @notice Called on a plain ETH transfer.\n    */\n    receive() external payable { }\n}",
    "vulnerable_lines": [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53],
    "vulnerable_functions": ["_withdraw"]
  },
  
  "context_files": [],
  
  "call_flow": "User calls public withdraw function -> Internal call to `_withdraw(..., to)` -> Inside loop, when `assetAddresses[i] == address(0)` (for ETH) -> Execution of `payable(msg.sender).call{value: amount}(\"\")` -> ETH is sent to `msg.sender` instead of the `to` parameter.",
  "context_hint": "A logic error where the code for native ETH withdrawal uses `msg.sender` as the recipient of the funds, despite the function signature and NatSpec comment explicitly defining a separate `to` address parameter. The code for ERC20/ERC721/ERC1155 correctly uses the `to` parameter.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The vulnerability is a direct contradiction between the function's documentation (`@param to The address to withdraw to`) and its implementation (`payable(msg.sender).call{...}`). This is a high-impact logic bug for users expecting to be able to withdraw to an arbitrary address."
}

{
  "id": "gs_pashov_bunni_C01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "arbitrary_token_claim",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "claimRecurPool does not verify the provided incentiveToken is equal to rewardToken",
  "finding_description": "When the `claimRecurPool` function is called, it iterates through the claims but does not verify that the `incentiveToken` provided in the `RecurClaimParams` is equal to the `rewardToken` associated with the claimed `RecurPoolKey`. This allows an attacker to claim rewards denominated in one token but receive a different, possibly more valuable, token.",
  "attack_scenario": "1. Attacker creates a fake Recur Pool with an arbitrary/worthless reward token but provides a high `rewardRate`.\n2. When calling `claimRecurPool`, the attacker uses the ID of their fake pool but sets the `incentiveToken` parameter to the address of a valuable token (e.g., WETH, or a core protocol token) that is held by the `MasterBunni` contract (e.g., from a genuine pool).\n3. The reward amount is calculated based on the fake pool's high rate, and this high amount of the valuable token is transferred to the recipient, effectively stealing funds from the contract's overall balance.",
  "fix_description": "Validate that the provided `incentiveToken` (from `params[i].incentiveToken`) is equal to the `rewardToken` of each `RecurPoolKey` being processed within the loop.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [11],
    "vulnerable_functions": ["claimRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.claimRecurPool(fakePoolKey, recipient) -> MasterBunni calculates reward for fakePoolKey (which uses rewardToken A) -> MasterBunni transfers `totalClaimableAmount` of `incentiveToken B` (specified by attacker) to recipient. Token B is stolen.",
  "context_hint": "The claim function relies on a user-provided `incentiveToken` parameter for the final transfer, rather than enforcing that the `incentiveToken` matches the `rewardToken` determined by the `RecurPoolKey`. This decouples the reward calculation from the token being paid out, leading to critical asset theft.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A very high-impact logic error allowing asset drain via a token substitution attack. Crucial state integrity check is missing."
}

{
  "id": "gs_pashov_bunni_C02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "inconsistent_state_update",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "incentiveToken is not verified within incentivizeRecurPool",
  "finding_description": "The `incentivizeRecurPool` function allows a user to update the `state.rewardRate` for a pool using an arbitrary `incentiveToken` provided as an argument, without verifying that this token matches the pool's actual `rewardToken` (which is part of the `RecurPoolKey`). This allows a malicious actor to deposit a worthless token while increasing the reward rate for the pool's legitimate reward token.",
  "attack_scenario": "1. A legitimate pool exists where `rewardToken` is WETH.\n2. An attacker calls `incentivizeRecurPool` for this pool, providing a large `incentiveAmount` and setting `incentiveToken` to a worthless token (e.g., AttackerToken).\n3. The reward rate for the WETH pool is updated based on the large amount.\n4. The function executes a `safeTransferFrom` of the worthless AttackerToken, which successfully transfers the token to the contract.\n5. Legitimate users see a high reward rate for WETH, but when they try to claim, the contract quickly runs out of WETH (the actual reward token), or the pool accounting is permanently ruined because the reward token stored in the contract is useless (AttackerToken) but the promised reward is WETH.",
  "fix_description": "Validate that the `incentiveToken` parameter is equal to the `rewardToken` associated with the `RecurPoolKey` within the `incentivizeRecurPool` function.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [47],
    "vulnerable_functions": ["incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.incentivizeRecurPool(validPoolKey, AttackerToken) -> MasterBunni updates the rewardRate state for the pool's actual rewardToken (e.g., WETH) -> MasterBunni transfers AttackerToken into the contract (the WETH reward is now under-collateralized/unclaimable).",
  "context_hint": "The function calculates the reward rate update based on the pool's configuration (which implies a `rewardToken`), but accepts a separate, unvalidated `incentiveToken` parameter for the token transfer itself, allowing the attacker to increase the effective reward rate of a valuable token by depositing a worthless one.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Similar to C-01, this is a critical integrity check failure leading to corrupted reward state and potential denial of service or asset loss for LPs relying on the correct reward mechanism."
}

{
  "id": "gs_pashov_bunni_C03",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-03]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "reward_loss_logic",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "Previous rewardRate is removed when periodFinish has not yet been reached",
  "finding_description": "In `incentivizeRecurPool`, when adding a new incentive while the current reward period (`periodFinish`) is still active, the new reward rate (`newRewardRate`) is calculated and then assigned directly to `state.rewardRate` instead of being added to the existing `state.rewardRate`. This overwrites and effectively removes the previous incentive provider's reward rate, causing their provided reward amount to be lost/unclaimable.",
  "attack_scenario": "1. User A provides an incentive for 30 days, setting a high `state.rewardRate`.\n2. Before the 30 days are up, User B calls `incentivizeRecurPool` with a new, smaller incentive amount.\n3. The code calculates the `newRewardRate` based only on User B's incentive and the remaining duration.\n4. This calculated `newRewardRate` (B) is assigned to `state.rewardRate`, overwriting the previous, higher `state.rewardRate` (A).\n5. LPs who staked for User A's incentive will receive significantly fewer rewards than promised for the remainder of the period, as the reward rate has been artificially lowered by the overwrite. User A's funds are essentially locked or permanently lost due to the incorrect accounting.",
  "fix_description": "When the current period is still active (`block.timestamp < periodFinish`), the calculated `newRewardRate` (based on the new deposit) must be added to the existing `state.rewardRate`. The fix is changing `state.rewardRate = newRewardRate;` to `state.rewardRate += newRewardRate;` in the `else` block.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [28],
    "vulnerable_functions": ["incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "User A calls incentivizeRecurPool (Period Active) -> User B calls incentivizeRecurPool (Period Active) -> MasterBunni calculates B's `newRewardRate` -> MasterBunni sets `state.rewardRate = newRewardRate` (overwrites A's contribution) -> A's funds are effectively locked/lost.",
  "context_hint": "A fundamental accounting error in managing concurrent incentives. By assigning the newly calculated rate instead of adding it, the pool's reward state is reset, causing rewards promised by previous depositors to be canceled for the remainder of the period.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a direct economic exploit that steals or locks existing incentive providers' funds, causing material loss and breaking trust in the staking mechanism. Easily fixable by changing assignment to addition."
}

{
  "id": "gs_pashov_bunni_H01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[H-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "high",
  "vulnerability_type": "denial_of_unstake",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "joinRecurPool can incorrectly increment userPoolCounts",
  "finding_description": "The `joinRecurPool` function incorrectly increments `userPoolCounts[msgSender][key.stakeToken]` even when the user is only updating their staked balance (i.e., not the first time joining the pool). Since `userPoolCounts` is designed to track the number of distinct pools a user has joined for a specific stake token, its inflation will prevent users from successfully calling the unlock mechanism (which relies on this counter decreasing to zero for the final unlock), leading to a permanent denial of unstake for the affected tokens.",
  "attack_scenario": "1. User A joins a Recur Pool (Pool 1) with Stake Token X. `userPoolCounts[A][X]` becomes 1.\n2. User A later increases their balance of Stake Token X and calls `joinRecurPool` again for Pool 1 (to update their staked amount).\n3. The code incorrectly executes `++userPoolCounts[A][X]`, making the counter 2.\n4. When User A exits all pools, the unlock function will attempt to decrement this counter, but it will never reach zero, permanently locking User A's Stake Token X.",
  "fix_description": "Increment `userPoolCounts` only if the previous staked balance (`stakedBalance`) was zero, indicating the user is joining the pool for the first time. Add a check: `if (stakedBalance == 0) { ++userPoolCounts[msgSender][key.stakeToken]; }`.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [23],
    "vulnerable_functions": ["joinRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "User calls `joinRecurPool` second time (to update stake) -> `stakedBalance > 0` -> `++userPoolCounts` executes redundantly -> Counter becomes $> 1$ for a single pool -> Token unlock mechanism fails.",
  "context_hint": "A state accounting error tied to a core component (`userPoolCounts`) used for token locking/unlocking. Over-incrementing this counter prevents the user from ever fully unlocking their token, leading to permanent asset loss.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a severe vulnerability as it locks user funds. The fix requires checking the prior state (`stakedBalance == 0`) before incrementing the pool count."
}

{
  "id": "gs_pashov_bunni_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "transfer_logic_bypass",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "depositIncentive and incentivizeRecurPool do not verify if the incentiveToken exists",
  "finding_description": "Both `depositIncentive` (for RushPools) and `incentivizeRecurPool` (for RecurPools) use a version of Solady's `safeTransferFrom2` which does not check the code size of the `incentiveToken` address before performing the transfer call. In Solidity's assembly, if there is no return data (which happens when calling a non-contract address), the call is treated as successful. This allows an attacker to provide a non-contract address as the `incentiveToken` and proceed with updating the reward accounting state without actually transferring any tokens, or use a predictable address of a token that is yet to be created.",
  "attack_scenario": "1. An attacker determines the predictable future address of a legitimate Bunni LP token (Token X).\n2. The attacker calls `incentivizeRecurPool`, using the address of the uncreated Token X and providing a huge fake `incentiveAmount`.\n3. The `safeTransferFrom2` call to the uncreated address is treated as successful due to the lack of code size check, and no actual tokens are transferred to the protocol.\n4. The reward accounting state is updated based on the huge fake incentive, immediately disrupting the pool's reward rate and potentially leading to a permanent locking of real rewards deposited later.",
  "fix_description": "Upgrade the protocol to use the latest version of Solady's SafeTransferLib, which includes a code size check for contract addresses during transfers, or manually implement a code size check (`address(incentiveToken).code.length > 0`) before initiating the transfer.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["depositIncentive", "incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.depositIncentive(..., uncreatedTokenAddress) -> MasterBunni calls `uncreatedTokenAddress.safeTransferFrom2(...)` -> Solady's underlying assembly accepts the transfer as successful (due to no return data from non-contract) -> Reward state is corrupted without deposit.",
  "context_hint": "An issue stemming from reliance on a vulnerable/outdated external library implementation (`SafeTransferLib`). This allows attackers to manipulate reward accounting state using fake deposits to non-existent contract addresses, leading to reward corruption/disruption.",
  
  "is_vulnerable": true,
  
  "expert_notes": "While the impact can be high (reward corruption), the likelihood depends on the attacker's ability to predict addresses (Medium/Low), hence the Medium severity. The core issue is the missing code size check for the token address."
}

{
  "id": "gs_pashov_bunni_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "DOS Attack in joinRushPool",
  "finding_description": "The `joinRushPool` function allows users to stake tokens up to a maximum cap. However, the lack of time restrictions (such as a minimum stake duration or an unstaking delay) allows malicious actors to perform a sandwich attack, repeatedly front-running and back-running legitimate users' stake transactions to keep the pool permanently full.",
  "attack_scenario": "1. Attacker observes a pending transaction where a legitimate user attempts to call `joinRushPool`.\n2. **Front-run:** Attacker calls `joinRushPool` to fill the pool up to its stake cap.\n3. Victim's transaction fails because the pool capacity is zero.\n4. **Back-run:** Attacker immediately calls `exitRushPool` to withdraw their stake, emptying the pool for the next opportunity.\n5. The attacker can repeat this process indefinitely, preventing legitimate users from ever staking, costing only the gas fees for the sandwich transactions.",
  "fix_description": "It is recommended to implement an anti-sandwich measure, such as a minimum stake duration or an unstaking delay, to increase the cost and reduce the profitability of this DOS attack.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["joinRushPool", "exitRushPool"],
    "vulnerable_lines": [10]
  },
  
  "context_files": [],
  
  "call_flow": "Victim.joinRushPool (pending) -> Attacker.joinRushPool (fills cap) -> Victim TX reverts -> Attacker.exitRushPool (empties cap) -> Repeat.",
  "context_hint": "Economic Denial of Service vulnerability arising from the lack of temporal restrictions on staking and unstaking in a capped pool. The attacker uses cheap, reversible transactions to maintain a persistent block on legitimate users.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A standard mechanism for DOS in capped pools without time locks. While it doesn't lead to direct asset loss from the protocol, it severely harms user experience and can disrupt the protocol's liquidity acquisition strategy."
}


{
  "id": "gs_pashov_bunni_M04",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-04]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "incorrect_arithmetic_rounding",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Incorrect tick rounding in TWAP calculation",
  "finding_description": "In `BunniHookOracle._queryTwap()`, the arithmetic mean tick is calculated by dividing the cumulative tick delta (`tickCumulativesDelta`) by the window size. When `tickCumulativesDelta` is negative, Solidity's integer division rounds toward zero (upward). Correct TWAP tick calculation requires rounding toward negative infinity (downward) to maintain accuracy and consistency with price definitions, especially for negative ticks. The current implementation can result in the tick value being off by 1.",
  "attack_scenario": "The incorrect rounding can result in a mispriced oracle value (off by one tick) when the calculated average tick is negative and not an exact integer. This slight mispricing can be abused by arbitrageurs or lead to inaccurate price-dependent operations in the protocol, potentially costing small amounts of value in each transaction relying on the TWAP.",
  "fix_description": "Implement consistent rounding-down behavior for the tick calculation by adding a check: if `tickCumulativesDelta < 0` and the remainder of the division is non-zero, decrement the resulting tick by 1.",
  
  "primary_file": {
    "path": "contracts/BunniHookOracle.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {SSTORE2} from "solady/utils/SSTORE2.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport "../external/IBunniHook.sol";\nimport {TickMath} from "../lib/TickMath.sol";\nimport {IOracle} from "../interfaces/IOracle.sol";\n\n/// @title Oracle using BunniHook TWAP oracle as data source\n/// @author zefram.eth\n/// @notice The oracle contract that provides the current price to purchase\n/// the underlying token while exercising options. Uses BunniHook TWAP oracle\n/// as data source, and then applies a multiplier & lower bound.\ncontract BunniHookOracle is IOracle, Ownable {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SSTORE2 for *;\n    using TickMath for *;\n    using FixedPointMathLib for *;\n\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    error BunniHookOracle__InvalidPoolKey();\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event SetParams(uint16 multiplier, uint32 secs, uint32 ago, uint128 minPrice);\n    event SetPoolKey(PoolKey poolKey);\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @notice The denominator for converting the multiplier into a decimal number.\n    /// i.e. multiplier uses 4 decimals.\n    uint256 internal constant MULTIPLIER_DENOM = 10000;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n\n    /// -----------------------------------------------------------------------\n    /// Immutable parameters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The BunniHook contract\n    IBunniHook public immutable bunniHook;\n\n    /// @inheritdoc IOracle\n    address public immutable paymentToken;\n\n    /// @inheritdoc IOracle\n    address public immutable underlyingToken;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @notice The multiplier applied to the TWAP value. Encodes the discount of\n    /// the options token. Uses 4 decimals.\n    uint16 public multiplier;\n\n    /// @notice The size of the window to take the TWAP value over in seconds.\n    uint32 public secs;\n\n    /// @notice The number of seconds in the past to take the TWAP from. The window\n    /// would be (block.timestamp - secs - ago, block.timestamp - ago].\n    uint32 public ago;\n\n    /// @notice The minimum value returned by getPrice(). Maintains a floor for the\n    /// price to mitigate potential attacks on the TWAP oracle.\n    uint128 public minPrice;\n\n    /// @notice The SSTORE2 pointer to the PoolKey used to query the BunniHook TWAP oracle.\n    address public poolKeyPointer;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        IBunniHook bunniHook_,\n        PoolKey memory poolKey,\n        address paymentToken_,\n        address underlyingToken_,\n        address owner_,\n        uint16 multiplier_,\n        uint32 secs_,\n        uint32 ago_,\n        uint128 minPrice_\n    ) {\n        bunniHook = bunniHook_;\n        paymentToken = paymentToken_;\n        underlyingToken = underlyingToken_;\n\n        multiplier = multiplier_;\n        secs = secs_;\n        ago = ago_;\n        minPrice = minPrice_;\n\n        emit SetParams(multiplier_, secs_, ago_, minPrice_);\n\n        _initializeOwner(owner_);\n\n        if (\n            !(\n                (poolKey.currency0 == paymentToken_ && poolKey.currency1 == underlyingToken_)\n                    || (poolKey.currency0 == underlyingToken_ && poolKey.currency1 == paymentToken_)\n            ) || poolKey.hooks != address(bunniHook_)\n        ) {\n            revert BunniHookOracle__InvalidPoolKey();\n        }\n        poolKeyPointer = abi.encode(poolKey).write();\n        emit SetPoolKey(poolKey);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// IOracle\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IOracle\n    function getPrice() external view override returns (uint256 price) {\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint16 multiplier_ = multiplier;\n        uint32 secs_ = secs;\n        uint32 ago_ = ago;\n        uint256 minPrice_ = minPrice;\n\n        /// -----------------------------------------------------------------------\n        /// Computation\n        /// -----------------------------------------------------------------------\n\n        // query BunniHook to get TWAP value\n        {\n            // get average tick\n            PoolKey memory poolKey = getPoolKey();\n            int24 arithmeticMeanTick = _queryTwap(poolKey, secs_ + ago_, ago_);\n\n            // the unit of the average price is (currency1 / currency0)\n            // if paymentToken is not currency1 of the pool, negate the tick\n            // so that the unit of the average price is (paymentToken / underlyingToken)\n            arithmeticMeanTick = paymentToken == poolKey.currency1 ? arithmeticMeanTick : -arithmeticMeanTick;\n\n            // convert tick to sqrtPriceX96\n            uint256 sqrtPriceX96 = arithmeticMeanTick.getSqrtPriceAtTick();\n\n            // convert sqrtPriceX96 in Q96 (2**96) to price in WAD (1e18)\n            // mulDiv cannot overflow since log2(MAX_SQRT_PRICE * WAD) ~= 219.79 < 256\n            uint256 sqrtPriceWad = sqrtPriceX96.mulDiv(WAD, Q96);\n\n            // compute the price by squaring the sqrtPriceWad\n            // mulWad cannot overflow since log2((MAX_SQRT_PRICE * WAD / Q96)**2) ~= 247.94 < 256\n            price = sqrtPriceWad.mulWad(sqrtPriceWad);\n        }\n\n        // apply multiplier to price\n        price = price.mulDivUp(multiplier_, MULTIPLIER_DENOM);\n\n        // bound price above minPrice\n        price = FixedPointMathLib.max(price, minPrice_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @notice Returns the pool key used to query the BunniHook TWAP oracle.\n    function getPoolKey() public view returns (PoolKey memory) {\n        return abi.decode(poolKeyPointer.read(), (PoolKey));\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Updates the oracle parameters. Only callable by the owner.\n    /// @param multiplier_ The multiplier applied to the TWAP value. Encodes the discount of\n    /// the options token. Uses 4 decimals.\n    /// @param secs_ The size of the window to take the TWAP value over in seconds.\n    /// @param ago_ The number of seconds in the past to take the TWAP from. The window\n    /// would be (block.timestamp - secs - ago, block.timestamp - ago].\n    /// @param minPrice_ The minimum value returned by getPrice(). Maintains a floor for the\n    /// price to mitigate potential attacks on the TWAP oracle.\n    function setParams(uint16 multiplier_, uint32 secs_, uint32 ago_, uint128 minPrice_) external onlyOwner {\n        multiplier = multiplier_;\n        secs = secs_;\n        ago = ago_;\n        minPrice = minPrice_;\n        emit SetParams(multiplier_, secs_, ago_, minPrice_);\n    }\n\n    /// @notice Sets the pool key used to query the BunniHook TWAP oracle.\n    /// Only callable by the owner.\n    /// @param poolKey The new pool key\n    function setPoolKey(PoolKey calldata poolKey) external onlyOwner {\n        // validate pool key\n        if (\n            !(\n                (poolKey.currency0 == paymentToken && poolKey.currency1 == underlyingToken)\n                    || (poolKey.currency0 == underlyingToken && poolKey.currency1 == paymentToken)\n            ) || poolKey.hooks != address(bunniHook)\n        ) {\n            revert BunniHookOracle__InvalidPoolKey();\n        }\n\n        poolKeyPointer = abi.encode(poolKey).write();\n        emit SetPoolKey(poolKey);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the arithmetic mean tick of the TWAP window.\n    /// The TWAP window is defined by (block.timestamp - twapSecondsAgoStart, block.timestamp - twapSecondsAgoEnd].\n    /// The window size is (twapSecondsAgoStart - twapSecondsAgoEnd).\n    /// The unit of the average price is (currency1 / currency0).\n    function _queryTwap(PoolKey memory poolKey, uint32 twapSecondsAgoStart, uint32 twapSecondsAgoEnd)\n        internal\n        view\n        returns (int24 arithmeticMeanTick)\n    {\n        uint32 windowSize = twapSecondsAgoStart - twapSecondsAgoEnd;\n        IBunniHook hook = IBunniHook(address(poolKey.hooks));\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = twapSecondsAgoStart;\n        secondsAgos[1] = twapSecondsAgoEnd;\n        int56[] memory tickCumulatives = hook.observe(poolKey, secondsAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        return int24(tickCumulativesDelta / int56(uint56(windowSize)));\n    }\n}",
    "vulnerable_lines": [14],
    "vulnerable_functions": ["_queryTwap"]
  },
  
  "context_files": [],
  
  "call_flow": "Oracle calls `_queryTwap` -> `tickCumulativesDelta` is negative -> Solidity division rounds up (toward zero) -> Oracle returns an inaccurate tick value (off by 1).",
  "context_hint": "A subtle but common bug in Solidity when dealing with signed integer division. It leads to inaccurate TWAP calculation, which can be exploitable by sophisticated users for marginal gain. The issue is in not implementing the 'round towards negative infinity' standard for tick math.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Essential for accurate price oracles. While the impact of one tick difference is typically low, consistent price inaccuracy breaks guarantees and can be exploited. Severity is Medium for an oracle function."
}

{
  "id": "gs_auditors_tcap_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "TCAP V2.0 Audit",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Cryptex-security-review.pdf",
  "github_repo_url": "https://github.com/cryptexfinance/tcapv2.0/tree/f0168f3fe66c1fba4fd70ffdcdc87287e8f0cb6a",
  "contest_date": "2025-09-30",
  
  "severity": "medium",
  "vulnerability_type": "oracle_manipulation_logic",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "Circuit breakers are not considered when processing Chainlink's answer",
  "finding_description": "The oracle implementation does not validate Chainlink's returned price (`answer`) against the feed's `minAnswer` and `maxAnswer` circuit breaker limits. On some EVM chains like Arbitrum, Chainlink actively caps the returned price to these limits. If the actual asset price drops below `minAnswer`, the oracle will use the capped price (which is higher than the true market price), leading to an incorrect, inflated price being used by the protocol.",
  "attack_scenario": "1. The price of an asset, monitored by a Chainlink feed on Arbitrum, drops below the feed's configured `minAnswer`.\n2. The Chainlink feed returns the `minAnswer` (the capped value) instead of the true, lower market price.\n3. The protocol's `latestPrice()` function, lacking a check against `minAnswer`, accepts this artificially inflated price.\n4. This results in incorrect (overstated) collateralization ratios, preventing necessary liquidations and increasing the protocol's risk of insolvency.",
  "fix_description": "Implement checks within `latestPrice` to ensure the returned price (`answer`) is strictly between the aggregator's `MIN_ANSWER` and `MAX_ANSWER` (and also greater than 0), reverting if the returned answer is capped by the circuit breaker: `require(answer > MIN_ANSWER && answer < MAX_ANSWER);`.",
  
  "primary_file": {
    "path": "src/oracle/AggregatedChainlinkOracle.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\nimport {BaseOracleUSD} from "./BaseOracleUSD.sol";\nimport {AggregatorV3Interface} from "@chainlink/interfaces/feeds/AggregatorV3Interface.sol";\n/// @title Aggregated Chainlink Oracle USD\n/// @dev all oracles are priced in USD with 18 decimals\ncontract AggregatedChainlinkOracle is BaseOracleUSD {\n    AggregatorV3Interface public immutable feed;\n    uint256 public immutable feedDecimals;\n    constructor(address feed_, address token) BaseOracleUSD(token) {\n        feed = AggregatorV3Interface(feed_);\n        feedDecimals = feed.decimals();\n    }\n    function latestPrice(bool checkStaleness) public view virtual override returns (uint256) {\n        (, int256 answer,, uint256 updatedAt,) = feed.latestRoundData();\n        // @audit in case of a stale oracle do not revert because it would prevent users from withdrawing\n        // @audit only check staleness during minting to ensure staleness of price doesn't allow for arbitrage\n        if (checkStaleness) {\n            if (updatedAt < block.timestamp - 1 days) {\n                revert StaleOracle();\n            }\n        }\n        assert(answer > 0);\n        // @audit feed decimals cannot exceed 18\n        uint256 adjustedDecimalsAnswer = uint256(answer) * 10 ** (18 - feedDecimals);\n        return adjustedDecimalsAnswer;\n    }\n}",
    "vulnerable_lines": [15],
    "vulnerable_functions": ["latestPrice"]
  },
  
  "context_files": [],
  
  "call_flow": "Protocol calls `latestPrice()` -> Chainlink on Arbitrum returns capped price (because actual price < `minAnswer`) -> `latestPrice()` uses capped price without validation -> Protocol calculates over-collateralized ratio and skips liquidation.",
  "context_hint": "A critical flaw in price oracle validation stemming from misunderstanding Chainlink's circuit breaker implementation on specific chains (like Arbitrum). The protocol relies on a potentially inflated price, compromising its ability to manage solvency risk.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This issue highlights the importance of chain-specific Chainlink documentation. The impact is High because it directly compromises the liquidation mechanism, but the likelihood is Low due to the requirement for specific market conditions (price crossing the circuit breaker)."
}

{
  "id": "gs_auditors_tcap_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "TCAP V2.0 Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Cryptex-security-review.pdf",
  "github_repo_url": "https://github.com/cryptexfinance/tcapv2.0/tree/f0168f3fe66c1fba4fd70ffdcdc87287e8f0cb6a",
  "contest_date": "2025-09-30",
  
  "severity": "medium",
  "vulnerability_type": "missing_access_control",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Add a form of access control to takeFee",
  "finding_description": "The `takeFee()` function is external and lacks any access control, allowing anyone to call it for any user's debt. This function executes fee calculation and share reduction via `_takeFee`. An external actor can selectively and repeatedly call this function for targeted depositors, gradually decreasing their shares and, in effect, increasing the proportional ownership of depositors whose fees have not been taken.",
  "attack_scenario": "1. Depositors A, B, and C hold equal shares. \n2. An attacker calls `takeFee()` targeting only Depositor A and B's debt/shares, causing their share balances to slightly decrease due to the fee subtraction.\n3. Depositor C's shares remain unchanged.\n4. This selective fee application causes C's proportional claim on the underlying assets to increase at the expense of A and B, enabling a griefing or subtle profit redistribution attack that is detrimental to the targeted users.",
  "fix_description": "Consider limiting the function to a protected role (e.g., `onlyKeeper`, `onlyOwner`) and/or modifying the function to only allow a user to call `takeFee` for their own position, e.g., by adding a check that `user == msg.sender`.",
  
  "primary_file": {
    "path": "contracts/Vault.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {AccessControlUpgradeable as AccessControl} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";\nimport {Multicall} from "./lib/Multicall.sol";\nimport {ITCAPV2, IERC20} from "./interface/ITCAPV2.sol";\nimport {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";\nimport {IVault, IVersioned} from "./interface/IVault.sol";\nimport {IPocket} from "./interface/pockets/IPocket.sol";\nimport {FeeCalculatorLib} from "./lib/FeeCalculatorLib.sol";\nimport {IPermit2, ISignatureTransfer} from "permit2/src/interfaces/IPermit2.sol";\nimport {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport {SafeTransferLib} from "solady/src/utils/SafeTransferLib.sol";\nimport {IOracle} from "./interface/IOracle.sol";\nimport {Constants, Roles} from "./lib/Constants.sol";\nimport {LiquidationLib} from "./lib/LiquidationLib.sol";\n\n/// @title Vault\n/// @notice Vaults manage deposits of collateral and mint TCAP tokens\ncontract Vault is IVault, AccessControl, Multicall {\n    using FeeCalculatorLib for MintData;\n    using SafeCast for uint256;\n    using SafeTransferLib for address;\n\n    struct Deposit {\n        uint256 mintAmount;\n        uint256 feeIndex;\n        uint256 accruedInterest;\n    }\n\n    struct Pocket {\n        IPocket pocket;\n        bool enabled;\n    }\n\n    struct FeeData {\n        uint256 index;\n        uint16 fee;\n        uint40 lastUpdated;\n    }\n\n    struct MintData {\n        mapping(uint256 mintId => Deposit deposit) deposits;\n        FeeData feeData;\n    }\n\n    /// @custom:storage-location erc7201:tcapv2.storage.vault\n    struct VaultStorage {\n        mapping(uint96 pocketId => Pocket pocket) pockets;\n        uint96 pocketCounter;\n        IOracle oracle;\n        address feeRecipient;\n        IVault.LiquidationParams liquidationParams;\n        MintData mintData;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("tcapv2.storage.vault")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VaultStorageLocation = 0xead32f79207e43129359e4c6890b619e37e73a4cc1d61050c081a5aea1b4df00;\n\n    ITCAPV2 public immutable TCAPV2;\n    IERC20 public immutable COLLATERAL;\n    IPermit2 private immutable PERMIT2;\n    uint8 private immutable COLLATERAL_DECIMALS;\n\n    /// @dev ensures loan is healthy after any action is performed\n    modifier ensureLoanHealthy(address user, uint96 pocketId, bool checkStaleness) {\n        _;\n        if (_healthFactor(user, pocketId, checkStaleness) < liquidationParams().threshold) revert LoanNotHealthy();\n    }\n\n    constructor(ITCAPV2 tCAPV2_, IERC20 collateral_, IPermit2 permit2_) {\n        TCAPV2 = tCAPV2_;\n        COLLATERAL = collateral_;\n        PERMIT2 = permit2_;\n        COLLATERAL_DECIMALS = IERC20Metadata(address(collateral_)).decimals();\n        _disableInitializers();\n    }\n\n    function initialize(address admin, uint16 initialFee, address oracle_, address feeRecipient_, IVault.LiquidationParams calldata liquidationParams_)\n        public\n        initializer\n    {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _updateInterestRate(initialFee);\n        _updateOracle(oracle_);\n        _updateFeeRecipient(feeRecipient_);\n        _updateLiquidationParams(liquidationParams_);\n    }\n\n    function _getVaultStorage() private pure returns (VaultStorage storage $) {\n        assembly {\n            $.slot := VaultStorageLocation\n        }\n    }\n\n    /// @inheritdoc IVault\n    function addPocket(IPocket pocket) external onlyRole(Roles.POCKET_SETTER_ROLE) returns (uint96 pocketId) {\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        if (address(pocket.VAULT()) != address(this)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        if (pocket.UNDERLYING_TOKEN() != COLLATERAL) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET_COLLATERAL);\n        VaultStorage storage $ = _getVaultStorage();\n        pocketId = ++$.pocketCounter;\n        $.pockets[pocketId] = Pocket({pocket: pocket, enabled: true});\n        emit PocketAdded(pocketId, pocket);\n    }\n\n    /// @inheritdoc IVault\n    function disablePocket(uint96 pocketId) external onlyRole(Roles.POCKET_SETTER_ROLE) {\n        VaultStorage storage $ = _getVaultStorage();\n        if (!$.pockets[pocketId].enabled) revert PocketNotEnabled(pocketId);\n        $.pockets[pocketId].enabled = false;\n        emit PocketDisabled(pocketId);\n    }\n\n    /// @inheritdoc IVault\n    function updateInterestRate(uint16 fee) external onlyRole(Roles.FEE_SETTER_ROLE) {\n        _updateInterestRate(fee);\n    }\n\n    /// @inheritdoc IVault\n    function updateFeeRecipient(address newFeeRecipient) external onlyRole(Roles.FEE_SETTER_ROLE) {\n        _updateFeeRecipient(newFeeRecipient);\n    }\n\n    /// @inheritdoc IVault\n    function updateOracle(address newOracle) external onlyRole(Roles.ORACLE_SETTER_ROLE) {\n        _updateOracle(newOracle);\n    }\n\n    /// @inheritdoc IVault\n    function updateLiquidationParams(LiquidationParams calldata newParams) external onlyRole(Roles.LIQUIDATION_SETTER_ROLE) {\n        _updateLiquidationParams(newParams);\n    }\n\n    /// @inheritdoc IVault\n    function deposit(uint96 pocketId, uint256 amount) external returns (uint256 shares) {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        IPocket pocket = _getPocket(pocketId);\n        address(COLLATERAL).safeTransferFrom(msg.sender, address(pocket), amount);\n        shares = pocket.registerDeposit(msg.sender, amount);\n        emit Deposited(msg.sender, pocketId, amount, shares);\n    }\n\n    /// @inheritdoc IVault\n    function depositWithPermit(uint96 pocketId, uint256 amount, IPermit2.PermitTransferFrom calldata permit, bytes calldata signature)\n        external\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        if (permit.permitted.token != address(COLLATERAL)) revert InvalidToken();\n        IPocket pocket = _getPocket(pocketId);\n        IPermit2.SignatureTransferDetails memory transferDetails = ISignatureTransfer.SignatureTransferDetails({to: address(pocket), requestedAmount: amount});\n        PERMIT2.permitTransferFrom(permit, transferDetails, msg.sender, signature);\n        shares = pocket.registerDeposit(msg.sender, amount);\n        emit Deposited(msg.sender, pocketId, amount, shares);\n    }\n\n    /// @inheritdoc IVault\n    function withdraw(uint96 pocketId, uint256 amount, address to) external ensureLoanHealthy(msg.sender, pocketId, false) returns (uint256 shares) {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        // @audit should be able to withdraw even if pocket is disabled\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        _takeFee(pocket, msg.sender, pocketId);\n        shares = pocket.withdraw(msg.sender, amount, to);\n        emit Withdrawn(msg.sender, pocketId, to, amount, shares);\n    }\n\n    /// @inheritdoc IVault\n    function mint(uint96 pocketId, uint256 amount) external ensureLoanHealthy(msg.sender, pocketId, true) {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        MintData storage $ = _getVaultStorage().mintData;\n        $.modifyPosition(_toMintId(msg.sender, pocketId), amount.toInt256());\n        TCAPV2.mint(msg.sender, amount);\n        emit Minted(msg.sender, pocketId, amount);\n    }\n\n    /// @inheritdoc IVault\n    function burn(uint96 pocketId, uint256 amount) external {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        MintData storage $ = _getVaultStorage().mintData;\n        uint256 mintId = _toMintId(msg.sender, pocketId);\n        if ($.deposits[mintId].mintAmount < amount) revert InsufficientMintedAmount();\n        $.modifyPosition(mintId, -1 * (amount.toInt256()));\n        TCAPV2.burn(msg.sender, amount);\n        emit Burned(msg.sender, pocketId, amount);\n    }\n\n    /// @inheritdoc IVault\n    function liquidate(address user, uint96 pocketId, uint256 burnAmount) external returns (uint256 liquidationReward) {\n        if (burnAmount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        // @audit should be able to liquidate even if pocket is disabled\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        _takeFee(pocket, user, pocketId);\n        uint256 mintAmount = mintedAmountOf(user, pocketId);\n        if (burnAmount > mintAmount) revert InvalidValue(IVault.ErrorCode.INVALID_BURN_AMOUNT);\n        uint256 tcapPrice = TCAPV2.latestPrice();\n        uint256 collateralAmount = collateralOf(user, pocketId);\n        uint256 collateralPrice = _latestPrice(false);\n        IVault.LiquidationParams memory liquidation = liquidationParams();\n        uint256 healthFactor_ = LiquidationLib.healthFactor(mintAmount, tcapPrice, collateralAmount, collateralPrice, COLLATERAL_DECIMALS);\n        if (healthFactor_ >= liquidation.threshold) revert LoanHealthy();\n\n        liquidationReward = LiquidationLib.liquidationReward(burnAmount, tcapPrice, collateralPrice, liquidation.penalty, COLLATERAL_DECIMALS);\n        if (liquidationReward > collateralAmount) {\n            // if mintValue < collateralValue + liquidationPenalty, liquidationReward will be > collateralAmount\n            // in this case, we will liquidate the entire collateral\n            // liquidation reward cannot be greater than collateral amount if the loan health is greater than 100% + liquidation penalty\n            if (burnAmount != mintAmount) revert InvalidValue(IVault.ErrorCode.MUST_LIQUIDATE_ENTIRE_POSITION);\n            liquidationReward = collateralAmount;\n        } else {\n            uint256 minBurnAmount = LiquidationLib.tokensRequiredForTargetHealthFactor(\n                healthFactor_, liquidation.threshold + liquidation.minHealthFactor, mintAmount, liquidation.penalty\n            );\n\n            // if the minimum burn amount required to reach the minimum health factor is greater than the minted amount, we need to liquidate the entire position\n            if (minBurnAmount > mintAmount) minBurnAmount = mintAmount;\n\n            // ensure health factor is above liquidation threshold + min health factor delta after liquidation, e.g., 150% + 10% = 160%\n            if (burnAmount < minBurnAmount) {\n                revert InvalidValue(IVault.ErrorCode.HEALTH_FACTOR_BELOW_MINIMUM);\n            }\n            // ensure health factor is below liquidation threshold + max health factor delta after liquidation, e.g., 150% + 30% = 180%\n            if (\n                burnAmount\n                    > LiquidationLib.tokensRequiredForTargetHealthFactor(\n                        healthFactor_, liquidation.threshold + liquidation.maxHealthFactor, mintAmount, liquidation.penalty\n                    )\n            ) {\n                revert InvalidValue(IVault.ErrorCode.HEALTH_FACTOR_ABOVE_MAXIMUM);\n            }\n        }\n\n        _getVaultStorage().mintData.modifyPosition(_toMintId(user, pocketId), -1 * (burnAmount.toInt256()));\n        TCAPV2.burn(msg.sender, burnAmount);\n        pocket.withdraw(user, liquidationReward, msg.sender);\n        emit Liquidated(msg.sender, user, pocketId, liquidationReward, burnAmount);\n    }\n\n    /// @inheritdoc IVault\n    function takeFee(address user, uint96 pocketId) external {\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        _takeFee(pocket, user, pocketId);\n    }\n\n    /// @inheritdoc IVault\n    function collateralValueOfUser(address user, uint96 pocketId) external view returns (uint256) {\n        return collateralValueOf(collateralOf(user, pocketId));\n    }\n\n    /// @inheritdoc IVault\n    function healthFactor(address user, uint96 pocketId) external view returns (uint256) {\n        return _healthFactor(user, pocketId, false);\n    }\n\n    /// @inheritdoc IVault\n    function collateralValueOf(uint256 amount) public view returns (uint256) {\n        return amount * _latestPrice(false) / 10 ** COLLATERAL_DECIMALS;\n    }\n\n    /// @inheritdoc IVault\n    function mintedValueOf(uint256 amount) public view returns (uint256) {\n        return TCAPV2.latestPriceOf(amount);\n    }\n\n    /// @inheritdoc IVault\n    function mintedValueOfUser(address user, uint96 pocketId) external view returns (uint256) {\n        return mintedValueOf(mintedAmountOf(user, pocketId));\n    }\n\n    /// @inheritdoc IVault\n    function collateralOf(address user, uint96 pocketId) public view returns (uint256) {\n        uint256 balance = _balanceOf(user, pocketId);\n        uint256 interest = outstandingInterestOf(user, pocketId);\n        if (interest > balance) return 0;\n        return balance - interest;\n    }\n\n    /// @inheritdoc IVault\n    function mintedAmountOf(address user, uint96 pocketId) public view returns (uint256) {\n        return _getVaultStorage().mintData.deposits[_toMintId(user, pocketId)].mintAmount;\n    }\n\n    /// @inheritdoc IVault\n    function outstandingInterestOf(address user, uint96 pocketId) public view returns (uint256) {\n        MintData storage $ = _getVaultStorage().mintData;\n        uint256 interestAmount = $.interestOf(_toMintId(user, pocketId));\n        return interestAmount * TCAPV2.latestPrice() / _latestPrice(false) * 10 ** COLLATERAL_DECIMALS / 10 ** Constants.TCAP_DECIMALS;\n    }\n\n    /// @inheritdoc IVault\n    function latestPrice() external view returns (uint256) {\n        return _latestPrice(false);\n    }\n\n    /// @inheritdoc IVault\n    function oracle() external view returns (address) {\n        return address(_getVaultStorage().oracle);\n    }\n\n    /// @inheritdoc IVault\n    function interestRate() external view returns (uint16) {\n        return _getVaultStorage().mintData.feeData.fee;\n    }\n\n    /// @inheritdoc IVault\n    function feeRecipient() external view returns (address) {\n        return _getVaultStorage().feeRecipient;\n    }\n\n    /// @inheritdoc IVault\n    function liquidationParams() public view returns (IVault.LiquidationParams memory params) {\n        params = _getVaultStorage().liquidationParams;\n    }\n\n    /// @inheritdoc IVault\n    function pockets(uint96 id) external view returns (IPocket) {\n        return _getVaultStorage().pockets[id].pocket;\n    }\n\n    /// @inheritdoc IVault\n    function pocketEnabled(uint96 id) external view returns (bool) {\n        return _getVaultStorage().pockets[id].enabled;\n    }\n\n    function _takeFee(IPocket pocket, address user, uint96 pocketId) internal {\n        uint256 interest = outstandingInterestOf(user, pocketId);\n        uint256 collateral = _balanceOf(user, pocketId);\n        if (interest > collateral) interest = collateral;\n        VaultStorage storage $ = _getVaultStorage();\n        address feeRecipient_ = $.feeRecipient;\n        if (interest != 0 && feeRecipient_ != address(0)) {\n            $.mintData.resetInterestOf(_toMintId(user, pocketId));\n            pocket.withdraw(user, interest, feeRecipient_);\n            emit FeeCollected(user, pocketId, feeRecipient_, interest);\n        }\n    }\n\n    function _updateInterestRate(uint16 fee) internal {\n        if (fee > Constants.MAX_FEE) revert InvalidValue(IVault.ErrorCode.MAX_FEE);\n        VaultStorage storage $ = _getVaultStorage();\n        $.mintData.setInterestRate(fee);\n        emit InterestRateUpdated(fee);\n    }\n\n    function _updateFeeRecipient(address newFeeRecipient) internal {\n        VaultStorage storage $ = _getVaultStorage();\n        $.feeRecipient = newFeeRecipient;\n        emit FeeRecipientUpdated(newFeeRecipient);\n    }\n\n    function _updateLiquidationParams(IVault.LiquidationParams calldata liquidation) internal {\n        if (liquidation.penalty > Constants.MAX_LIQUIDATION_PENALTY) revert InvalidValue(IVault.ErrorCode.MAX_LIQUIDATION_PENALTY);\n        if (liquidation.threshold > Constants.MAX_LIQUIDATION_THRESHOLD - liquidation.penalty) revert InvalidValue(IVault.ErrorCode.MAX_LIQUIDATION_THRESHOLD);\n        if (liquidation.threshold < Constants.MIN_LIQUIDATION_THRESHOLD + liquidation.penalty) {\n            revert InvalidValue(IVault.ErrorCode.MIN_LIQUIDATION_THRESHOLD);\n        }\n        if (liquidation.minHealthFactor < Constants.MIN_POST_LIQUIDATION_HEALTH_FACTOR) {\n            revert InvalidValue(IVault.ErrorCode.MIN_POST_LIQUIDATION_HEALTH_FACTOR);\n        }\n        if (liquidation.maxHealthFactor > Constants.MAX_POST_LIQUIDATION_HEALTH_FACTOR) {\n            revert InvalidValue(IVault.ErrorCode.MAX_POST_LIQUIDATION_HEALTH_FACTOR);\n        }\n        if (liquidation.minHealthFactor >= liquidation.maxHealthFactor) {\n            revert InvalidValue(IVault.ErrorCode.INCOMPATIBLE_MAX_POST_LIQUIDATION_HEALTH_FACTOR);\n        }\n        VaultStorage storage $ = _getVaultStorage();\n        $.liquidationParams = liquidation;\n        emit LiquidationParamsUpdated(liquidation);\n    }\n\n    function _updateOracle(address newOracle) internal {\n        if (IOracle(newOracle).asset() != address(COLLATERAL)) revert IOracle.InvalidOracle();\n        VaultStorage storage $ = _getVaultStorage();\n        $.oracle = IOracle(newOracle);\n        emit OracleUpdated(newOracle);\n    }\n\n    function _getPocket(uint96 pocketId) internal view returns (IPocket) {\n        Pocket storage p = _getVaultStorage().pockets[pocketId];\n        if (!p.enabled) revert PocketNotEnabled(pocketId);\n        return p.pocket;\n    }\n\n    function _latestPrice(bool checkStaleness) internal view returns (uint256) {\n        return _getVaultStorage().oracle.latestPrice(checkStaleness);\n    }\n\n    function _healthFactor(address user, uint96 pocketId, bool checkStaleness) internal view returns (uint256) {\n        return LiquidationLib.healthFactor(\n            mintedAmountOf(user, pocketId), TCAPV2.latestPrice(), collateralOf(user, pocketId), _latestPrice(checkStaleness), COLLATERAL_DECIMALS\n        );\n    }\n\n    function _balanceOf(address user, uint96 pocketId) internal view returns (uint256) {\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        return pocket.balanceOf(user);\n    }\n\n    function _toMintId(address user, uint96 pocketId) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(user, pocketId)));\n    }\n\n    /// @inheritdoc IVersioned\n    function version() external pure returns (string memory) {\n        return "1.0.0";\n    }\n}",
    "vulnerable_lines": [9],
    "vulnerable_functions": ["takeFee"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.takeFee(TargetUser, pocketId) -> Vault.takeFee executes without access check -> Fee is subtracted from TargetUser's shares -> Proportional ownership is unfairly redistributed.",
  "context_hint": "Missing access control on a maintenance function that mutates state (adjusts user shares based on accrued fee). The lack of protection allows for selective application of the fee, disrupting proportional ownership among depositors.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The vulnerability lies in the function's external visibility combined with its state-mutating effect on a specific user's shares. Since fee accrual is constant, the time it is applied should be protected or symmetric."
}

{
  "id": "gs_koolex_hydration_H01",
  "subset": "gold_standard",
  "language": "rust",
  "chain": "other",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Hydration Tokenomics Audit",
  "source_finding_id": "[H-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Hydration-security-review-October.pdf",
  "github_repo_url": "https://github.com/galacticcouncil/hydration-node/tree/90eb2543cbe037626ed2c5f263f876bc5db6825a",
  "contest_date": "2025-10-17",
  
  "severity": "high",
  "vulnerability_type": "incorrect_function_modifier",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "TransferFrom is incorrectly treated as a view function",
  "finding_description": "In the `execute` function of the MultiCurrencyPrecompile module, the `check_function_modifier` logic incorrectly defaults `Function::TransferFrom` to `FunctionModifier::View`. This happens because `Function::TransferFrom` is missing from the `match selector` statement, causing it to fall through to the default `_ => FunctionModifier::View`. This is incorrect because `TransferFrom` is a state-changing function that requires `FunctionModifier::NonPayable`.",
  "attack_scenario": "If the `MultiCurrencyPrecompile` is executed in a context that strictly enforces view-only restrictions (e.g., in a query or a context that doesn't permit state changes), a call intended to execute `TransferFrom` will fail or revert because the precompile incorrectly signals it as a view function. This breaks a core token transfer mechanism and can lead to unexpected failures in dApps or cross-chain operations relying on this precompile.",
  "fix_description": "Include `Function::TransferFrom` in the `check_function_modifier` match statement and assign it `FunctionModifier::NonPayable`, mirroring the treatment of `Function::Transfer`.",
  
  "primary_file": {
    "path": "precompiles/utils/src/precompile_set.rs",
    "content": "// Copyright 2019-2022 PureStake Inc.\n// This file is part of Moonbeam.\n\n// Moonbeam is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Moonbeam is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Moonbeam.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Provide utils to assemble precompiles and precompilesets into a\n//! final precompile set with security checks. All security checks are enabled by\n//! default and must be disabled explicely throught type annotations.\n\nuse crate::{\n\tevm::handle::PrecompileHandleExt,\n\tsolidity::{codec::String, revert::revert},\n\tEvmResult,\n};\nuse fp_evm::{\n\tExitError, IsPrecompileResult, Precompile, PrecompileFailure, PrecompileHandle, PrecompileResult, PrecompileSet,\n};\nuse frame_support::pallet_prelude::Get;\nuse impl_trait_for_tuples::impl_for_tuples;\nuse pallet_evm::AddressMapping;\nuse sp_core::{H160, H256};\nuse sp_std::{\n\tcell::RefCell, collections::btree_map::BTreeMap, marker::PhantomData, ops::RangeInclusive, vec, vec::Vec,\n};\n\n/// Trait representing checks that can be made on a precompile call.\n/// Types implementing this trait are made to be chained in a tuple.\n///\n/// For that reason every method returns an Option, None meaning that\n/// the implementor have no constraint and the decision is left to\n/// latter elements in the chain. If None is returned by all elements of\n/// the chain then sensible defaults are used.\n///\n/// Both `PrecompileAt` and `PrecompileSetStartingWith` have a type parameter that must\n/// implement this trait to configure the checks of the precompile(set) it represents.\npub trait PrecompileChecks {\n\t#[inline(always)]\n\t/// Is there a limit to the amount of recursions this precompile\n\t/// can make using subcalls? 0 means this specific precompile will not\n\t/// be callable as a subcall of itself, 1 will allow one level of recursion,\n\t/// etc...\n\t///\n\t/// If all checks return None, defaults to `Some(0)` (no recursion allowed).\n\tfn recursion_limit() -> Option<Option<u16>> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Does this precompile supports being called with DELEGATECALL or CALLCODE?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn accept_delegate_call() -> Option<bool> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Is this precompile callable by a smart contract?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn callable_by_smart_contract(_caller: H160, _called_selector: Option<u32>) -> Option<bool> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Is this precompile callable by a precompile?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn callable_by_precompile(_caller: H160, _called_selector: Option<u32>) -> Option<bool> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Is this precompile able to do subcalls?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn allow_subcalls() -> Option<bool> {\n\t\tNone\n\t}\n\n\t/// Summarize the checks when being called by a smart contract.\n\tfn callable_by_smart_contract_summary() -> Option<String> {\n\t\tNone\n\t}\n\n\t/// Summarize the checks when being called by a precompile.\n\tfn callable_by_precompile_summary() -> Option<String> {\n\t\tNone\n\t}\n}\n\n#[derive(Debug, Clone)]\npub enum DiscriminantResult<T> {\n\tSome(T, u64),\n\tNone(u64),\n\tOutOfGas,\n}\n\nimpl<T> Into<IsPrecompileResult> for DiscriminantResult<T> {\n\tfn into(self) -> IsPrecompileResult {\n\t\tmatch self {\n\t\t\tSelf::Some(_, extra_cost) => IsPrecompileResult::Answer {\n\t\t\t\tis_precompile: true,\n\t\t\t\textra_cost,\n\t\t\t},\n\t\t\tSelf::None(extra_cost) => IsPrecompileResult::Answer {\n\t\t\t\tis_precompile: false,\n\t\t\t\textra_cost,\n\t\t\t},\n\t\t\tSelf::OutOfGas => IsPrecompileResult::OutOfGas,\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone)]\n#[cfg_attr(feature = "testing", derive(serde::Serialize, serde::Deserialize))]\npub enum PrecompileKind {\n\tSingle(H160),\n\tMultiple(Vec<H160>),\n\tPrefixed(Vec<u8>),\n}\n\n#[derive(Debug, Clone)]\n#[cfg_attr(feature = "testing", derive(serde::Serialize, serde::Deserialize))]\npub struct PrecompileCheckSummary {\n\tpub name: Option<String>,\n\tpub precompile_kind: PrecompileKind,\n\tpub recursion_limit: Option<u16>,\n\tpub accept_delegate_call: bool,\n\tpub callable_by_smart_contract: String,\n\tpub callable_by_precompile: String,\n}\n\n#[impl_for_tuples(0, 20)]\nimpl PrecompileChecks for Tuple {\n\t#[inline(always)]\n\tfn recursion_limit() -> Option<Option<u16>> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::recursion_limit() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn accept_delegate_call() -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::accept_delegate_call() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn callable_by_smart_contract(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_smart_contract(caller, called_selector) {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn callable_by_precompile(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_precompile(caller, called_selector) {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn allow_subcalls() -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::allow_subcalls() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\tfn callable_by_smart_contract_summary() -> Option<String> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_smart_contract_summary() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\tfn callable_by_precompile_summary() -> Option<String> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_precompile_summary() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n}\n\n/// Precompile can be called using DELEGATECALL/CALLCODE.\npub struct AcceptDelegateCall;\n\nimpl PrecompileChecks for AcceptDelegateCall {\n\t#[inline(always)]\n\tfn accept_delegate_call() -> Option<bool> {\n\t\tSome(true)\n\t}\n}\n\n/// Precompile is able to do subcalls with provided nesting limit.\npub struct SubcallWithMaxNesting<const R: u16>;\n\nimpl<const R: u16> PrecompileChecks for SubcallWithMaxNesting<R> {\n\t#[inline(always)]\n\tfn recursion_limit() -> Option<Option<u16>> {\n\t\tSome(Some(R))\n\t}\n\n\t#[inline(always)]\n\tfn allow_subcalls() -> Option<bool> {\n\t\tSome(true)\n\t}\n}\n\npub trait SelectorFilter {\n\tfn is_allowed(_caller: H160, _selector: Option<u32>) -> bool;\n\n\tfn description() -> String;\n}\npub struct ForAllSelectors;\nimpl SelectorFilter for ForAllSelectors {\n\tfn is_allowed(_caller: H160, _selector: Option<u32>) -> bool {\n\t\ttrue\n\t}\n\n\tfn description() -> String {\n\t\t"Allowed for all selectors and callers".into()\n\t}\n}\n\npub struct OnlyFrom<T>(PhantomData<T>);\nimpl<T: Get<H160>> SelectorFilter for OnlyFrom<T> {\n\tfn is_allowed(caller: H160, _selector: Option<u32>) -> bool {\n\t\tcaller == T::get()\n\t}\n\n\tfn description() -> String {\n\t\talloc::format!("Allowed for all selectors only if called from {}", T::get())\n\t}\n}\n\npub struct CallableByContract<T = ForAllSelectors>(PhantomData<T>);\n\nimpl<T: SelectorFilter> PrecompileChecks for CallableByContract<T> {\n\t#[inline(always)]\n\tfn callable_by_smart_contract(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tSome(T::is_allowed(caller, called_selector))\n\t}\n\n\tfn callable_by_smart_contract_summary() -> Option<String> {\n\t\tSome(T::description())\n\t}\n}\n\n/// Precompiles are allowed to call this precompile.\npub struct CallableByPrecompile<T = ForAllSelectors>(PhantomData<T>);\n\nimpl<T: SelectorFilter> PrecompileChecks for CallableByPrecompile<T> {\n\t#[inline(always)]\n\tfn callable_by_precompile(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tSome(T::is_allowed(caller, called_selector))\n\t}\n\n\tfn callable_by_precompile_summary() -> Option<String> {\n\t\tSome(T::description())\n\t}\n}\n\n/// The type of EVM address.\n#[derive(PartialEq)]\n#[cfg_attr(feature = "std", derive(Debug))]\npub enum AddressType {\n\t/// The code stored at the address is less than 5 bytes, but not well known.\n\tUnknown,\n\t/// No code is stored at the address, therefore is EOA.\n\tEOA,\n\t/// The 5-byte magic constant for a precompile is stored at the address.\n\tPrecompile,\n\t/// The code is greater than 5-bytes, potentially a Smart Contract.\n\tContract,\n}\n\n/// Retrieves the type of address demarcated by `AddressType`.\npub fn get_address_type<R: pallet_evm::Config>(\n\thandle: &mut impl PrecompileHandle,\n\taddress: H160,\n) -> Result<AddressType, ExitError> {\n\t// AccountCodesMetadata:\n\t// Blake2128(16) + H160(20) + CodeMetadata(40)\n\thandle.record_db_read::<R>(76)?;\n\tlet code_len = pallet_evm::Pallet::<R>::account_code_metadata(address).size;\n\n\t// 0 => either EOA or precompile without dummy code\n\tif code_len == 0 {\n\t\treturn Ok(AddressType::EOA);\n\t}\n\n\t// dummy code is 5 bytes long, so any other len means it is a contract.\n\tif code_len != 5 {\n\t\treturn Ok(AddressType::Contract);\n\t}\n\n\t// check code matches dummy code\n\thandle.record_db_read::<R>(code_len as usize)?;\n\tlet code = pallet_evm::AccountCodes::<R>::get(address);\n\tif &code == &[0x60, 0x00, 0x60, 0x00, 0xfd] {\n\t\treturn Ok(AddressType::Precompile);\n\t}\n\n\tOk(AddressType::Unknown)\n}\n\nfn is_address_eoa_or_precompile<R: pallet_evm::Config>(\n\thandle: &mut impl PrecompileHandle,\n\taddress: H160,\n) -> Result<bool, ExitError> {\n\tmatch get_address_type::<R>(handle, address)? {\n\t\tAddressType::EOA | AddressType::Precompile => Ok(true),\n\t\t_ => Ok(false),\n\t}\n}\n\n/// Common checks for precompile and precompile sets.\n/// Don't contain recursion check as precompile sets have recursion check for each member.\nfn common_checks<R: pallet_evm::Config, C: PrecompileChecks>(handle: &mut impl PrecompileHandle) -> EvmResult<()> {\n\tlet code_address = handle.code_address();\n\tlet caller = handle.context().caller;\n\n\t// Check DELEGATECALL config.\n\tlet accept_delegate_call = C::accept_delegate_call().unwrap_or(false);\n\tif !accept_delegate_call && code_address != handle.context().address {\n\t\treturn Err(revert("Cannot be called with DELEGATECALL or CALLCODE"));\n\t}\n\n\t// Extract which selector is called.\n\tlet selector = handle.input().get(0..4).map(|bytes| {\n\t\tlet mut buffer = [0u8; 4];\n\t\tbuffer.copy_from_slice(bytes);\n\t\tu32::from_be_bytes(buffer)\n\t});\n\n\t// Is this selector callable from a smart contract?\n\tlet callable_by_smart_contract = C::callable_by_smart_contract(caller, selector).unwrap_or(false);\n\tif !callable_by_smart_contract {\n\t\tif !is_address_eoa_or_precompile::<R>(handle, caller)? {\n\t\t\treturn Err(revert("Function not callable by smart contracts"));\n\t\t}\n\t}\n\n\t// Is this selector callable from a precompile?\n\tlet callable_by_precompile = C::callable_by_precompile(caller, selector).unwrap_or(false);\n\tif !callable_by_precompile && is_precompile_or_fail::<R>(caller, handle.remaining_gas())? {\n\t\treturn Err(revert("Function not callable by precompiles"));\n\t}\n\n\tOk(())\n}\n\npub fn is_precompile_or_fail<R: pallet_evm::Config>(address: H160, gas: u64) -> EvmResult<bool> {\n\tmatch <R as pallet_evm::Config>::PrecompilesValue::get().is_precompile(address, gas) {\n\t\tIsPrecompileResult::Answer { is_precompile, .. } => Ok(is_precompile),\n\t\tIsPrecompileResult::OutOfGas => Err(PrecompileFailure::Error {\n\t\t\texit_status: ExitError::OutOfGas,\n\t\t}),\n\t}\n}\n\npub struct AddressU64<const N: u64>;\nimpl<const N: u64> Get<H160> for AddressU64<N> {\n\t#[inline(always)]\n\tfn get() -> H160 {\n\t\tH160::from_low_u64_be(N)\n\t}\n}\n\npub struct RestrictiveHandle<'a, H> {\n\thandle: &'a mut H,\n\tallow_subcalls: bool,\n}\n\nimpl<'a, H: PrecompileHandle> PrecompileHandle for RestrictiveHandle<'a, H> {\n\tfn call(\n\t\t&mut self,\n\t\taddress: H160,\n\t\ttransfer: Option<fp_evm::Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: &fp_evm::Context,\n\t) -> (fp_evm::ExitReason, Vec<u8>) {\n\t\tif !self.allow_subcalls {\n\t\t\treturn (\n\t\t\t\tfp_evm::ExitReason::Revert(fp_evm::ExitRevert::Reverted),\n\t\t\t\tcrate::solidity::revert::revert_as_bytes("subcalls disabled for this precompile"),\n\t\t\t);\n\t\t}\n\n\t\tself.handle\n\t\t\t.call(address, transfer, input, target_gas, is_static, context)\n\t}\n\n\tfn record_cost(&mut self, cost: u64) -> Result<(), fp_evm::ExitError> {\n\t\tself.handle.record_cost(cost)\n\t}\n\n\tfn remaining_gas(&self) -> u64 {\n\t\tself.handle.remaining_gas()\n\t}\n\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) -> Result<(), fp_evm::ExitError> {\n\t\tself.handle.log(address, topics, data)\n\t}\n\n\tfn code_address(&self) -> H160 {\n\t\tself.handle.code_address()\n\t}\n\n\tfn input(&self) -> &[u8] {\n\t\tself.handle.input()\n\t}\n\n\tfn context(&self) -> &fp_evm::Context {\n\t\tself.handle.context()\n\t}\n\n\tfn is_static(&self) -> bool {\n\t\tself.handle.is_static()\n\t}\n\n\tfn gas_limit(&self) -> Option<u64> {\n\t\tself.handle.gas_limit()\n\t}\n\n\tfn record_external_cost(\n\t\t&mut self,\n\t\tref_time: Option<u64>,\n\t\tproof_size: Option<u64>,\n\t\tstorage_growth: Option<u64>,\n\t) -> Result<(), ExitError> {\n\t\tself.handle.record_external_cost(ref_time, proof_size, storage_growth)\n\t}\n\n\tfn refund_external_cost(&mut self, ref_time: Option<u64>, proof_size: Option<u64>) {\n\t\tself.handle.refund_external_cost(ref_time, proof_size)\n\t}\n}\n\n/// Allows to know if a precompile is active or not.\n/// This allows to detect deactivated precompile, that are still considered precompiles by\n/// the EVM but that will always revert when called.\npub trait IsActivePrecompile {\n\t/// Is the provided address an active precompile, a precompile that has\n\t/// not be deactivated. Note that a deactivated precompile is still considered a precompile\n\t/// for the EVM, but it will always revert when called.\n\tfn is_active_precompile(&self, address: H160, gas: u64) -> IsPrecompileResult;\n}\n\n// INDIVIDUAL PRECOMPILE(SET)\n\n/// A fragment of a PrecompileSet. Should be implemented as is it\n/// was a PrecompileSet containing only the precompile(set) it wraps.\n/// They can be combined into a real PrecompileSet using `PrecompileSetBuilder`.\npub trait PrecompileSetFragment {\n\t/// Instanciate the fragment.\n\tfn new() -> Self;\n\n\t/// Execute the fragment.\n\tfn execute<R: pallet_evm::Config>(&self, handle: &mut impl PrecompileHandle) -> Option<PrecompileResult>;\n\n\t/// Is the provided address a precompile in this fragment?\n\tfn is_precompile(&self, address: H160, gas: u64) -> IsPrecompileResult;\n\n\t/// Return the list of addresses covered by this fragment.\n\tfn used_addresses(&self) -> Vec<H160>;\n\n\t/// Summarize\n\tfn summarize_checks(&self) -> Vec<PrecompileCheckSummary>;\n}\n\n/// Wraps a stateless precompile: a type implementing the `Precompile` trait.\n/// Type parameters allow to define:\n/// - A: The address of the precompile\n/// - R: The recursion limit (defaults to 1)\n/// - D: If DELEGATECALL is supported (default to no)\npub struct PrecompileAt<A, P, C = ()> {\n\tcurrent_recursion_level: RefCell<u16>,\n\t_phantom: PhantomData<(A, P, C)>,\n}\n\nimpl<A, P, C> PrecompileSetFragment for PrecompileAt<A, P, C>\nwhere\n\tA: Get<H160>,\n\tP: Precompile,\n\tC: PrecompileChecks,\n{\n\t#[inline(always)]\n\tfn new() -> Self {\n\t\tSelf {\n\t\t\tcurrent_recursion_level: RefCell::new(0),\n\t\t\t_phantom: PhantomData,\n\t\t}\n\t}\n\n\t#[inline(always)]\n\tfn execute<R: pallet_evm::Config>(&self, handle: &mut impl PrecompileHandle) -> Option<PrecompileResult> {\n\t\tlet code_address = handle.code_address();\n\n\t\t// Check if this is the address of the precompile.\n\t\tif A::get() != code_address {\n\t\t\treturn None;\n\t\t}\n\n\t\t// Perform common checks.\n\t\tif let Err(err) = common_checks::<R, C>(handle) {\n\t\t\treturn Some(Err(err));\n\t\t}\n\n\t\t// Check and increase recursion level if needed.\n\t\tlet recursion_limit = C::recursion_limit().unwrap_or(Some(0));\n\t\tif let Some(max_recursion_level) = recursion_limit {\n\t\t\tmatch self.current_recursion_level.try_borrow_mut() {\n\t\t\t\tOk(mut recursion_level) => {\n\t\t\t\t\tif *recursion_level > max_recursion_level {\n\t\t\t\t\t\treturn Some(Err(revert("Precompile is called with too high nesting").into()));\n\t\t\t\t\t}\n\n\t\t\t\t\t*recursion_level += 1;\n\t\t\t\t}\n\t\t\t\t// We don't hold the borrow and are in single-threaded code, thus we should\n\t\t\t\t// not be able to fail borrowing in nested calls.\n\t\t\t\tErr(_) => return Some(Err(revert("Couldn't check precompile nesting").into())),\n\t\t\t}\n\t\t}\n\n\t\t// Subcall protection.\n\t\tlet allow_subcalls = C::allow_subcalls().unwrap_or(false);\n\t\tlet mut handle = RestrictiveHandle { handle, allow_subcalls };\n\n\t\tlet res = P::execute(&mut handle);\n\n\t\t// Decrease recursion level if needed.\n\t\tif recursion_limit.is_some() {\n\t\t\tmatch self.current_recursion_level.try_borrow_mut() {\n\t\t\t\tOk(mut recursion_level) => {\n\t\t\t\t\t*recursion_level -= 1;\n\t\t\t\t}\n\t\t\t\t// We don't hold the borrow and are in single-threaded code, thus we should\n\t\t\t\t// not be able to fail borrowing in nested calls.\n\t\t\t\tErr(_) => return Some(Err(revert("Couldn't check precompile nesting").into())),\n\t\t\t}\n\t\t}\n\n\t\tSome(res)\n\t}\n\n\t#[inline(always)]\n\tfn is_precompile(&self, address: H160, _gas: u64) -> IsPrecompileResult {\n\t\tIsPrecompileResult::Answer {\n\t\t\tis_precompile: address == A::get(),\n\t\t\textra_cost: 0,\n\t\t}\n\t}\n\n\t#[inline(always)]\n\tfn used_addresses(&self) -> Vec<H160> {\n\t\tvec![A::get()]\n\t}\n\n\tfn summarize_checks(&self) -> Vec<PrecompileCheckSummary> {\n\t\tvec![PrecompileCheckSummary {\n\t\t\tname: None,\n\t\t\tprecompile_kind: PrecompileKind::Single(A::get()),\n\t\t\trecursion_limit: C::recursion_limit().unwrap_or(Some(0)),\n\t\t\taccept_delegate_call: C::accept_delegate_call().unwrap_or(false),\n\t\t\tcallable_by_smart_contract: C::callable_by_smart_contract_summary()\n\t\t\t\t.unwrap_or_else(|| "Not callable".into()),\n\t\t\tcallable_by_precompile: C::callable_by_precompile_summary().unwrap_or_else(|| "Not callable".into()),\n\t\t}]\n\t}\n}\n\nimpl<A, P, C> IsActivePrecompile for PrecompileAt<A, P, C>\nwhere\n\tA: Get<H160>,\n{\n\t#[inline(always)]\n\tfn is_active_precompile(&self, address: H160, _gas: u64) -> IsPrecompileResult {\n\t\tIsPrecompileResult::Answer {\n\t\t\tis_precompile: address == A::get(),\n\t\t\textra_cost: 0,\n\t\t}\n\t}\n}\n\n/// Wraps an inner PrecompileSet with all its addresses starting with\n/// a common prefix.\n/// Type parameters allow to define:\n/// - A: The common prefix\n/// - D: If DELEGATECALL is supported (default to no)\npub struct PrecompileSetStartingWith<A, P, C = ()> {\n\tprecompile_set: P,\n\tcurrent_recursion_level: RefCell<BTreeMap<H160, u16>>,\n\t_phantom: PhantomData<(A, C)>,\n}\n\nimpl<A, P, C> PrecompileSetFragment for PrecompileSetStartingWith<A, P, C>\nwhere\n\tA: Get<&'static [u8]>,\n\tP: PrecompileSet + Default,\n\tC: PrecompileChecks,\n{\n\t#[inline(always)]\n\tfn new() -> Self {\n\t\tSelf {\n\t\t\tprecompile_set: P::default(),\n\t\t\tcurrent_recursion_level: RefCell::new(BTreeMap::new()),\n\t\t\t_phantom: PhantomData,\n",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["execute"]
  },
  
  "context_files": [],
  
  "call_flow": "EVM call to Precompile -> `execute` function -> `check_function_modifier(match selector)` -> `TransferFrom` is not matched -> Defaults to `FunctionModifier::View` -> Execution environment rejects state change.",
  "context_hint": "A logic error in the EVM precompile wrapper for token transfers. By misclassifying the `TransferFrom` state-changing function as a view function, the precompile violates the expected execution context, leading to high-impact failures of core token functionality.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A fundamental issue in the precompile implementation that breaks standard ERC20 compatibility. While the impact is a failure/revert rather than fund loss, disabling a core transfer mechanism is a High severity DOS."
}

{
  "id": "gs_pashov_hyperbeat_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Hyperbeat Security Review",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Hyperbeat-security-review_2025-09-03.pdf",
  "github_repo_url": "https://github.com/etherfi-protocol/beHYPE/tree/c620e61aaf8fe5767e713bb9d7447bd9fbc40148/src",
  "contest_date": "2025-09-03",
  
  "severity": "medium",
  "vulnerability_type": "liquidity_miscalculation",
  "difficulty_tier": 2,
  "context_level": "multi_file",
  
  "finding_title": "getTotalProtocolHype() includes pending withdrawal amounts",
  "finding_description": "The `getTotalProtocolHype()` function in `StakingCore.sol`, which calculates the total HYPE (the underlying asset) owned by the protocol, fails to subtract the amount of HYPE that has been requested for withdrawal (`hypeRequestedForWithdraw`) but not yet finalized (i.e., not yet transferred from `StakingCore` to `WithdrawManager`). This inflated TVL calculation is then used by functions like `lowWatermarkInHYPE()` and `getLiquidHypeAmount()` in `WithdrawManager.sol`, leading to an incorrect calculation of `withdrawableAmount` during instant withdrawal flow.",
  "attack_scenario": "1. A user queues a delayed withdrawal for 1000 HYPE, increasing `hypeRequestedForWithdraw`. The total protocol HYPE is 10000 HYPE.\n2. Since `getTotalProtocolHype()` still returns 10000 HYPE, the calculated liquid available for instant withdrawal is incorrectly inflated by 1000 HYPE.\n3. A malicious user can exploit this window before `finalizeWithdrawals()` is called to instantly withdraw more liquidity than is actually available to the protocol, leading to a temporary liquidity crunch and potential denial of service for future instant withdrawals.",
  "fix_description": "Create a separate function, `getAvailableProtocolHype()`, which calculates the total HYPE but subtracts `hypeRequestedForWithdraw` from the total. This new function should be used when calculating the instant withdrawal limit (e.g., in `lowWatermarkInHYPE()` and `getLiquidHypeAmount()`) to prevent temporary over-withdrawal. In `getLiquidHypeAmount()`, ensure the subtraction is protected from underflow.",
  
  "primary_file": {
    "path": "StakingCore.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport {Math} from "@openzeppelin/contracts/utils/math/Math.sol";\nimport {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";\nimport {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\nimport {IRoleRegistry} from "./interfaces/IRoleRegistry.sol";\nimport {IBeHYPEToken} from "./interfaces/IBeHYPE.sol";\nimport {IStakingCore} from "./interfaces/IStakingCore.sol";\nimport {IWithdrawManager} from "./interfaces/IWithdrawManager.sol";\nimport {L1Read} from "./lib/L1Read.sol";\nimport {CoreWriter} from "./lib/CoreWriter.sol";\n\ncontract StakingCore is IStakingCore, Initializable, UUPSUpgradeable, PausableUpgradeable {\n\n    IRoleRegistry public roleRegistry;\n    IBeHYPEToken public beHypeToken;\n    address public withdrawManager;\n    uint256 public exchangeRatio;\n    uint16 public acceptablAprInBps;\n    bool public exchangeRateGuard;\n    uint256 public lastExchangeRatioUpdate;\n    uint256 public withdrawalCooldownPeriod;\n    uint256 public lastWithdrawalTimestamp;\n    uint256 public lastHyperCoreOperationBlock;\n\n    uint64 public constant HYPE_TOKEN_ID = 150;\n    address public constant L1_HYPE_CONTRACT = 0x2222222222222222222222222222222222222222;\n    L1Read public constant l1Read = L1Read(0xb7467E0524Afba7006957701d1F06A59000d15A2);\n    CoreWriter public constant coreWriter = CoreWriter(0x3333333333333333333333333333333333333333);\n    uint256 public constant MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE = 5;\n\n    constructor() { _disableInitializers(); }\n    \n    function initialize(address _roleRegistry, address _beHype, address _withdrawManager, uint16 _acceptablAprInBps, bool _exchangeRateGuard, uint256 _withdrawalCooldownPeriod) public initializer {\n        __UUPSUpgradeable_init();\n        roleRegistry = IRoleRegistry(_roleRegistry);\n        beHypeToken = IBeHYPEToken(_beHype);\n        acceptablAprInBps = _acceptablAprInBps;\n        exchangeRateGuard = _exchangeRateGuard;\n        withdrawManager = _withdrawManager;\n        exchangeRatio = 1 ether;\n        lastExchangeRatioUpdate = block.timestamp;\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        lastWithdrawalTimestamp = block.timestamp;\n        lastHyperCoreOperationBlock = block.number;\n    }\n\n    function stake(string memory communityCode) public payable {\n       if (paused()) revert StakingPaused();\n       beHypeToken.mint(msg.sender, HYPEToBeHYPE(msg.value));\n       emit Deposit(msg.sender, msg.value, communityCode); \n    }\n\n    function updateExchangeRatio() external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 blocksPassed = block.number - lastHyperCoreOperationBlock;\n        if (blocksPassed < MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE) {\n            revert ExchangeRatioUpdateTooSoon(MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE, blocksPassed);\n        }\n        uint256 totalProtocolHype = getTotalProtocolHype();\n        uint256 newRatio = Math.mulDiv(totalProtocolHype, 1e18, beHypeToken.totalSupply());\n        uint256 ratioChange;\n        if (newRatio > exchangeRatio) {\n            ratioChange = newRatio - exchangeRatio;\n        } else {\n            ratioChange = exchangeRatio - newRatio;\n        }\n        uint256 elapsedTime = block.timestamp - lastExchangeRatioUpdate;\n        if (elapsedTime == 0) revert ElapsedTimeCannotBeZero();\n        uint256 percentageChange = Math.mulDiv(ratioChange, 1e18, exchangeRatio);\n        uint256 yearlyRate = Math.mulDiv(percentageChange, 365 days, elapsedTime);\n        uint256 yearlyRateInBps = yearlyRate / 1e14;\n        uint16 yearlyRateInBps16 = uint16(Math.min(yearlyRateInBps, type(uint16).max));\n        if (exchangeRateGuard) {\n            if (yearlyRateInBps16 > acceptablAprInBps) revert ExchangeRatioChangeExceedsThreshold(yearlyRateInBps16);\n        }\n        uint256 oldRatio = exchangeRatio;\n        exchangeRatio = newRatio;\n        lastExchangeRatioUpdate = block.timestamp;\n        emit ExchangeRatioUpdated(oldRatio, exchangeRatio, yearlyRateInBps16);\n    }\n\n    function sendFromWithdrawManager(uint256 amount, address to) external {\n        if (msg.sender != withdrawManager) revert NotAuthorized();\n        (bool success,) = payable(to).call{value: amount}("");\n        if (!success) revert FailedToSendFromWithdrawManager();\n    }\n\n    function setWithdrawManager(address _withdrawManager) external {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n        withdrawManager = _withdrawManager;\n        emit WithdrawManagerUpdated(withdrawManager);\n    }\n\n    function updateAcceptableApr(uint16 _acceptablAprInBps) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        acceptablAprInBps = _acceptablAprInBps;\n        emit AcceptableAprUpdated(_acceptablAprInBps);\n    }\n\n    function updateExchangeRateGuard(bool _exchangeRateGuard) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        exchangeRateGuard = _exchangeRateGuard;\n        emit ExchangeRateGuardUpdated(_exchangeRateGuard);\n    }\n\n    function updateWithdrawalCooldownPeriod(uint256 _withdrawalCooldownPeriod) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        emit WithdrawalCooldownPeriodUpdated(withdrawalCooldownPeriod);\n    }\n\n    function depositToHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 truncatedAmount = amount / 1e10 * 1e10;\n        if (amount != truncatedAmount) {\n            revert PrecisionLossDetected(amount, truncatedAmount);\n        }\n        (bool success,) = payable(L1_HYPE_CONTRACT).call{value: amount}("");\n        if (!success) revert FailedToDepositToHyperCore();\n        lastHyperCoreOperationBlock = block.number;\n        emit HyperCoreDeposit(amount);\n    }\n\n    function withdrawFromHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(6, abi.encode(L1_HYPE_CONTRACT, HYPE_TOKEN_ID, _convertTo8Decimals(amount)));\n        emit HyperCoreWithdraw(amount);\n    }\n\n    function depositToStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(4, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingDeposit(amount);\n    }\n\n    function withdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        if (amount > IWithdrawManager(withdrawManager).hypeRequestedForWithdraw()) revert ExceedsLimit();\n        if (block.timestamp < lastWithdrawalTimestamp + withdrawalCooldownPeriod) {\n            revert WithdrawalCooldownNotMet();\n        }\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        lastWithdrawalTimestamp = block.timestamp;\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function emergencyWithdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function delegateTokens(address validator, uint256 amount, bool isUndelegate) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(3, abi.encode(validator, _convertTo8Decimals(amount), isUndelegate));\n        emit TokenDelegated(validator, amount, isUndelegate);\n    }\n\n    function pauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _pause();\n    }\n\n    function unpauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _unpause();\n    }\n\n    function BeHYPEToHYPE(uint256 beHYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(beHYPEAmount, exchangeRatio, 1e18);\n    }\n    \n    function HYPEToBeHYPE(uint256 HYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(HYPEAmount, 1e18, exchangeRatio);\n    }\n\n    function getTotalProtocolHype() public view returns (uint256) {\n        L1Read.DelegatorSummary memory delegatorSummary = l1Read.delegatorSummary(address(this));\n        uint256 totalHypeInStakingAccount = _convertTo18Decimals(delegatorSummary.delegated) + _convertTo18Decimals(delegatorSummary.undelegated) + _convertTo18Decimals(delegatorSummary.totalPendingWithdrawal);\n        L1Read.SpotBalance memory spotBalance = l1Read.spotBalance(address(this), HYPE_TOKEN_ID);\n        uint256 totalHypeInSpotAccount = _convertTo18Decimals(spotBalance.total);\n        uint256 totalHypeInLiquidityPool = address(this).balance;\n        uint256 total = totalHypeInStakingAccount + totalHypeInSpotAccount + totalHypeInLiquidityPool;\n        return total;\n    }\n\n    function _convertTo8Decimals(uint256 amount) internal pure returns (uint64) {\n        uint256 truncatedAmount = amount / 1e10;\n        if (truncatedAmount > type(uint64).max) revert AmountExceedsUint64Max();\n        return uint64(truncatedAmount);\n    }\n\n    function _convertTo18Decimals(uint64 amount) internal pure returns (uint256) {\n        return uint256(amount) * 1e10;\n    }\n\n    function _encodeAction(uint8 actionId, bytes memory actionData) internal {\n        lastHyperCoreOperationBlock = block.number;\n        bytes memory data = new bytes(4 + actionData.length);\n        data[0] = 0x01;\n        data[1] = 0x00;\n        data[2] = 0x00;\n        data[3] = bytes1(actionId);\n        for (uint256 i = 0; i < actionData.length; i++) {\n            data[4 + i] = actionData[i];\n        }\n        coreWriter.sendRawAction(data);\n    }\n\n    function _authorizeUpgrade(address /* newImplementation */) internal view override {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n    }\n\n    receive() external payable {}\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["getTotalProtocolHype"]
  },
  
  "context_files": [
    {
      "path": "WithdrawManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\nimport {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";\nimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\nimport {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport {Math} from "@openzeppelin/contracts/utils/math/Math.sol";\nimport {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport {IRoleRegistry} from "./interfaces/IRoleRegistry.sol";\nimport {IBeHYPEToken} from "./interfaces/IBeHype.sol";\nimport {IStakingCore} from "./interfaces/IStakingCore.sol";\nimport {IWithdrawManager} from "./interfaces/IWithdrawManager.sol";\nimport {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";\nimport {BucketLimiter} from "./lib/BucketLimiter.sol";\ncontract WithdrawManager is Initializable, UUPSUpgradeable, IWithdrawManager, ReentrancyGuardUpgradeable, PausableUpgradeable {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n    IBeHYPEToken public beHypeToken;\n    IStakingCore public stakingCore;\n    IRoleRegistry public roleRegistry;\n    uint256 public hypeRequestedForWithdraw;\n    uint256 public lastFinalizedIndex;\n    WithdrawalEntry[] public withdrawalQueue;\n    mapping(address => uint256[]) public userWithdrawals;\n    uint256 public minWithdrawalAmount;\n    uint256 public maxWithdrawalAmount;\n    uint16 public instantWithdrawalFeeInBps;\n    uint16 public lowWatermarkInBpsOfTvl;\n    BucketLimiter.Limit public instantWithdrawalLimit;\n    uint256 public constant BUCKET_UNIT_SCALE = 1e12;\n    uint256 public constant BASIS_POINT_SCALE = 1e4;\n    constructor() { _disableInitializers(); }\n    function initialize(uint256 _minWithdrawAmount, uint256 _maxWithdrawAmount, uint16 _lowWatermarkInBpsOfTvl, uint16 _instantWithdrawalFeeInBps, address _roleRegistry, address _beHypeToken, address _stakingCore, uint256 _bucketCapacity, uint64 _bucketRefillRate) public initializer {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        minWithdrawalAmount = _minWithdrawAmount;\n        maxWithdrawalAmount = _maxWithdrawAmount;\n        lowWatermarkInBpsOfTvl = _lowWatermarkInBpsOfTvl;\n        instantWithdrawalFeeInBps = _instantWithdrawalFeeInBps;\n        roleRegistry = IRoleRegistry(_roleRegistry);\n        beHypeToken = IBeHYPEToken(_beHypeToken);\n        stakingCore = IStakingCore(_stakingCore);\n        instantWithdrawalLimit = BucketLimiter.create(_convertToBucketUnit(_bucketCapacity, Math.Rounding.Floor), _bucketRefillRate);\n        withdrawalQueue.push(WithdrawalEntry({user: address(0), beHypeAmount: 0, hypeAmount: 0, claimed: true}));\n    }\n    function withdraw(uint256 beHypeAmount, bool instant, uint256 minAmountOut) external nonReentrant returns (uint256 withdrawalId) {\n        if (paused()) revert WithdrawalsPaused();\n        if (beHypeAmount < minWithdrawalAmount) revert InvalidAmount();\n        if (beHypeAmount > maxWithdrawalAmount) revert InvalidAmount();\n        if (beHypeToken.balanceOf(msg.sender) < beHypeAmount) revert InsufficientBeHYPEBalance();\n        uint256 hypeAmount = stakingCore.BeHYPEToHYPE(beHypeAmount);\n        if (instant) {\n            if (!_canRateLimiterConsume(hypeAmount)) revert InstantWithdrawalRateLimitExceeded();\n            if (!canInstantWithdraw(beHypeAmount)) revert InsufficientHYPELiquidity();\n            uint256 instantWithdrawalFee = beHypeAmount.mulDiv(instantWithdrawalFeeInBps, BASIS_POINT_SCALE);\n            uint256 beHypeWithdrawalAfterFee = beHypeAmount - instantWithdrawalFee;\n            uint256 hypeWithdrawalAfterFee = stakingCore.BeHYPEToHYPE(beHypeWithdrawalAfterFee);\n            if (hypeWithdrawalAfterFee < minAmountOut) revert InsufficientMinimumAmountOut();\n            _updateRateLimit(hypeAmount);\n            beHypeToken.transferFrom(msg.sender, address(this), beHypeAmount);\n            beHypeToken.transfer(roleRegistry.protocolTreasury(), instantWithdrawalFee);\n            beHypeToken.burn(address(this), beHypeWithdrawalAfterFee);\n            stakingCore.sendFromWithdrawManager(hypeWithdrawalAfterFee, msg.sender);\n            emit InstantWithdrawal(msg.sender, beHypeAmount, hypeWithdrawalAfterFee, instantWithdrawalFee);\n        } else {\n            if (hypeAmount < minAmountOut) revert InsufficientMinimumAmountOut();\n            withdrawalId = withdrawalQueue.length;\n            hypeRequestedForWithdraw += hypeAmount;\n            withdrawalQueue.push(WithdrawalEntry({user: msg.sender, beHypeAmount: beHypeAmount, hypeAmount: hypeAmount, claimed: false}));\n            userWithdrawals[msg.sender].push(withdrawalId);\n            beHypeToken.transferFrom(msg.sender, address(this), beHypeAmount);\n            emit WithdrawalQueued(msg.sender, withdrawalId, beHypeAmount, hypeAmount, withdrawalId);\n        }\n    }\n    function claimWithdrawal(uint256 withdrawalId) external nonReentrant {\n        if (paused()) revert WithdrawalsPaused();\n        if (!canClaimWithdrawal(withdrawalId)) revert WithdrawalNotClaimable();\n        WithdrawalEntry storage entry = withdrawalQueue[withdrawalId];\n        if (entry.claimed) revert AlreadyClaimed();\n        entry.claimed = true;\n        (bool success, ) = payable(entry.user).call{value: entry.hypeAmount}("");\n        if (!success) revert TransferFailed();\n        emit WithdrawalClaimed(entry.user, withdrawalId, entry.hypeAmount);\n    }\n    function finalizeWithdrawals(uint256 index) external nonReentrant {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        if (index >= withdrawalQueue.length) revert IndexOutOfBounds();\n        if (index <= lastFinalizedIndex) revert CanOnlyFinalizeForward();\n        uint256 hypeAmountToFinalize = 0;\n        uint256 beHypeAmountToFinalize = 0;\n        for (uint256 i = lastFinalizedIndex + 1; i <= index;) {\n            beHypeAmountToFinalize += withdrawalQueue[i].beHypeAmount;\n            hypeAmountToFinalize += withdrawalQueue[i].hypeAmount;\n            unchecked { ++i; }\n        }\n        lastFinalizedIndex = index;\n        beHypeToken.burn(address(this), beHypeAmountToFinalize);\n        stakingCore.sendFromWithdrawManager(hypeAmountToFinalize, address(this));\n        hypeRequestedForWithdraw -= hypeAmountToFinalize;\n        emit WithdrawalsBatchFinalized(index);\n    }\n    function setInstantWithdrawalFeeInBps(uint16 _instantWithdrawalFeeInBps) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        if (_instantWithdrawalFeeInBps > BASIS_POINT_SCALE) revert InvalidInstantWithdrawalFee();\n        instantWithdrawalFeeInBps = _instantWithdrawalFeeInBps;\n        emit InstantWithdrawalFeeInBpsUpdated(_instantWithdrawalFeeInBps);\n    }\n    function setInstantWithdrawalCapacity(uint256 capacity) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint64 bucketUnit = _convertToBucketUnit(capacity, Math.Rounding.Floor);\n        BucketLimiter.setCapacity(instantWithdrawalLimit, bucketUnit);\n        emit InstantWithdrawalCapacityUpdated(capacity);\n    }\n    function setInstantWithdrawalRefillRatePerSecond(uint64 refillRate) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        BucketLimiter.setRefillRate(instantWithdrawalLimit, refillRate);\n        emit InstantWithdrawalRefillRateUpdated(refillRate);\n    }\n    function pauseWithdrawals() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _pause();\n    }\n    function unpauseWithdrawals() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _unpause();\n    }\n    function getWithdrawalQueue(uint256 index) external view returns (WithdrawalEntry memory) {\n        return withdrawalQueue[index];\n    }\n    function canClaimWithdrawal(uint256 withdrawalId) public view returns (bool) {\n        if (withdrawalId >= withdrawalQueue.length) return false;\n        if (withdrawalId > lastFinalizedIndex) return false;\n        WithdrawalEntry storage entry = withdrawalQueue[withdrawalId];\n        return !entry.claimed;\n    }\n    function getUserUnclaimedWithdrawals(address user) external view returns (uint256[] memory) {\n        uint256[] memory unclaimedWithdrawals = new uint256[](userWithdrawals[user].length);\n        uint256 count = 0;\n        for (uint256 i = 0; i < userWithdrawals[user].length;) {\n            WithdrawalEntry storage entry = withdrawalQueue[userWithdrawals[user][i]];\n            if (!entry.claimed) {\n                unclaimedWithdrawals[count] = userWithdrawals[user][i];\n                unchecked { ++count; }\n            }\n            unchecked { ++i; }\n        }\n        assembly { mstore(unclaimedWithdrawals, count) }\n        return unclaimedWithdrawals;\n    }\n    function getTotalInstantWithdrawableBeHYPE() public view returns (uint256) {\n        if (getLiquidHypeAmount() < lowWatermarkInHYPE()) return 0;\n        uint256 withdrawableAmount = getLiquidHypeAmount() - lowWatermarkInHYPE();\n        uint256 rateLimitAllowedAmount = _convertFromBucketUnit(BucketLimiter.consumable(instantWithdrawalLimit));\n        return stakingCore.HYPEToBeHYPE(Math.min(withdrawableAmount, rateLimitAllowedAmount));\n    }\n    function canInstantWithdraw(uint256 beHypeAmount) public view returns (bool) {\n        return beHypeAmount <= getTotalInstantWithdrawableBeHYPE();\n    }\n    function getLiquidHypeAmount() public view returns (uint256) {\n        return address(stakingCore).balance;\n    }\n    function getPendingWithdrawalsCount() external view returns (uint256) {\n        return withdrawalQueue.length - lastFinalizedIndex - 1;\n    }\n    function lowWatermarkInHYPE() public view returns (uint256) {\n        return stakingCore.getTotalProtocolHype().mulDiv(lowWatermarkInBpsOfTvl, BASIS_POINT_SCALE);\n    }\n    function _updateRateLimit(uint256 amount) internal {\n        uint64 bucketUnit = _convertToBucketUnit(amount, Math.Rounding.Ceil);\n        if (!BucketLimiter.consume(instantWithdrawalLimit, bucketUnit)) revert InstantWithdrawalRateLimitExceeded();\n    }\n    function _canRateLimiterConsume(uint256 amount) internal view returns (bool) {\n        return BucketLimiter.canConsume(instantWithdrawalLimit, _convertToBucketUnit(amount, Math.Rounding.Ceil));\n    }\n    function _convertToBucketUnit(uint256 amount, Math.Rounding rounding) internal pure returns (uint64) {\n        require(amount < type(uint64).max * BUCKET_UNIT_SCALE, "WithdrawManager: Amount too large");\n        return (rounding == Math.Rounding.Ceil) ? SafeCast.toUint64((amount + BUCKET_UNIT_SCALE - 1) / BUCKET_UNIT_SCALE) : SafeCast.toUint64(amount / BUCKET_UNIT_SCALE);\n    }\n    function _convertFromBucketUnit(uint64 bucketUnit) internal pure returns (uint256) {\n        return bucketUnit * BUCKET_UNIT_SCALE;\n    }\n    function _authorizeUpgrade(address /* newImplementation */) internal view override {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n    }\n    receive() external payable {}\n}",
      "relevance": "This file uses the inflated values from `StakingCore.getTotalProtocolHype()` and `address(stakingCore).balance` (which includes pending withdrawals before finalization) to calculate the instant withdrawable amount, leading to the vulnerability."
    }
  ],
  
  "call_flow": "User calls WithdrawManager.withdraw() (queues withdrawal) -> `hypeRequestedForWithdraw` increases -> Instant Withdrawal check uses `StakingCore.getTotalProtocolHype()` -> Value is inflated -> Instant withdrawal is granted beyond true liquidity.",
  "context_hint": "An accounting inconsistency between two contracts during the multi-step withdrawal process. The `StakingCore` reports the underlying asset total without acknowledging the liability represented by the pending withdrawals (`hypeRequestedForWithdraw`) stored in `WithdrawManager` that have not yet moved off the core contract balance.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The Medium severity is appropriate as this only leads to a temporary liquidity crunch, not permanent loss, and only when there are unfinalized withdrawals. The fix requires careful separation of liquidity available for instant withdrawal vs. total assets for exchange rate calculation."
}

{
  "id": "gs_pashov_hyperbeat_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Hyperbeat Security Review",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Hyperbeat-security-review_2025-09-03.pdf",
  "github_repo_url": "https://github.com/etherfi-protocol/beHYPE/tree/c620e61aaf8fe5767e713bb9d7447bd9fbc40148/src",
  "contest_date": "2025-09-03",
  
  "severity": "medium",
  "vulnerability_type": "exchange_rate_corruption",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  
  "finding_title": "Idle HYPE balance consideration allows silent bypass of exchange rate guard",
  "finding_description": "The `updateExchangeRatio()` function uses an APR guard to prevent the exchange rate from being corrupted by bad data reads from external HyperCore precompiles. The guard checks the calculated new ratio against the expected APR, but the new ratio calculation (via `getTotalProtocolHype()`) includes all assets, specifically the 'idle HYPE balance' present directly on the `StakingCore` contract's address (`address(this).balance`). If a bad precompile read occurs, the presence of sufficient idle liquidity in the `StakingCore` contract can artificially inflate the calculated total HYPE, making the ratio appear higher than it should be, thus allowing the corrupted ratio to silently bypass the APR guard and be accepted, corrupting the protocol's exchange rate.",
  "attack_scenario": "1. A bad read from the HyperCore precompile occurs, causing the reported delegated/undelegated balances to be much lower than reality, which should trigger the APR guard.\n2. The `StakingCore` contract holds a large, idle native HYPE balance (`address(this).balance`).\n3. This idle balance artificially boosts the `total` HYPE calculated by `getTotalProtocolHype()`, which is used to derive the new exchange ratio.\n4. The inflated total HYPE value compensates for the bad read, causing the resulting exchange ratio to still fall within the acceptable APR guard limits.\n5. The corrupted exchange rate is accepted by the protocol, causing an incorrect accounting of user shares and potentially affecting the `WithdrawManager::lowWatermarkInHYPE()` calculation.",
  "fix_description": "It is recommended to guard the `delegatorSummary` and `spotBalance` values (the results of the external HyperCore precompile calls) individually before aggregating them, rather than relying on a guard that uses the aggregated total which includes the local contract's balance.",
  
  "primary_file": {
    "path": "StakingCore.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport {Math} from "@openzeppelin/contracts/utils/math/Math.sol";\nimport {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";\nimport {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\nimport {IRoleRegistry} from "./interfaces/IRoleRegistry.sol";\nimport {IBeHYPEToken} from "./interfaces/IBeHYPE.sol";\nimport {IStakingCore} from "./interfaces/IStakingCore.sol";\nimport {IWithdrawManager} from "./interfaces/IWithdrawManager.sol";\nimport {L1Read} from "./lib/L1Read.sol";\nimport {CoreWriter} from "./lib/CoreWriter.sol";\n\ncontract StakingCore is IStakingCore, Initializable, UUPSUpgradeable, PausableUpgradeable {\n\n    IRoleRegistry public roleRegistry;\n    IBeHYPEToken public beHypeToken;\n    address public withdrawManager;\n    uint256 public exchangeRatio;\n    uint16 public acceptablAprInBps;\n    bool public exchangeRateGuard;\n    uint256 public lastExchangeRatioUpdate;\n    uint256 public withdrawalCooldownPeriod;\n    uint256 public lastWithdrawalTimestamp;\n    uint256 public lastHyperCoreOperationBlock;\n\n    uint64 public constant HYPE_TOKEN_ID = 150;\n    address public constant L1_HYPE_CONTRACT = 0x2222222222222222222222222222222222222222;\n    L1Read public constant l1Read = L1Read(0xb7467E0524Afba7006957701d1F06A59000d15A2);\n    CoreWriter public constant coreWriter = CoreWriter(0x3333333333333333333333333333333333333333);\n    uint256 public constant MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE = 5;\n\n    constructor() { _disableInitializers(); }\n    \n    function initialize(address _roleRegistry, address _beHype, address _withdrawManager, uint16 _acceptablAprInBps, bool _exchangeRateGuard, uint256 _withdrawalCooldownPeriod) public initializer {\n        __UUPSUpgradeable_init();\n        roleRegistry = IRoleRegistry(_roleRegistry);\n        beHypeToken = IBeHYPEToken(_beHype);\n        acceptablAprInBps = _acceptablAprInBps;\n        exchangeRateGuard = _exchangeRateGuard;\n        withdrawManager = _withdrawManager;\n        exchangeRatio = 1 ether;\n        lastExchangeRatioUpdate = block.timestamp;\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        lastWithdrawalTimestamp = block.timestamp;\n        lastHyperCoreOperationBlock = block.number;\n    }\n\n    function stake(string memory communityCode) public payable {\n       if (paused()) revert StakingPaused();\n       beHypeToken.mint(msg.sender, HYPEToBeHYPE(msg.value));\n       emit Deposit(msg.sender, msg.value, communityCode); \n    }\n\n    function updateExchangeRatio() external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 blocksPassed = block.number - lastHyperCoreOperationBlock;\n        if (blocksPassed < MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE) {\n            revert ExchangeRatioUpdateTooSoon(MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE, blocksPassed);\n        }\n        uint256 totalProtocolHype = getTotalProtocolHype();\n        uint256 newRatio = Math.mulDiv(totalProtocolHype, 1e18, beHypeToken.totalSupply());\n        uint256 ratioChange;\n        if (newRatio > exchangeRatio) {\n            ratioChange = newRatio - exchangeRatio;\n        } else {\n            ratioChange = exchangeRatio - newRatio;\n        }\n        uint256 elapsedTime = block.timestamp - lastExchangeRatioUpdate;\n        if (elapsedTime == 0) revert ElapsedTimeCannotBeZero();\n        uint256 percentageChange = Math.mulDiv(ratioChange, 1e18, exchangeRatio);\n        uint256 yearlyRate = Math.mulDiv(percentageChange, 365 days, elapsedTime);\n        uint256 yearlyRateInBps = yearlyRate / 1e14;\n        uint16 yearlyRateInBps16 = uint16(Math.min(yearlyRateInBps, type(uint16).max));\n        if (exchangeRateGuard) {\n            if (yearlyRateInBps16 > acceptablAprInBps) revert ExchangeRatioChangeExceedsThreshold(yearlyRateInBps16);\n        }\n        uint256 oldRatio = exchangeRatio;\n        exchangeRatio = newRatio;\n        lastExchangeRatioUpdate = block.timestamp;\n        emit ExchangeRatioUpdated(oldRatio, exchangeRatio, yearlyRateInBps16);\n    }\n\n    function sendFromWithdrawManager(uint256 amount, address to) external {\n        if (msg.sender != withdrawManager) revert NotAuthorized();\n        (bool success,) = payable(to).call{value: amount}("");\n        if (!success) revert FailedToSendFromWithdrawManager();\n    }\n\n    function setWithdrawManager(address _withdrawManager) external {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n        withdrawManager = _withdrawManager;\n        emit WithdrawManagerUpdated(withdrawManager);\n    }\n\n    function updateAcceptableApr(uint16 _acceptablAprInBps) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        acceptablAprInBps = _acceptablAprInBps;\n        emit AcceptableAprUpdated(_acceptablAprInBps);\n    }\n\n    function updateExchangeRateGuard(bool _exchangeRateGuard) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        exchangeRateGuard = _exchangeRateGuard;\n        emit ExchangeRateGuardUpdated(_exchangeRateGuard);\n    }\n\n    function updateWithdrawalCooldownPeriod(uint256 _withdrawalCooldownPeriod) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        emit WithdrawalCooldownPeriodUpdated(withdrawalCooldownPeriod);\n    }\n\n    function depositToHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 truncatedAmount = amount / 1e10 * 1e10;\n        if (amount != truncatedAmount) {\n            revert PrecisionLossDetected(amount, truncatedAmount);\n        }\n        (bool success,) = payable(L1_HYPE_CONTRACT).call{value: amount}("");\n        if (!success) revert FailedToDepositToHyperCore();\n        lastHyperCoreOperationBlock = block.number;\n        emit HyperCoreDeposit(amount);\n    }\n\n    function withdrawFromHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(6, abi.encode(L1_HYPE_CONTRACT, HYPE_TOKEN_ID, _convertTo8Decimals(amount)));\n        emit HyperCoreWithdraw(amount);\n    }\n\n    function depositToStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(4, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingDeposit(amount);\n    }\n\n    function withdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        if (amount > IWithdrawManager(withdrawManager).hypeRequestedForWithdraw()) revert ExceedsLimit();\n        if (block.timestamp < lastWithdrawalTimestamp + withdrawalCooldownPeriod) {\n            revert WithdrawalCooldownNotMet();\n        }\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        lastWithdrawalTimestamp = block.timestamp;\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function emergencyWithdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function delegateTokens(address validator, uint256 amount, bool isUndelegate) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(3, abi.encode(validator, _convertTo8Decimals(amount), isUndelegate));\n        emit TokenDelegated(validator, amount, isUndelegate);\n    }\n\n    function pauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _pause();\n    }\n\n    function unpauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _unpause();\n    }\n\n    function BeHYPEToHYPE(uint256 beHYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(beHYPEAmount, exchangeRatio, 1e18);\n    }\n    \n    function HYPEToBeHYPE(uint256 HYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(HYPEAmount, 1e18, exchangeRatio);\n    }\n\n    function getTotalProtocolHype() public view returns (uint256) {\n        L1Read.DelegatorSummary memory delegatorSummary = l1Read.delegatorSummary(address(this));\n        uint256 totalHypeInStakingAccount = _convertTo18Decimals(delegatorSummary.delegated) + _convertTo18Decimals(delegatorSummary.undelegated) + _convertTo18Decimals(delegatorSummary.totalPendingWithdrawal);\n        L1Read.SpotBalance memory spotBalance = l1Read.spotBalance(address(this), HYPE_TOKEN_ID);\n        uint256 totalHypeInSpotAccount = _convertTo18Decimals(spotBalance.total);\n        uint256 totalHypeInLiquidityPool = address(this).balance;\n        uint256 total = totalHypeInStakingAccount + totalHypeInSpotAccount + totalHypeInLiquidityPool;\n        return total;\n    }\n\n    function _convertTo8Decimals(uint256 amount) internal pure returns (uint64) {\n        uint256 truncatedAmount = amount / 1e10;\n        if (truncatedAmount > type(uint64).max) revert AmountExceedsUint64Max();\n        return uint64(truncatedAmount);\n    }\n\n    function _convertTo18Decimals(uint64 amount) internal pure returns (uint256) {\n        return uint256(amount) * 1e10;\n    }\n\n    function _encodeAction(uint8 actionId, bytes memory actionData) internal {\n        lastHyperCoreOperationBlock = block.number;\n        bytes memory data = new bytes(4 + actionData.length);\n        data[0] = 0x01;\n        data[1] = 0x00;\n        data[2] = 0x00;\n        data[3] = bytes1(actionId);\n        for (uint256 i = 0; i < actionData.length; i++) {\n            data[4 + i] = actionData[i];\n        }\n        coreWriter.sendRawAction(data);\n    }\n\n    function _authorizeUpgrade(address /* newImplementation */) internal view override {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n    }\n\n    receive() external payable {}\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["getTotalProtocolHype", "updateExchangeRatio"]
  },
  
  "context_files": [],
  
  "call_flow": "External Precompile returns corrupted data (low balances) -> `getTotalProtocolHype` calculates `total` -> High `address(this).balance` masks the corruption -> Calculated exchange ratio bypasses APR guard -> Corrupted ratio is written to state.",
  "context_hint": "The aggregation logic for the exchange rate calculation incorrectly combines externally sourced volatile data with locally held non-volatile data. This allows the local balance to act as a buffer, preventing a necessary safety check (APR guard) from detecting corrupted external data, leading to state corruption.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The guard is rendered ineffective by the inclusion of the StakingCore contract's own balance. The fix shifts the guarding logic from the aggregated total to the individual external reads, which is the correct security boundary."
}

{
  "id": "gs_honeyjar_interpol_C01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[C-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "critical",
  "vulnerability_type": "access_control_bypass",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "Adversary can lock tokens forever for any HoneyLocker",
  "finding_description": "The `depositAndLock()` function is protected by the `onlyOwnerOrMigratingVault` modifier, which contains a vulnerable check: `owner() != Ownable(msg.sender).owner()`. An adversary can deploy a malicious contract that implements an `owner()` function designed to return the current owner's address of the `HoneyLocker` contract. Since the malicious contract's owner is the attacker, the check passes (`owner()` of `HoneyLocker` equals `owner()` of the malicious contract, which is not equal to the malicious contract's owner, which is also checked), allowing the attacker to bypass access control.",
  "attack_scenario": "1. Attacker deploys `ExpirationAttacker` contract, which has an `owner()` function returning the legitimate `HoneyLocker`'s owner address.\n2. Attacker calls `HoneyLocker.depositAndLock()` via the malicious contract.\n3. The `onlyOwnerOrMigratingVault` check is bypassed.\n4. The attacker sets the `_expiration` to the maximum possible value (`type(uint256).max`), locking the LP tokens in the `HoneyLocker` permanently.\n5. The legitimate owner is unable to withdraw their tokens as they will never expire.",
  "fix_description": "Replace the vulnerable check logic in `onlyOwnerOrMigratingVault` with a more explicit access control mechanism, such as allowing only the contract's explicit owner or a specifically whitelisted Migration Vault address to call the function, removing the reliance on external contract's `owner()` implementation.",
  
  "primary_file": {
    "path": "HoneyLocker.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {ERC721} from "solady/tokens/ERC721.sol";\nimport {ERC1155} from "solady/tokens/ERC1155.sol";\nimport {SafeTransferLib as STL} from "solady/utils/SafeTransferLib.sol";\nimport {HoneyQueen} from "./HoneyQueen.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {TokenReceiver} from "./utils/TokenReceiver.sol";\ncontract HoneyLocker is TokenReceiver, Ownable {\n    error MigrationNotEnabled();\n    error ExpirationNotMatching();\n    error TargetContractNotAllowed();\n    error NotExpiredYet();\n    error TokenBlocked();\n    error CannotBeLPToken();\n    error HasToBeLPToken();\n    error StakeFailed();\n    error UnstakeFailed();\n    error SelectorNotAllowed();\n    error ClaimRewardsFailed();\n    error WildcardFailed();\n    event Initialized(address indexed owner);\n    event Deposited(address indexed token, uint256 amount);\n    event LockedUntil(address indexed token, uint256 expiration);\n    event Staked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Unstaked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Withdrawn(address indexed token, uint256 amount);\n    event Migrated(address indexed token, address indexed oldLocker, address indexed newLocker);\n    event RewardsClaimed(address stakingContract);\n    mapping(address => mapping(address => uint256)) public staked;\n    mapping(address => uint256) public expirations;\n    address public referral;\n    bool public unlocked;\n    HoneyQueen internal HONEY_QUEEN;\n    modifier onlyOwnerOrMigratingVault() {\n        if (msg.sender != owner() && owner() != Ownable(msg.sender).owner()) revert Unauthorized();\n        _;\n    }\n    modifier onlyOwnerOrAutomaton() {\n        if (msg.sender != owner() && msg.sender != HONEY_QUEEN.automaton()) revert Unauthorized();\n        _;\n    }\n    modifier onlyUnblockedTokens(address _token) {\n        if (!unlocked && HONEY_QUEEN.isTokenBlocked(_token)) revert TokenBlocked();\n        _;\n    }\n    modifier onlyAllowedSelector(address _stakingContract, string memory action, bytes memory _data) {\n        bytes4 selector;\n        assembly { selector := mload(add(_data, 32)) }\n        if (!HONEY_QUEEN.isSelectorAllowedForTarget(selector, action, _stakingContract)) revert SelectorNotAllowed();\n        _;\n    }\n    modifier onlyAllowedTargetContract(address _targetContract) {\n        if (!HONEY_QUEEN.isTargetContractAllowed(_targetContract)) revert TargetContractNotAllowed();\n        _;\n    }\n    function initialize(address _owner, address _honeyQueen, address _referral, bool _unlocked) external {\n        require(address(HONEY_QUEEN) == address(0));\n        _initializeOwner(_owner);\n        HONEY_QUEEN = HoneyQueen(_honeyQueen);\n        referral = _referral;\n        unlocked = _unlocked;\n        emit Initialized(_owner);\n    }\n    function wildcard(address _contract, bytes calldata _data) external onlyOwner onlyAllowedTargetContract(_contract) onlyAllowedSelector(_contract, "wildcard", _data) {\n        (bool success,) = _contract.call(_data);\n        if (!success) revert WildcardFailed();\n    }\n    function stake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) external onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "stake", _data) {\n        staked[_LPToken][_stakingContract] += _amount;\n        ERC20(_LPToken).approve(address(_stakingContract), _amount);\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert StakeFailed();\n        emit Staked(_stakingContract, _LPToken, _amount);\n    }\n    function unstake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) public onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "unstake", _data) {\n        staked[_LPToken][_stakingContract] -= _amount;\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert UnstakeFailed();\n        emit Unstaked(_stakingContract, _LPToken, _amount);\n    }\n    function burnBGTForBERA(uint256 _amount) external onlyOwner {\n        HONEY_QUEEN.BGT().redeem(address(this), _amount);\n        withdrawBERA(_amount);\n    }\n    function withdrawLPToken(address _LPToken, uint256 _amount) external onlyOwner {\n        if (expirations[_LPToken] == 0) revert HasToBeLPToken();\n        if (block.timestamp < expirations[_LPToken]) revert NotExpiredYet();\n        ERC20(_LPToken).transfer(msg.sender, _amount);\n        emit Withdrawn(_LPToken, _amount);\n    }\n    function migrate(address[] calldata _LPTokens, uint256[] calldata _amountsOrIds, address payable _newHoneyLocker) external onlyOwner {\n        if (!HONEY_QUEEN.isMigrationEnabled(address(this).codehash, _newHoneyLocker.codehash)) revert MigrationNotEnabled();\n        for (uint256 i; i < _LPTokens.length; i++) {\n            ERC20(_LPTokens[i]).approve(address(_newHoneyLocker), _amountsOrIds[i]);\n            HoneyLocker(_newHoneyLocker).depositAndLock(_LPTokens[i], _amountsOrIds[i], expirations[_LPTokens[i]]);\n            emit Migrated(_LPTokens[i], address(this), _newHoneyLocker);\n        }\n    }\n    function claimRewards(address _stakingContract, bytes memory _data) external onlyOwnerOrAutomaton onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "rewards", _data) {\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert ClaimRewardsFailed();\n        emit RewardsClaimed(_stakingContract);\n    }\n    function depositAndLock(address _LPToken, uint256 _amountOrId, uint256 _expiration) external onlyOwnerOrMigratingVault {\n        if (!unlocked && expirations[_LPToken] != 0 && _expiration < expirations[_LPToken]) revert ExpirationNotMatching();\n        expirations[_LPToken] = unlocked ? 1 : _expiration;\n        ERC721(_LPToken).transferFrom(msg.sender, address(this), _amountOrId);\n        emit Deposited(_LPToken, _amountOrId);\n        emit LockedUntil(_LPToken, _expiration);\n    }\n    function delegateBGT(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().queueBoost(_validator, _amount);\n    }\n    function activateBoost(address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().activateBoost(_validator);\n    }\n    function cancelQueuedBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().cancelBoost(_validator, _amount);\n    }\n    function dropBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().dropBoost(_validator, _amount);\n    }\n    function withdrawBERA(uint256 _amount) public onlyOwner {\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        STL.safeTransferETH(msg.sender, _amount - fees);\n        HONEY_QUEEN.beekeeper().distributeFees{value: fees}(referral, address(0), fees);\n        emit Withdrawn(address(0), _amount - fees);\n    }\n    function withdrawERC20(address _token, uint256 _amount) external onlyUnblockedTokens(_token) onlyOwner {\n        if (expirations[_token] != 0) revert CannotBeLPToken();\n        Beekeeper beekeeper = HONEY_QUEEN.beekeeper();\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        ERC20(_token).transfer(msg.sender, _amount - fees);\n        ERC20(_token).transfer(address(beekeeper), fees);\n        beekeeper.distributeFees(referral, _token, fees);\n        emit Withdrawn(_token, _amount - fees);\n    }\n    function withdrawERC721(address _token, uint256 _id) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC721(_token).transferFrom(address(this), msg.sender, _id);\n    }\n    function withdrawERC1155(address _token, uint256 _id, uint256 _amount, bytes calldata _data) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC1155(_token).safeTransferFrom(address(this), msg.sender, _id, _amount, _data);\n    }\n    receive() external payable {}\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["onlyOwnerOrMigratingVault", "depositAndLock"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker calls `MaliciousContract.depositAndLock()` -> `HoneyLocker.onlyOwnerOrMigratingVault` check is bypassed by `MaliciousContract.owner()` returning the `HoneyLocker` owner -> `depositAndLock` executes -> Attacker sets `expirations` to max value, locking tokens.",
  "context_hint": "A critical access control bypass enabled by utilizing the EVM's ability to call an external contract's `owner()` function. The logic incorrectly trusts the result of this external call for authorization, allowing an attacker to spoof the migration vault check and cause permanent Denial of Withdrawal.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A classic pattern for breaking ownership/migration checks in Solidity. High impact because it leads to permanent denial of withdrawal for legitimate owners."
}

{
  "id": "gs_honeyjar_interpol_H01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[H-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "high",
  "vulnerability_type": "access_control_bypass",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "Blocked ERC20 tokens can still be withdrawn",
  "finding_description": "The contract intends to block withdrawal of certain ERC20 tokens via the `withdrawERC20()` function using the `onlyUnblockedTokens` modifier, which checks `HONEY_QUEEN.isTokenBlocked(_token)`. However, an owner can bypass this check and withdraw blocked ERC20 tokens using the `withdrawLPToken()` function. This is possible because `withdrawLPToken()` is only protected by a check that `expirations[_LPToken] == 0`, an expectation that can be broken by calling `depositAndLock()` with the blocked ERC20 token, a zero amount, and a past expiration, thus setting a non-zero `expirations` value for the blocked token.",
  "attack_scenario": "1. The owner calls `depositAndLock()` with a blocked ERC20 token (Token X), an amount of 0, and a past expiration time. This sets `expirations[TokenX]` to a non-zero value.\n2. The owner can now call `withdrawLPToken(TokenX, amount)`, and the check `expirations[_LPToken] == 0` fails to prevent the withdrawal because the value is now non-zero.\n3. The function `ERC20(_LPToken).transfer(msg.sender, _amount)` executes, transferring the blocked token out of the contract, bypassing the intended security measure.",
  "fix_description": "Implement the `onlyUnblockedTokens` modifier in the `withdrawLPToken()` function, or alternatively, add a robust whitelist/blacklist check in `depositAndLock()` to prevent non-LP tokens or blocked tokens from being assigned an expiration value that enables this bypass.",
  
  "primary_file": {
    "path": "HoneyLocker.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {ERC721} from "solady/tokens/ERC721.sol";\nimport {ERC1155} from "solady/tokens/ERC1155.sol";\nimport {SafeTransferLib as STL} from "solady/utils/SafeTransferLib.sol";\nimport {HoneyQueen} from "./HoneyQueen.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {TokenReceiver} from "./utils/TokenReceiver.sol";\ncontract HoneyLocker is TokenReceiver, Ownable {\n    error MigrationNotEnabled();\n    error ExpirationNotMatching();\n    error TargetContractNotAllowed();\n    error NotExpiredYet();\n    error TokenBlocked();\n    error CannotBeLPToken();\n    error HasToBeLPToken();\n    error StakeFailed();\n    error UnstakeFailed();\n    error SelectorNotAllowed();\n    error ClaimRewardsFailed();\n    error WildcardFailed();\n    event Initialized(address indexed owner);\n    event Deposited(address indexed token, uint256 amount);\n    event LockedUntil(address indexed token, uint256 expiration);\n    event Staked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Unstaked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Withdrawn(address indexed token, uint256 amount);\n    event Migrated(address indexed token, address indexed oldLocker, address indexed newLocker);\n    event RewardsClaimed(address stakingContract);\n    mapping(address => mapping(address => uint256)) public staked;\n    mapping(address => uint256) public expirations;\n    address public referral;\n    bool public unlocked;\n    HoneyQueen internal HONEY_QUEEN;\n    modifier onlyOwnerOrMigratingVault() {\n        if (msg.sender != owner() && owner() != Ownable(msg.sender).owner()) revert Unauthorized();\n        _;\n    }\n    modifier onlyOwnerOrAutomaton() {\n        if (msg.sender != owner() && msg.sender != HONEY_QUEEN.automaton()) revert Unauthorized();\n        _;\n    }\n    modifier onlyUnblockedTokens(address _token) {\n        if (!unlocked && HONEY_QUEEN.isTokenBlocked(_token)) revert TokenBlocked();\n        _;\n    }\n    modifier onlyAllowedSelector(address _stakingContract, string memory action, bytes memory _data) {\n        bytes4 selector;\n        assembly { selector := mload(add(_data, 32)) }\n        if (!HONEY_QUEEN.isSelectorAllowedForTarget(selector, action, _stakingContract)) revert SelectorNotAllowed();\n        _;\n    }\n    modifier onlyAllowedTargetContract(address _targetContract) {\n        if (!HONEY_QUEEN.isTargetContractAllowed(_targetContract)) revert TargetContractNotAllowed();\n        _;\n    }\n    function initialize(address _owner, address _honeyQueen, address _referral, bool _unlocked) external {\n        require(address(HONEY_QUEEN) == address(0));\n        _initializeOwner(_owner);\n        HONEY_QUEEN = HoneyQueen(_honeyQueen);\n        referral = _referral;\n        unlocked = _unlocked;\n        emit Initialized(_owner);\n    }\n    function wildcard(address _contract, bytes calldata _data) external onlyOwner onlyAllowedTargetContract(_contract) onlyAllowedSelector(_contract, "wildcard", _data) {\n        (bool success,) = _contract.call(_data);\n        if (!success) revert WildcardFailed();\n    }\n    function stake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) external onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "stake", _data) {\n        staked[_LPToken][_stakingContract] += _amount;\n        ERC20(_LPToken).approve(address(_stakingContract), _amount);\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert StakeFailed();\n        emit Staked(_stakingContract, _LPToken, _amount);\n    }\n    function unstake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) public onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "unstake", _data) {\n        staked[_LPToken][_stakingContract] -= _amount;\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert UnstakeFailed();\n        emit Unstaked(_stakingContract, _LPToken, _amount);\n    }\n    function burnBGTForBERA(uint256 _amount) external onlyOwner {\n        HONEY_QUEEN.BGT().redeem(address(this), _amount);\n        withdrawBERA(_amount);\n    }\n    function withdrawLPToken(address _LPToken, uint256 _amount) external onlyOwner {\n        if (expirations[_LPToken] == 0) revert HasToBeLPToken();\n        if (block.timestamp < expirations[_LPToken]) revert NotExpiredYet();\n        ERC20(_LPToken).transfer(msg.sender, _amount);\n        emit Withdrawn(_LPToken, _amount);\n    }\n    function migrate(address[] calldata _LPTokens, uint256[] calldata _amountsOrIds, address payable _newHoneyLocker) external onlyOwner {\n        if (!HONEY_QUEEN.isMigrationEnabled(address(this).codehash, _newHoneyLocker.codehash)) revert MigrationNotEnabled();\n        for (uint256 i; i < _LPTokens.length; i++) {\n            ERC20(_LPTokens[i]).approve(address(_newHoneyLocker), _amountsOrIds[i]);\n            HoneyLocker(_newHoneyLocker).depositAndLock(_LPTokens[i], _amountsOrIds[i], expirations[_LPTokens[i]]);\n            emit Migrated(_LPTokens[i], address(this), _newHoneyLocker);\n        }\n    }\n    function claimRewards(address _stakingContract, bytes memory _data) external onlyOwnerOrAutomaton onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "rewards", _data) {\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert ClaimRewardsFailed();\n        emit RewardsClaimed(_stakingContract);\n    }\n    function depositAndLock(address _LPToken, uint256 _amountOrId, uint256 _expiration) external onlyOwnerOrMigratingVault {\n        if (!unlocked && expirations[_LPToken] != 0 && _expiration < expirations[_LPToken]) revert ExpirationNotMatching();\n        expirations[_LPToken] = unlocked ? 1 : _expiration;\n        ERC721(_LPToken).transferFrom(msg.sender, address(this), _amountOrId);\n        emit Deposited(_LPToken, _amountOrId);\n        emit LockedUntil(_LPToken, _expiration);\n    }\n    function delegateBGT(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().queueBoost(_validator, _amount);\n    }\n    function activateBoost(address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().activateBoost(_validator);\n    }\n    function cancelQueuedBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().cancelBoost(_validator, _amount);\n    }\n    function dropBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().dropBoost(_validator, _amount);\n    }\n    function withdrawBERA(uint256 _amount) public onlyOwner {\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        STL.safeTransferETH(msg.sender, _amount - fees);\n        HONEY_QUEEN.beekeeper().distributeFees{value: fees}(referral, address(0), fees);\n        emit Withdrawn(address(0), _amount - fees);\n    }\n    function withdrawERC20(address _token, uint256 _amount) external onlyUnblockedTokens(_token) onlyOwner {\n        if (expirations[_token] != 0) revert CannotBeLPToken();\n        Beekeeper beekeeper = HONEY_QUEEN.beekeeper();\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        ERC20(_token).transfer(msg.sender, _amount - fees);\n        ERC20(_token).transfer(address(beekeeper), fees);\n        beekeeper.distributeFees(referral, _token, fees);\n        emit Withdrawn(_token, _amount - fees);\n    }\n    function withdrawERC721(address _token, uint256 _id) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC721(_token).transferFrom(address(this), msg.sender, _id);\n    }\n    function withdrawERC1155(address _token, uint256 _id, uint256 _amount, bytes calldata _data) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC1155(_token).safeTransferFrom(address(this), msg.sender, _id, _amount, _data);\n    }\n    receive() external payable {}\n}",
    "vulnerable_lines": [16, 27],
    "vulnerable_functions": ["withdrawLPToken", "depositAndLock"]
  },
  
  "context_files": [],
  
  "call_flow": "Owner.depositAndLock(BlockedTokenX, 0, pastTime) -> `expirations[BlockedTokenX]` is set to non-zero -> Owner.withdrawLPToken(BlockedTokenX, amount) -> `expirations[BlockedTokenX] == 0` check fails to revert -> Blocked token is withdrawn.",
  "context_hint": "A dual-functionality design flaw: a function intended for LP token withdrawal (`withdrawLPToken`) is insufficiently protected and can be used to withdraw any ERC20 token if a specific state variable (`expirations`) is manipulated via another function (`depositAndLock`).",
  
  "is_vulnerable": true,
  
  "expert_notes": "High severity due to the bypass of a core security mechanism (token blocking/whitelisting), allowing the protocol owner to drain assets they were explicitly supposed to hold."
}

{
  "id": "gs_honeyjar_interpol_H02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[H-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "high",
  "vulnerability_type": "fee_bypass_asset_loss",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "BGT and reward tokens can be withdrawn without paying fees",
  "finding_description": "Similar to [H-01], the `withdrawLPToken()` function can be exploited by the owner to withdraw non-LP tokens, specifically BGT and other reward tokens that are expected to be subject to withdrawal fees (which are enforced in `withdrawBERA()` and `withdrawERC20()`). By manipulating `expirations[_LPToken]` to be non-zero, the owner can use `withdrawLPToken()` to transfer these fee-bearing assets out without the necessary fee calculation and deduction, bypassing protocol revenue mechanisms.",
  "attack_scenario": "1. The protocol receives BGT or other reward tokens that are supposed to be subject to a withdrawal fee (e.g., 2%).\n2. The owner calls `depositAndLock()` with the BGT token, 0 amount, and a past expiration to set `expirations[BGT]` to a non-zero value.\n3. The owner calls `withdrawLPToken(BGT, amount)`.\n4. The BGT token is transferred out using `withdrawLPToken`'s internal transfer logic, which lacks any fee calculation, allowing the owner to withdraw the full amount and steal the protocol's fee revenue.",
  "fix_description": "Ensure that `withdrawLPToken()` is strictly limited to actual LP tokens. This requires either: 1) Adding a whitelist/blacklist to `depositAndLock()` to ensure only LP tokens can set an expiration, or 2) Adding explicit checks in `withdrawLPToken()` to prevent critical non-LP tokens (like BGT and other rewards) from being withdrawn through this path.",
  
  "primary_file": {
    "path": "HoneyLocker.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {ERC721} from "solady/tokens/ERC721.sol";\nimport {ERC1155} from "solady/tokens/ERC1155.sol";\nimport {SafeTransferLib as STL} from "solady/utils/SafeTransferLib.sol";\nimport {HoneyQueen} from "./HoneyQueen.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {TokenReceiver} from "./utils/TokenReceiver.sol";\ncontract HoneyLocker is TokenReceiver, Ownable {\n    error MigrationNotEnabled();\n    error ExpirationNotMatching();\n    error TargetContractNotAllowed();\n    error NotExpiredYet();\n    error TokenBlocked();\n    error CannotBeLPToken();\n    error HasToBeLPToken();\n    error StakeFailed();\n    error UnstakeFailed();\n    error SelectorNotAllowed();\n    error ClaimRewardsFailed();\n    error WildcardFailed();\n    event Initialized(address indexed owner);\n    event Deposited(address indexed token, uint256 amount);\n    event LockedUntil(address indexed token, uint256 expiration);\n    event Staked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Unstaked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Withdrawn(address indexed token, uint256 amount);\n    event Migrated(address indexed token, address indexed oldLocker, address indexed newLocker);\n    event RewardsClaimed(address stakingContract);\n    mapping(address => mapping(address => uint256)) public staked;\n    mapping(address => uint256) public expirations;\n    address public referral;\n    bool public unlocked;\n    HoneyQueen internal HONEY_QUEEN;\n    modifier onlyOwnerOrMigratingVault() {\n        if (msg.sender != owner() && owner() != Ownable(msg.sender).owner()) revert Unauthorized();\n        _;\n    }\n    modifier onlyOwnerOrAutomaton() {\n        if (msg.sender != owner() && msg.sender != HONEY_QUEEN.automaton()) revert Unauthorized();\n        _;\n    }\n    modifier onlyUnblockedTokens(address _token) {\n        if (!unlocked && HONEY_QUEEN.isTokenBlocked(_token)) revert TokenBlocked();\n        _;\n    }\n    modifier onlyAllowedSelector(address _stakingContract, string memory action, bytes memory _data) {\n        bytes4 selector;\n        assembly { selector := mload(add(_data, 32)) }\n        if (!HONEY_QUEEN.isSelectorAllowedForTarget(selector, action, _stakingContract)) revert SelectorNotAllowed();\n        _;\n    }\n    modifier onlyAllowedTargetContract(address _targetContract) {\n        if (!HONEY_QUEEN.isTargetContractAllowed(_targetContract)) revert TargetContractNotAllowed();\n        _;\n    }\n    function initialize(address _owner, address _honeyQueen, address _referral, bool _unlocked) external {\n        require(address(HONEY_QUEEN) == address(0));\n        _initializeOwner(_owner);\n        HONEY_QUEEN = HoneyQueen(_honeyQueen);\n        referral = _referral;\n        unlocked = _unlocked;\n        emit Initialized(_owner);\n    }\n    function wildcard(address _contract, bytes calldata _data) external onlyOwner onlyAllowedTargetContract(_contract) onlyAllowedSelector(_contract, "wildcard", _data) {\n        (bool success,) = _contract.call(_data);\n        if (!success) revert WildcardFailed();\n    }\n    function stake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) external onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "stake", _data) {\n        staked[_LPToken][_stakingContract] += _amount;\n        ERC20(_LPToken).approve(address(_stakingContract), _amount);\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert StakeFailed();\n        emit Staked(_stakingContract, _LPToken, _amount);\n    }\n    function unstake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) public onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "unstake", _data) {\n        staked[_LPToken][_stakingContract] -= _amount;\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert UnstakeFailed();\n        emit Unstaked(_stakingContract, _LPToken, _amount);\n    }\n    function burnBGTForBERA(uint256 _amount) external onlyOwner {\n        HONEY_QUEEN.BGT().redeem(address(this), _amount);\n        withdrawBERA(_amount);\n    }\n    function withdrawLPToken(address _LPToken, uint256 _amount) external onlyOwner {\n        if (expirations[_LPToken] == 0) revert HasToBeLPToken();\n        if (block.timestamp < expirations[_LPToken]) revert NotExpiredYet();\n        ERC20(_LPToken).transfer(msg.sender, _amount);\n        emit Withdrawn(_LPToken, _amount);\n    }\n    function migrate(address[] calldata _LPTokens, uint256[] calldata _amountsOrIds, address payable _newHoneyLocker) external onlyOwner {\n        if (!HONEY_QUEEN.isMigrationEnabled(address(this).codehash, _newHoneyLocker.codehash)) revert MigrationNotEnabled();\n        for (uint256 i; i < _LPTokens.length; i++) {\n            ERC20(_LPTokens[i]).approve(address(_newHoneyLocker), _amountsOrIds[i]);\n            HoneyLocker(_newHoneyLocker).depositAndLock(_LPTokens[i], _amountsOrIds[i], expirations[_LPTokens[i]]);\n            emit Migrated(_LPTokens[i], address(this), _newHoneyLocker);\n        }\n    }\n    function claimRewards(address _stakingContract, bytes memory _data) external onlyOwnerOrAutomaton onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "rewards", _data) {\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert ClaimRewardsFailed();\n        emit RewardsClaimed(_stakingContract);\n    }\n    function depositAndLock(address _LPToken, uint256 _amountOrId, uint256 _expiration) external onlyOwnerOrMigratingVault {\n        if (!unlocked && expirations[_LPToken] != 0 && _expiration < expirations[_LPToken]) revert ExpirationNotMatching();\n        expirations[_LPToken] = unlocked ? 1 : _expiration;\n        ERC721(_LPToken).transferFrom(msg.sender, address(this), _amountOrId);\n        emit Deposited(_LPToken, _amountOrId);\n        emit LockedUntil(_LPToken, _expiration);\n    }\n    function delegateBGT(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().queueBoost(_validator, _amount);\n    }\n    function activateBoost(address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().activateBoost(_validator);\n    }\n    function cancelQueuedBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().cancelBoost(_validator, _amount);\n    }\n    function dropBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().dropBoost(_validator, _amount);\n    }\n    function withdrawBERA(uint256 _amount) public onlyOwner {\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        STL.safeTransferETH(msg.sender, _amount - fees);\n        HONEY_QUEEN.beekeeper().distributeFees{value: fees}(referral, address(0), fees);\n        emit Withdrawn(address(0), _amount - fees);\n    }\n    function withdrawERC20(address _token, uint256 _amount) external onlyUnblockedTokens(_token) onlyOwner {\n        if (expirations[_token] != 0) revert CannotBeLPToken();\n        Beekeeper beekeeper = HONEY_QUEEN.beekeeper();\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        ERC20(_token).transfer(msg.sender, _amount - fees);\n        ERC20(_token).transfer(address(beekeeper), fees);\n        beekeeper.distributeFees(referral, _token, fees);\n        emit Withdrawn(_token, _amount - fees);\n    }\n    function withdrawERC721(address _token, uint256 _id) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC721(_token).transferFrom(address(this), msg.sender, _id);\n    }\n    function withdrawERC1155(address _token, uint256 _id, uint256 _amount, bytes calldata _data) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC1155(_token).safeTransferFrom(address(this), msg.sender, _id, _amount, _data);\n    }\n    receive() external payable {}\n}",
    "vulnerable_lines": [6],
    "vulnerable_functions": ["withdrawLPToken"]
  },
  
  "context_files": [],
  
  "call_flow": "Owner.depositAndLock(BGT, 0, pastTime) -> `expirations[BGT]` is set non-zero -> Owner.withdrawLPToken(BGT, amount) -> BGT is withdrawn without fees, bypassing fee structure.",
  "context_hint": "This is an economic attack path leveraging the same structural flaw as [H-01]. Instead of bypassing a safety block, it bypasses the revenue-generating fee mechanism, leading to a loss of protocol income.",
  
  "is_vulnerable": true,
  
  "expert_notes": "High severity because it allows the contract owner to steal protocol revenue by exploiting a function designed for a specific asset type (LPs) to withdraw general assets (rewards) without fees."
}

{
  "id": "gs_honeyjar_interpol_H03",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[H-03]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "high",
  "vulnerability_type": "asset_loss_logic",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "All locked LP tokens can be withdrawn during a migration",
  "finding_description": "The `migrate()` function, intended to move assets to a new `HoneyLocker`, relies only on codehash checks (`HONEY_QUEEN.isMigrationEnabled(address(this).codehash, _newHoneyLocker.codehash)`) to authorize the migration. This check is insufficient because it does not guarantee that the target vault (`_newHoneyLocker`) has the same initialized security-critical values (like `unlocked`, `HONEY_QUEEN`, and `referral`). A malicious actor can initialize a new `HoneyLocker` with the `unlocked` flag set to `true` (or a malicious `HONEY_QUEEN` address) and migrate all locked LP tokens to it, immediately enabling withdrawal.",
  "attack_scenario": "1. The owner creates a new `HoneyLockerV2` contract (`maliciousLocker`).\n2. The owner initializes `maliciousLocker` with `unlocked = true`.\n3. The owner sets the migration flag in `HoneyQueen` based on codehashes.\n4. The owner calls `HoneyLocker.migrate()` to send all locked LP tokens to `maliciousLocker`.\n5. Since `maliciousLocker` is initialized as `unlocked = true`, the owner can immediately call `maliciousLocker.withdrawLPToken()` and drain all previously locked LP tokens, bypassing their original expiration times.",
  "fix_description": "Add additional checks in the `migrate()` function to verify that critical security-related initialization parameters (`unlocked`, `HONEY_QUEEN`, and `referral`) are identical between the current lock and the new `_newHoneyLocker` before proceeding with the asset transfer.",
  
  "primary_file": {
    "path": "HoneyLocker.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {ERC721} from "solady/tokens/ERC721.sol";\nimport {ERC1155} from "solady/tokens/ERC1155.sol";\nimport {SafeTransferLib as STL} from "solady/utils/SafeTransferLib.sol";\nimport {HoneyQueen} from "./HoneyQueen.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {TokenReceiver} from "./utils/TokenReceiver.sol";\ncontract HoneyLocker is TokenReceiver, Ownable {\n    error MigrationNotEnabled();\n    error ExpirationNotMatching();\n    error TargetContractNotAllowed();\n    error NotExpiredYet();\n    error TokenBlocked();\n    error CannotBeLPToken();\n    error HasToBeLPToken();\n    error StakeFailed();\n    error UnstakeFailed();\n    error SelectorNotAllowed();\n    error ClaimRewardsFailed();\n    error WildcardFailed();\n    event Initialized(address indexed owner);\n    event Deposited(address indexed token, uint256 amount);\n    event LockedUntil(address indexed token, uint256 expiration);\n    event Staked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Unstaked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Withdrawn(address indexed token, uint256 amount);\n    event Migrated(address indexed token, address indexed oldLocker, address indexed newLocker);\n    event RewardsClaimed(address stakingContract);\n    mapping(address => mapping(address => uint256)) public staked;\n    mapping(address => uint256) public expirations;\n    address public referral;\n    bool public unlocked;\n    HoneyQueen internal HONEY_QUEEN;\n    modifier onlyOwnerOrMigratingVault() {\n        if (msg.sender != owner() && owner() != Ownable(msg.sender).owner()) revert Unauthorized();\n        _;\n    }\n    modifier onlyOwnerOrAutomaton() {\n        if (msg.sender != owner() && msg.sender != HONEY_QUEEN.automaton()) revert Unauthorized();\n        _;\n    }\n    modifier onlyUnblockedTokens(address _token) {\n        if (!unlocked && HONEY_QUEEN.isTokenBlocked(_token)) revert TokenBlocked();\n        _;\n    }\n    modifier onlyAllowedSelector(address _stakingContract, string memory action, bytes memory _data) {\n        bytes4 selector;\n        assembly { selector := mload(add(_data, 32)) }\n        if (!HONEY_QUEEN.isSelectorAllowedForTarget(selector, action, _stakingContract)) revert SelectorNotAllowed();\n        _;\n    }\n    modifier onlyAllowedTargetContract(address _targetContract) {\n        if (!HONEY_QUEEN.isTargetContractAllowed(_targetContract)) revert TargetContractNotAllowed();\n        _;\n    }\n    function initialize(address _owner, address _honeyQueen, address _referral, bool _unlocked) external {\n        require(address(HONEY_QUEEN) == address(0));\n        _initializeOwner(_owner);\n        HONEY_QUEEN = HoneyQueen(_honeyQueen);\n        referral = _referral;\n        unlocked = _unlocked;\n        emit Initialized(_owner);\n    }\n    function wildcard(address _contract, bytes calldata _data) external onlyOwner onlyAllowedTargetContract(_contract) onlyAllowedSelector(_contract, "wildcard", _data) {\n        (bool success,) = _contract.call(_data);\n        if (!success) revert WildcardFailed();\n    }\n    function stake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) external onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "stake", _data) {\n        staked[_LPToken][_stakingContract] += _amount;\n        ERC20(_LPToken).approve(address(_stakingContract), _amount);\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert StakeFailed();\n        emit Staked(_stakingContract, _LPToken, _amount);\n    }\n    function unstake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) public onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "unstake", _data) {\n        staked[_LPToken][_stakingContract] -= _amount;\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert UnstakeFailed();\n        emit Unstaked(_stakingContract, _LPToken, _amount);\n    }\n    function burnBGTForBERA(uint256 _amount) external onlyOwner {\n        HONEY_QUEEN.BGT().redeem(address(this), _amount);\n        withdrawBERA(_amount);\n    }\n    function withdrawLPToken(address _LPToken, uint256 _amount) external onlyOwner {\n        if (expirations[_LPToken] == 0) revert HasToBeLPToken();\n        if (block.timestamp < expirations[_LPToken]) revert NotExpiredYet();\n        ERC20(_LPToken).transfer(msg.sender, _amount);\n        emit Withdrawn(_LPToken, _amount);\n    }\n    function migrate(address[] calldata _LPTokens, uint256[] calldata _amountsOrIds, address payable _newHoneyLocker) external onlyOwner {\n        if (!HONEY_QUEEN.isMigrationEnabled(address(this).codehash, _newHoneyLocker.codehash)) revert MigrationNotEnabled();\n        for (uint256 i; i < _LPTokens.length; i++) {\n            ERC20(_LPTokens[i]).approve(address(_newHoneyLocker), _amountsOrIds[i]);\n            HoneyLocker(_newHoneyLocker).depositAndLock(_LPTokens[i], _amountsOrIds[i], expirations[_LPTokens[i]]);\n            emit Migrated(_LPTokens[i], address(this), _newHoneyLocker);\n        }\n    }\n    function claimRewards(address _stakingContract, bytes memory _data) external onlyOwnerOrAutomaton onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "rewards", _data) {\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert ClaimRewardsFailed();\n        emit RewardsClaimed(_stakingContract);\n    }\n    function depositAndLock(address _LPToken, uint256 _amountOrId, uint256 _expiration) external onlyOwnerOrMigratingVault {\n        if (!unlocked && expirations[_LPToken] != 0 && _expiration < expirations[_LPToken]) revert ExpirationNotMatching();\n        expirations[_LPToken] = unlocked ? 1 : _expiration;\n        ERC721(_LPToken).transferFrom(msg.sender, address(this), _amountOrId);\n        emit Deposited(_LPToken, _amountOrId);\n        emit LockedUntil(_LPToken, _expiration);\n    }\n    function delegateBGT(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().queueBoost(_validator, _amount);\n    }\n    function activateBoost(address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().activateBoost(_validator);\n    }\n    function cancelQueuedBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().cancelBoost(_validator, _amount);\n    }\n    function dropBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().dropBoost(_validator, _amount);\n    }\n    function withdrawBERA(uint256 _amount) public onlyOwner {\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        STL.safeTransferETH(msg.sender, _amount - fees);\n        HONEY_QUEEN.beekeeper().distributeFees{value: fees}(referral, address(0), fees);\n        emit Withdrawn(address(0), _amount - fees);\n    }\n    function withdrawERC20(address _token, uint256 _amount) external onlyUnblockedTokens(_token) onlyOwner {\n        if (expirations[_token] != 0) revert CannotBeLPToken();\n        Beekeeper beekeeper = HONEY_QUEEN.beekeeper();\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        ERC20(_token).transfer(msg.sender, _amount - fees);\n        ERC20(_token).transfer(address(beekeeper), fees);\n        beekeeper.distributeFees(referral, _token, fees);\n        emit Withdrawn(_token, _amount - fees);\n    }\n    function withdrawERC721(address _token, uint256 _id) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC721(_token).transferFrom(address(this), msg.sender, _id);\n    }\n    function withdrawERC1155(address _token, uint256 _id, uint256 _amount, bytes calldata _data) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC1155(_token).safeTransferFrom(address(this), msg.sender, _id, _amount, _data);\n    }\n    receive() external payable {}\n}",
    "vulnerable_lines": [7],
    "vulnerable_functions": ["migrate"]
  },
  
  "context_files": [],
  
  "call_flow": "Owner initializes `MaliciousLocker` with `unlocked=true` -> Owner calls `HoneyLocker.migrate(..., MaliciousLocker)` -> Asset transfer executes based on insufficient codehash check -> `MaliciousLocker` now holds locked assets but allows immediate withdrawal.",
  "context_hint": "Insecure migration logic. By only verifying the contract code (codehash) and not the contract's critical storage state (which is set during initialization), the security properties (locking mechanism) of the old contract are not guaranteed to be maintained in the new contract.",
  
  "is_vulnerable": true,
  
  "expert_notes": "High severity because it allows the contract owner to bypass all time locks for all users during a migration, enabling immediate withdrawal of all staked funds."
}

{
  "id": "gs_honeyjar_interpol_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "medium",
  "vulnerability_type": "logic_error",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Function isTargetContractAllowed always returns true",
  "finding_description": "The `isTargetContractAllowed` function is intended to check if a contract has been whitelisted by checking if its corresponding `protocolOfTarget` string is non-empty. However, the inline assembly used (`allowed := not(iszero(protocol))`) to check if the memory string is empty is flawed. In Solidity, a memory pointer to a string (`protocol`) is always non-zero once allocated, regardless of the string's content (even if its length is 0). Consequently, the condition always evaluates to `true`, incorrectly indicating that every contract address is allowed.",
  "attack_scenario": "While the impact is currently mitigated by checks in the `isSelectorAllowedForTarget` function (which prevents unauthorized calls), if this flawed function were used standalone in future code (e.g., to gate a more generalized 'allow call' mechanism), it would enable locker owners to fully circumvent liquidity lock restrictions or avoid paying fees by interacting with any target contract, regardless of whitelisting status.",
  "fix_description": "The function should check the length of the memory string instead of checking the memory pointer. The fix is to replace the assembly block with a standard Solidity check: `allowed = bytes(protocol).length > 0`.",
  
  "primary_file": {
    "path": "HoneyQueen.sol",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {IBGT} from "./utils/IBGT.sol";\ncontract HoneyQueen is Ownable {\n    event ProtocolOfTargetSet(address targetContract, string protocol);\n    event SelectorAllowedForProtocol(bytes4 selector, string action, string protocol, bool allowed);\n    event TokenBlocked(address token, bool blocked);\n    event MigrationFlagSet(bytes32 fromCodeHash, bytes32 toCodeHash, bool isEnabled);\n    event TreasurySet(address oldTreasury, address newTreasury);\n    event AutomatonSet(address oldAutomaton, address newAutomaton);\n    event ValidatorSet(address oldValidator, address newValidator);\n    event FeesSet(uint256 oldFees, uint256 newFees);\n    address public treasury;\n    address public automaton;\n    address public validator;\n    uint256 public fees = 200;\n    Beekeeper public immutable beekeeper;\n    IBGT public immutable BGT;\n    mapping(address => string) public protocolOfTarget;\n    mapping(bytes4 => mapping(string => mapping(string => bool))) public isSelectorAllowedForProtocol;\n    mapping(address => bool) public isTokenBlocked;\n    mapping(bytes32 => mapping(bytes32 => bool)) public isMigrationEnabled;\n    constructor(address _treasury, address _BGT, address _beekeeper) {\n        treasury = _treasury;\n        BGT = IBGT(_BGT);\n        beekeeper = Beekeeper(_beekeeper);\n        _initializeOwner(msg.sender);\n    }\n    function setProtocolOfTarget(address _targetContract, string memory _protocol) external onlyOwner {\n        protocolOfTarget[_targetContract] = _protocol;\n        emit ProtocolOfTargetSet(_targetContract, _protocol);\n    }\n    function setIsSelectorAllowedForProtocol(bytes4 _selector, string memory _action, string memory _protocol, bool _isAllowed) external onlyOwner {\n        isSelectorAllowedForProtocol[_selector][_action][_protocol] = _isAllowed;\n        emit SelectorAllowedForProtocol(_selector, _action, _protocol, _isAllowed);\n    }\n    function setIsTokenBlocked(address _token, bool _isBlocked) external onlyOwner {\n        isTokenBlocked[_token] = _isBlocked;\n        emit TokenBlocked(_token, _isBlocked);\n    }\n    function setMigrationFlag(bool _isMigrationEnabled, bytes32 _fromCodeHash, bytes32 _toCodeHash) external onlyOwner {\n        isMigrationEnabled[_fromCodeHash][_toCodeHash] = _isMigrationEnabled;\n        emit MigrationFlagSet(_fromCodeHash, _toCodeHash, _isMigrationEnabled);\n    }\n    function setTreasury(address _treasury) external onlyOwner {\n        emit TreasurySet(treasury, _treasury);\n        treasury = _treasury;\n    }\n    function setFees(uint256 _fees) external onlyOwner {\n        emit FeesSet(fees, _fees);\n        fees = _fees;\n    }\n    function setValidator(address _validator) external onlyOwner {\n        emit ValidatorSet(validator, _validator);\n        validator = _validator;\n    }\n    function setAutomaton(address _automaton) external onlyOwner {\n        emit AutomatonSet(automaton, _automaton);\n        automaton = _automaton;\n    }\n    function computeFees(uint256 amount) public view returns (uint256) {\n        return (amount * fees) / 10000;\n    }\n    function isTargetContractAllowed(address _target) public view returns (bool allowed) {\n        string memory protocol = protocolOfTarget[_target];\n        assembly { allowed := not(iszero(protocol)) }\n    }\n    function isSelectorAllowedForTarget(bytes4 _selector, string calldata _action, address _target) public view returns (bool) {\n        return isSelectorAllowedForProtocol[_selector][_action][protocolOfTarget[_target]];\n    }\n}",
    "vulnerable_lines": [5],
    "vulnerable_functions": ["isTargetContractAllowed"]
  },
  
  "context_files": [],
  
  "call_flow": "Any address passed to `isTargetContractAllowed` -> `protocolOfTarget` returns string pointer -> Assembly checks pointer (always non-zero) -> Function returns `true`.",
  "context_hint": "A subtle logic error due to incorrect usage of inline assembly for memory string checks. This function fails its intended purpose of enforcing a contract whitelist, which could lead to severe security issues if relied upon elsewhere in the protocol.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Medium severity because the flawed function is currently not the primary gatekeeper, but its incorrect logic represents a latent security debt. The fix is trivial and standard practice."
}

{
  "id": "gs_honeyjar_interpol_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "medium",
  "vulnerability_type": "logic_error_dos",
  "difficulty_tier": 2,
  "context_level": "cross_contract",
  
  "finding_title": "HoneyLocker.unstake() can possibly lead to underflow",
  "finding_description": "The `HoneyLocker.unstake()` function reduces the locally tracked staked amount (`staked[_LPToken][_stakingContract] -= _amount;`) *before* calling the external staking contract. If the external staking contract's function (e.g., `Kodiak.withdrawLockedAll()`) executes but fails to transfer the underlying LP tokens back to the `HoneyLocker` (e.g., because the lock expiration is not yet met), the local state is incorrectly updated. Subsequently, when the owner attempts to unstake the LP tokens again after the expiration is met, `unstake()` will attempt to deduct from the already zeroed-out local state, causing an underflow and making the LP tokens permanently stuck in the external staking contract.",
  "attack_scenario": "1. Owner stakes 100 LP tokens for 30 days. `staked[LP][Kodiak]` is 100.\n2. After 15 days, Owner calls `unstake()` with `amount=100` and `data` for `withdrawLockedAll()`.\n3. `HoneyLocker` deducts: `staked[LP][Kodiak]` becomes 0.\n4. External call to `Kodiak.withdrawLockedAll()` collects rewards but skips token transfer (lock not expired).\n5. After 30 days, Owner calls `unstake()` again with `amount=100`.\n6. `HoneyLocker` attempts to deduct: `0 - 100`, which reverts with an underflow.\n7. The 100 LP tokens are stuck in the Kodiak staking contract, permanently unrecoverable by the `HoneyLocker`.",
  "fix_description": "Add a check to prevent underflow: `if (_amount >= staked[_LPToken][_stakingContract]) { ... }`. More accurately, the function should follow the checks-effects-interactions pattern and only update the local state *after* the external call succeeds and the transfer amount is verified.",
  
  "primary_file": {
    "path": "HoneyLocker.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {ERC721} from "solady/tokens/ERC721.sol";\nimport {ERC1155} from "solady/tokens/ERC1155.sol";\nimport {SafeTransferLib as STL} from "solady/utils/SafeTransferLib.sol";\nimport {HoneyQueen} from "./HoneyQueen.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {TokenReceiver} from "./utils/TokenReceiver.sol";\ncontract HoneyLocker is TokenReceiver, Ownable {\n    error MigrationNotEnabled();\n    error ExpirationNotMatching();\n    error TargetContractNotAllowed();\n    error NotExpiredYet();\n    error TokenBlocked();\n    error CannotBeLPToken();\n    error HasToBeLPToken();\n    error StakeFailed();\n    error UnstakeFailed();\n    error SelectorNotAllowed();\n    error ClaimRewardsFailed();\n    error WildcardFailed();\n    event Initialized(address indexed owner);\n    event Deposited(address indexed token, uint256 amount);\n    event LockedUntil(address indexed token, uint256 expiration);\n    event Staked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Unstaked(address indexed stakingContract, address indexed token, uint256 amount);\n    event Withdrawn(address indexed token, uint256 amount);\n    event Migrated(address indexed token, address indexed oldLocker, address indexed newLocker);\n    event RewardsClaimed(address stakingContract);\n    mapping(address => mapping(address => uint256)) public staked;\n    mapping(address => uint256) public expirations;\n    address public referral;\n    bool public unlocked;\n    HoneyQueen internal HONEY_QUEEN;\n    modifier onlyOwnerOrMigratingVault() {\n        if (msg.sender != owner() && owner() != Ownable(msg.sender).owner()) revert Unauthorized();\n        _;\n    }\n    modifier onlyOwnerOrAutomaton() {\n        if (msg.sender != owner() && msg.sender != HONEY_QUEEN.automaton()) revert Unauthorized();\n        _;\n    }\n    modifier onlyUnblockedTokens(address _token) {\n        if (!unlocked && HONEY_QUEEN.isTokenBlocked(_token)) revert TokenBlocked();\n        _;\n    }\n    modifier onlyAllowedSelector(address _stakingContract, string memory action, bytes memory _data) {\n        bytes4 selector;\n        assembly { selector := mload(add(_data, 32)) }\n        if (!HONEY_QUEEN.isSelectorAllowedForTarget(selector, action, _stakingContract)) revert SelectorNotAllowed();\n        _;\n    }\n    modifier onlyAllowedTargetContract(address _targetContract) {\n        if (!HONEY_QUEEN.isTargetContractAllowed(_targetContract)) revert TargetContractNotAllowed();\n        _;\n    }\n    function initialize(address _owner, address _honeyQueen, address _referral, bool _unlocked) external {\n        require(address(HONEY_QUEEN) == address(0));\n        _initializeOwner(_owner);\n        HONEY_QUEEN = HoneyQueen(_honeyQueen);\n        referral = _referral;\n        unlocked = _unlocked;\n        emit Initialized(_owner);\n    }\n    function wildcard(address _contract, bytes calldata _data) external onlyOwner onlyAllowedTargetContract(_contract) onlyAllowedSelector(_contract, "wildcard", _data) {\n        (bool success,) = _contract.call(_data);\n        if (!success) revert WildcardFailed();\n    }\n    function stake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) external onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "stake", _data) {\n        staked[_LPToken][_stakingContract] += _amount;\n        ERC20(_LPToken).approve(address(_stakingContract), _amount);\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert StakeFailed();\n        emit Staked(_stakingContract, _LPToken, _amount);\n    }\n    function unstake(address _LPToken, address _stakingContract, uint256 _amount, bytes memory _data) public onlyOwner onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "unstake", _data) {\n        staked[_LPToken][_stakingContract] -= _amount;\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert UnstakeFailed();\n        emit Unstaked(_stakingContract, _LPToken, _amount);\n    }\n    function burnBGTForBERA(uint256 _amount) external onlyOwner {\n        HONEY_QUEEN.BGT().redeem(address(this), _amount);\n        withdrawBERA(_amount);\n    }\n    function withdrawLPToken(address _LPToken, uint256 _amount) external onlyOwner {\n        if (expirations[_LPToken] == 0) revert HasToBeLPToken();\n        if (block.timestamp < expirations[_LPToken]) revert NotExpiredYet();\n        ERC20(_LPToken).transfer(msg.sender, _amount);\n        emit Withdrawn(_LPToken, _amount);\n    }\n    function migrate(address[] calldata _LPTokens, uint256[] calldata _amountsOrIds, address payable _newHoneyLocker) external onlyOwner {\n        if (!HONEY_QUEEN.isMigrationEnabled(address(this).codehash, _newHoneyLocker.codehash)) revert MigrationNotEnabled();\n        for (uint256 i; i < _LPTokens.length; i++) {\n            ERC20(_LPTokens[i]).approve(address(_newHoneyLocker), _amountsOrIds[i]);\n            HoneyLocker(_newHoneyLocker).depositAndLock(_LPTokens[i], _amountsOrIds[i], expirations[_LPTokens[i]]);\n            emit Migrated(_LPTokens[i], address(this), _newHoneyLocker);\n        }\n    }\n    function claimRewards(address _stakingContract, bytes memory _data) external onlyOwnerOrAutomaton onlyAllowedTargetContract(_stakingContract) onlyAllowedSelector(_stakingContract, "rewards", _data) {\n        (bool success,) = _stakingContract.call(_data);\n        if (!success) revert ClaimRewardsFailed();\n        emit RewardsClaimed(_stakingContract);\n    }\n    function depositAndLock(address _LPToken, uint256 _amountOrId, uint256 _expiration) external onlyOwnerOrMigratingVault {\n        if (!unlocked && expirations[_LPToken] != 0 && _expiration < expirations[_LPToken]) revert ExpirationNotMatching();\n        expirations[_LPToken] = unlocked ? 1 : _expiration;\n        ERC721(_LPToken).transferFrom(msg.sender, address(this), _amountOrId);\n        emit Deposited(_LPToken, _amountOrId);\n        emit LockedUntil(_LPToken, _expiration);\n    }\n    function delegateBGT(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().queueBoost(_validator, _amount);\n    }\n    function activateBoost(address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().activateBoost(_validator);\n    }\n    function cancelQueuedBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().cancelBoost(_validator, _amount);\n    }\n    function dropBoost(uint128 _amount, address _validator) external onlyOwner {\n        HONEY_QUEEN.BGT().dropBoost(_validator, _amount);\n    }\n    function withdrawBERA(uint256 _amount) public onlyOwner {\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        STL.safeTransferETH(msg.sender, _amount - fees);\n        HONEY_QUEEN.beekeeper().distributeFees{value: fees}(referral, address(0), fees);\n        emit Withdrawn(address(0), _amount - fees);\n    }\n    function withdrawERC20(address _token, uint256 _amount) external onlyUnblockedTokens(_token) onlyOwner {\n        if (expirations[_token] != 0) revert CannotBeLPToken();\n        Beekeeper beekeeper = HONEY_QUEEN.beekeeper();\n        uint256 fees = HONEY_QUEEN.computeFees(_amount);\n        ERC20(_token).transfer(msg.sender, _amount - fees);\n        ERC20(_token).transfer(address(beekeeper), fees);\n        beekeeper.distributeFees(referral, _token, fees);\n        emit Withdrawn(_token, _amount - fees);\n    }\n    function withdrawERC721(address _token, uint256 _id) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC721(_token).transferFrom(address(this), msg.sender, _id);\n    }\n    function withdrawERC1155(address _token, uint256 _id, uint256 _amount, bytes calldata _data) external onlyUnblockedTokens(_token) onlyOwner {\n        ERC1155(_token).safeTransferFrom(address(this), msg.sender, _id, _amount, _data);\n    }\n    receive() external payable {}\n}",
    "vulnerable_lines": [8],
    "vulnerable_functions": ["unstake"]
  },
  
  "context_files": [],
  
  "call_flow": "HoneyLocker.unstake() -> Local state `staked` is reduced -> External call to staking contract fails to transfer tokens -> Local state is incorrect -> Subsequent call reverts on underflow, tokens are stuck.",
  "context_hint": "Violation of the checks-effects-interactions pattern. Prematurely updating the local balance tracking state before confirming the external withdrawal interaction leads to inconsistent state and a denial of service where funds are permanently stuck.",
  
  "is_vulnerable": true,
  
  "expert_notes": "High impact (permanent fund lock) but with a specific external condition (external contract conditionally transfers), making Medium severity appropriate per the report. The solution is to ensure the effects (state change) only happen after successful interaction (token transfer confirmation)."
}

{
  "id": "gs_honeyjar_interpol_M03",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Interpol Security Review",
  "source_finding_id": "[M-03]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Interpol-security-review.pdf",
  "github_repo_url": "https://github.com/0xHoneyJar/interpol-contracts/tree/dafe92ea1ad300d566a65743bfed4dbdd8e96427",
  "contest_date": "2025-09-02",
  
  "severity": "medium",
  "vulnerability_type": "economic_rounding",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Users can avoid paying fees to the protocol due to rounding",
  "finding_description": "The fee calculation in `HoneyQueen::computeFees` uses standard Solidity integer division, which rounds down toward zero: `return (amount * fees) / 10000;`. With a fee rate of 200 basis points (2%), a malicious owner can repeatedly withdraw funds in very small batches (e.g., 49 tokens). For this amount, the calculated fee is `(49 * 200) / 10000 = 0`, allowing the owner to avoid paying any fees to the referral or the treasury.",
  "attack_scenario": "The owner of a `HoneyLocker` contract with 1,000,000 tokens to withdraw can repeatedly execute `withdrawERC20` (or `withdrawBERA`) with an amount of 49 tokens. While the gas cost for 20,409 transactions is high, for high-value tokens with fewer decimals, the aggregate saving on fees can outweigh the transaction costs, allowing the owner to steal the expected protocol revenue.",
  "fix_description": "To ensure no withdrawal is completely free of charge, modify the fee calculation in `computeFees` to always round up (e.g., using `(amount * fees + 9999) / 10000` or a similar ceil function) or implement a minimum fee threshold that guarantees a non-zero fee for every transaction.",
  
  "primary_file": {
    "path": "HoneyQueen.sol",
    "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {Beekeeper} from "./Beekeeper.sol";\nimport {IBGT} from "./utils/IBGT.sol";\ncontract HoneyQueen is Ownable {\n    event ProtocolOfTargetSet(address targetContract, string protocol);\n    event SelectorAllowedForProtocol(bytes4 selector, string action, string protocol, bool allowed);\n    event TokenBlocked(address token, bool blocked);\n    event MigrationFlagSet(bytes32 fromCodeHash, bytes32 toCodeHash, bool isEnabled);\n    event TreasurySet(address oldTreasury, address newTreasury);\n    event AutomatonSet(address oldAutomaton, address newAutomaton);\n    event ValidatorSet(address oldValidator, address newValidator);\n    event FeesSet(uint256 oldFees, uint256 newFees);\n    address public treasury;\n    address public automaton;\n    address public validator;\n    uint256 public fees = 200;\n    Beekeeper public immutable beekeeper;\n    IBGT public immutable BGT;\n    mapping(address => string) public protocolOfTarget;\n    mapping(bytes4 => mapping(string => mapping(string => bool))) public isSelectorAllowedForProtocol;\n    mapping(address => bool) public isTokenBlocked;\n    mapping(bytes32 => mapping(bytes32 => bool)) public isMigrationEnabled;\n    constructor(address _treasury, address _BGT, address _beekeeper) {\n        treasury = _treasury;\n        BGT = IBGT(_BGT);\n        beekeeper = Beekeeper(_beekeeper);\n        _initializeOwner(msg.sender);\n    }\n    function setProtocolOfTarget(address _targetContract, string memory _protocol) external onlyOwner {\n        protocolOfTarget[_targetContract] = _protocol;\n        emit ProtocolOfTargetSet(_targetContract, _protocol);\n    }\n    function setIsSelectorAllowedForProtocol(bytes4 _selector, string memory _action, string memory _protocol, bool _isAllowed) external onlyOwner {\n        isSelectorAllowedForProtocol[_selector][_action][_protocol] = _isAllowed;\n        emit SelectorAllowedForProtocol(_selector, _action, _protocol, _isAllowed);\n    }\n    function setIsTokenBlocked(address _token, bool _isBlocked) external onlyOwner {\n        isTokenBlocked[_token] = _isBlocked;\n        emit TokenBlocked(_token, _isBlocked);\n    }\n    function setMigrationFlag(bool _isMigrationEnabled, bytes32 _fromCodeHash, bytes32 _toCodeHash) external onlyOwner {\n        isMigrationEnabled[_fromCodeHash][_toCodeHash] = _isMigrationEnabled;\n        emit MigrationFlagSet(_fromCodeHash, _toCodeHash, _isMigrationEnabled);\n    }\n    function setTreasury(address _treasury) external onlyOwner {\n        emit TreasurySet(treasury, _treasury);\n        treasury = _treasury;\n    }\n    function setFees(uint256 _fees) external onlyOwner {\n        emit FeesSet(fees, _fees);\n        fees = _fees;\n    }\n    function setValidator(address _validator) external onlyOwner {\n        emit ValidatorSet(validator, _validator);\n        validator = _validator;\n    }\n    function setAutomaton(address _automaton) external onlyOwner {\n        emit AutomatonSet(automaton, _automaton);\n        automaton = _automaton;\n    }\n    function computeFees(uint256 amount) public view returns (uint256) {\n        return (amount * fees) / 10000;\n    }\n    function isTargetContractAllowed(address _target) public view returns (bool allowed) {\n        string memory protocol = protocolOfTarget[_target];\n        assembly { allowed := not(iszero(protocol)) }\n    }\n    function isSelectorAllowedForTarget(bytes4 _selector, string calldata _action, address _target) public view returns (bool) {\n        return isSelectorAllowedForProtocol[_selector][_action][protocolOfTarget[_target]];\n    }\n}",
    "vulnerable_lines": [4],
    "vulnerable_functions": ["computeFees"]
  },
  
  "context_files": [],
  
  "call_flow": "Owner calls `withdrawERC20(smallAmount)` -> `HoneyQueen.computeFees(smallAmount)` -> Fee calculation rounds down to 0 -> Withdrawal executes without fee deduction.",
  "context_hint": "A common economic vulnerability arising from rounding down in Solidity arithmetic. It allows an attacker to bypass the revenue mechanism through strategically splitting large withdrawals into many small, fee-exempt transactions.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Medium severity because the attack is limited by gas costs and only affects small withdrawal amounts, but it represents a clear loss of expected protocol revenue. The fix should prioritize rounding up for fee calculations."
}

{
  "id": "gs_t1moh_laposte_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "LaPoste Security Review",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/LaPoste-security-review-October.pdf",
  "github_repo_url": "https://github.com/stake-dao/laposte/tree/0bf0be29ea9d78aa147cc7a924a4c10dba262669",
  "contest_date": "2025-10-22",
  
  "severity": "medium",
  "vulnerability_type": "deployment_incompatibility",
  "difficulty_tier": 3,
  "context_level": "multi_file",
  
  "finding_title": "Protocol will not work on ZkSync and Celo",
  "finding_description": "The protocol's cross-chain messaging logic relies on the assumption that core contracts (like `LaPoste.sol`) will be deployed to the exact same address across all chains. This assumption is crucial in the `Adapter.ccipReceive` function, where it verifies the sender address: `if (source == address(0) || source != laPoste) revert InvalidSender();`. However, this is impossible on chains like ZkSync (due to different address derivation formulas) and Celo (due to different `create3` address derivation from the seed phrase, as the same transaction sender cannot be reproduced). This fundamental incompatibility breaks cross-chain communication to and from these chains.",
  "attack_scenario": "Deployment on ZkSync or Celo will result in a different `LaPoste` contract address than on other chains. When a message is sent from an external chain to ZkSync/Celo, the `Adapter.ccipReceive` function on the destination chain will revert because the reported `source` address (the sender `LaPoste` contract's address on the source chain) will not match the expected local `laPoste` address, effectively disabling the protocol on these chains.",
  "fix_description": "Use chain-specific addresses when sending messages to and from ZkSync and Celo. The protocol must maintain a mapping or configuration for the correct `LaPoste` address on each incompatible chain and update the address check logic accordingly.",
  
  "primary_file": {
    "path": "src/ccip/Adapter.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\nimport "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport "src/ccip/IRouter.sol";\nimport "src/libraries/Chains.sol";\nimport "src/interfaces/ILaPoste.sol";\nimport "src/interfaces/IERC165.sol";\nimport "src/interfaces/IAny2EVMMessageReceiver.sol";\ncontract Adapter is IAny2EVMMessageReceiver, IERC165 {\n    using SafeCast for uint256;\n    address public immutable laPoste;\n    uint256 public immutable BASE_GAS_LIMIT;\n    IRouter public immutable router;\n    error OnlyRouter();\n    error OnlyLaPoste();\n    error InvalidSender();\n    error InvalidChainId();\n    error InvalidMessage();\n    error NotEnoughFee();\n    error ZeroAddress();\n    error SameChain();\n    modifier onlyRouter() {\n        if (msg.sender != address(router)) revert OnlyRouter();\n        _;\n    }\n    modifier onlyLaPoste() {\n        if (msg.sender != laPoste) revert OnlyLaPoste();\n        _;\n    }\n    constructor(address _laPoste, address _router, uint256 _baseGasLimit) {\n        laPoste = _laPoste;\n        router = IRouter(_router);\n        BASE_GAS_LIMIT = _baseGasLimit;\n    }\n    function sendMessage(address to, uint256 executionGasLimit, uint256 destinationChainId, bytes calldata message) external payable returns (bytes32) {\n        if (address(this) != laPoste) revert OnlyLaPoste();\n        if (destinationChainId == block.chainid) revert SameChain();\n        uint64 chainSelector = getBridgeChainId(destinationChainId).toUint64();\n        if (!router.isChainSupported(chainSelector)) revert InvalidChainId();\n        uint256 totalGasLimit = executionGasLimit + BASE_GAS_LIMIT;\n        Client.EVMExtraArgsV1 memory evmExtraArgs = Client.EVMExtraArgsV1({gasLimit: totalGasLimit});\n        bytes memory extraArgs = Client._argsToBytes(evmExtraArgs);\n        Client.EVM2AnyMessage memory ccipMessage = Client.EVM2AnyMessage({\n            receiver: abi.encode(to),\n            data: message,\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            feeToken: address(0),\n            extraArgs: extraArgs\n        });\n        uint256 fee = router.getFee(chainSelector, ccipMessage);\n        if (fee == 0) revert InvalidMessage();\n        if (msg.value < fee) revert NotEnoughFee();\n        return router.ccipSend{value: fee}(chainSelector, ccipMessage);\n    }\n    function ccipReceive(Client.Any2EVMMessage calldata message) external override onlyRouter {\n        address source = abi.decode(message.sender, (address));\n        if (source == address(0) || source != laPoste) revert InvalidSender();\n        ILaPoste(laPoste).receiveMessage({chainId: getChainId(message.sourceChainSelector), payload: message.data});\n    }\n    function getChainId(uint256 bridgeChainId) public pure returns (uint256) {\n        if (bridgeChainId == CCIPSelectors.MAINNET) return Chains.MAINNET;\n        else if (bridgeChainId == CCIPSelectors.AVALANCHE) return Chains.AVALANCHE;\n        else if (bridgeChainId == CCIPSelectors.POLYGON) return Chains.POLYGON;\n        else if (bridgeChainId == CCIPSelectors.ARBITRUM) return Chains.ARBITRUM;\n        else if (bridgeChainId == CCIPSelectors.OPTIMISM) return Chains.OPTIMISM;\n        else if (bridgeChainId == CCIPSelectors.BNB) return Chains.BNB;\n        else if (bridgeChainId == CCIPSelectors.BASE) return Chains.BASE;\n        else if (bridgeChainId == CCIPSelectors.ZKSYNC) return Chains.ZKSYNC;\n        else if (bridgeChainId == CCIPSelectors.GNOSIS) return Chains.GNOSIS;\n        else if (bridgeChainId == CCIPSelectors.LINEA) return Chains.LINEA;\n        else if (bridgeChainId == CCIPSelectors.SCROLL) return Chains.SCROLL;\n        else if (bridgeChainId == CCIPSelectors.CELO) return Chains.CELO;\n        else if (bridgeChainId == CCIPSelectors.BLAST) return Chains.BLAST;\n        return bridgeChainId;\n    }\n    function getBridgeChainId(uint256 chainId) public pure returns (uint256) {\n        if (chainId == Chains.MAINNET) return CCIPSelectors.MAINNET;\n        else if (chainId == Chains.AVALANCHE) return CCIPSelectors.AVALANCHE;\n        else if (chainId == Chains.POLYGON) return CCIPSelectors.POLYGON;\n        else if (chainId == Chains.ARBITRUM) return CCIPSelectors.ARBITRUM;\n        else if (chainId == Chains.OPTIMISM) return CCIPSelectors.OPTIMISM;\n        else if (chainId == Chains.BNB) return CCIPSelectors.BNB;\n        else if (chainId == Chains.BASE) return CCIPSelectors.BASE;\n        else if (chainId == Chains.ZKSYNC) return CCIPSelectors.ZKSYNC;\n        else if (chainId == Chains.GNOSIS) return CCIPSelectors.GNOSIS;\n        else if (chainId == Chains.LINEA) return CCIPSelectors.LINEA;\n        else if (chainId == Chains.SCROLL) return CCIPSelectors.SCROLL;\n        else if (chainId == Chains.CELO) return CCIPSelectors.CELO;\n        else if (chainId == Chains.BLAST) return CCIPSelectors.BLAST;\n        return chainId;\n    }\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}",
    "vulnerable_lines": [7],
    "vulnerable_functions": ["ccipReceive"]
  },
  
  "context_files": [
    {
      "path": "src/libraries/Chains.sol",
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\nlibrary Chains {\n    uint256 internal constant MAINNET = 1;\n    uint256 internal constant ARBITRUM = 42161;\n    uint256 internal constant OPTIMISM = 10;\n    uint256 internal constant BASE = 8453;\n    uint256 internal constant POLYGON = 137;\n    uint256 internal constant BNB = 56;\n    uint256 internal constant ZKSYNC = 324;\n    uint256 internal constant GNOSIS = 100;\n    uint256 internal constant AVALANCHE = 43114;\n    uint256 internal constant LINEA = 59144;\n    uint256 internal constant WEMIX = 1111;\n    uint256 internal constant METIS = 1088;\n    uint256 internal constant SCROLL = 534352;\n    uint256 internal constant MODE = 34443;\n    uint256 internal constant KROMA = 255;\n    uint256 internal constant CELO = 42220;\n    uint256 internal constant BLAST = 81457;\n}\nlibrary CCIPSelectors {\n    uint256 internal constant MAINNET = 5009297550715157269;\n    uint256 internal constant AVALANCHE = 6433500567565415381;\n    uint256 internal constant POLYGON = 4051577828743386545;\n    uint256 internal constant BNB = 11344663589394136015;\n    uint256 internal constant ARBITRUM = 4949039107694359620;\n    uint256 internal constant OPTIMISM = 3734403246176062136;\n    uint256 internal constant BASE = 15971525489660198786;\n    uint256 internal constant ZKSYNC = 1562403441176082196;\n    uint256 internal constant GNOSIS = 465200170687744372;\n    uint256 internal constant LINEA = 4627098889531055414;\n    uint256 internal constant WEMIX = 5142893604156789321;\n    uint256 internal constant METIS = 8805746078405598895;\n    uint256 internal constant SCROLL = 13204309965629103672;\n    uint256 internal constant MODE = 7264351850409363825;\n    uint256 internal constant KROMA = 3719320017875267166;\n    uint256 internal constant CELO = 1346049177634351622;\n    uint256 internal constant BLAST = 4411394078118774322;\n}",
      "relevance": "Provides the chain selectors which identify the source/destination chains, including those with unique deployment characteristics (ZkSync, Celo)."
    }
  ],
  
  "call_flow": "Message sent from Chain A to ZkSync/Celo -> `Adapter.ccipReceive` on ZkSync/Celo receives message -> `source` address is compared to local `laPoste` address -> Check fails due to address derivation difference -> Message reverts.",
  "context_hint": "A cross-chain compatibility issue rooted in different EVM address derivation standards (like `create2` vs. `create3`) across various chains. The protocol's reliance on address parity is a single point of failure for incompatible chains.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Medium severity because it breaks core functionality on a subset of chains, but the impact is contained to those chains rather than leading to a financial exploit across the entire protocol."
}

{
  "id": "gs_t1moh_laposte_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "LaPoste Security Review",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/LaPoste-security-review-October.pdf",
  "github_repo_url": "https://github.com/stake-dao/laposte/tree/0bf0be29ea9d78aa147cc7a924a4c10dba262669",
  "contest_date": "2025-10-22",
  
  "severity": "medium",
  "vulnerability_type": "denial_of_retry",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "Manual Execution will not work with the current nonce implementation",
  "finding_description": "The `LaPoste.receiveMessage` function tracks message ordering using `receivedNonces[chainId]` and checks that the incoming message's `message.nonce` is greater than this stored nonce to prevent replay: `if (message.nonce <= receivedNonces[chainId]) revert MessageAlreadyProcessed()`. However, if a message transaction fails on the destination chain (e.g., due to gas limit), subsequent messages for that lane will still increment the stored nonce. When the sender of the failed message later attempts to manually execute (retry) the transaction, its original `message.nonce` will be less than the now-incremented `receivedNonces[chainId]`, causing the retry attempt to perpetually revert with `MessageAlreadyProcessed()`, locking the sender's funds on the source chain.",
  "attack_scenario": "1. Message 1 (nonce 1) succeeds. `receivedNonces[chainId]` becomes 1.\n2. Message 2 (nonce 2) fails due to low gas.\n3. Message 3 (nonce 3) succeeds. `receivedNonces[chainId]` becomes 3.\n4. The sender of Message 2 attempts manual execution (retry) of the original transaction.\n5. `receiveMessage` checks: `2 <= 3`, which is true, and reverts with `MessageAlreadyProcessed()`. The sender's locked tokens are permanently inaccessible via the protocol.",
  "fix_description": "The recommended approach from Chainlink documentation is to use `EVMExtraArgsV2` with `allowOutOfOrderExecution` set to `false`. This ensures that if a message fails, subsequent messages are blocked until the failure is resolved, maintaining sequential nonces and enabling retry. The current nonce logic is only suitable for ordered execution.",
  
  "primary_file": {
    "path": "LaPoste.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// #########################################################\n/// #########################################################\n/// ##############################################################\n/// ####################################################################\n/// ##########################################################################################\n/// #######################################################\n/// ########################################################\n/// #############################################################\n/// ################################################################\n/// ####################################################################\n/// ####################################################################\n/// #################################################################\n/// ################################################################\n/// #################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// #####################################################\n/// #############################################################\n/// ###############################################################\n/// ####################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\nimport "src/interfaces/ILaPoste.sol";\nimport "src/interfaces/IAdapter.sol";\nimport "src/interfaces/ITokenFactory.sol";\nimport "src/interfaces/IMessageReceiver.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/access/Ownable2Step.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n/// @title LaPoste\n/// @notice A contract for cross-chain message passing and token transfers\n/// @author StakeDAO - @warrenception\n/// @dev This contract uses a single adapter for governance-controlled bridge interactions\ncontract LaPoste is Ownable2Step {\n    using SafeERC20 for IERC20;\n    /// @notice The address of the token factory\n    address public immutable tokenFactory;\n    /// @notice The address of the adapter\n    address public adapter;\n    /// @notice Nonce for sent messages, per chain\n    mapping(uint256 => uint256) public sentNonces;\n    /// @notice Nonce for received messages, per chain\n    mapping(uint256 => uint256) public receivedNonces;\n    /// @notice Thrown when the sender is not the adapter.\n    error OnlyAdapter();\n    /// @notice Thrown when no adapter is set.\n    error NoAdapterSet();\n    /// @notice Thrown when a message execution fails.\n    error ExecutionFailed();\n    /// @notice Thrown when a message is expired.\n    error ExpiredMessage();\n    /// @notice Thrown when a message has already been processed.\n    error MessageAlreadyProcessed();\n    /// @notice Thrown when a message is sent to the same chain.\n    error CannotSendToSelf();\n    event MessageSent(\n        uint256 indexed chainId, uint256 indexed nonce, address indexed sender, address to, ILaPoste.Message message\n    );\n    event MessageReceived(\n        uint256 indexed chainId,\n        uint256 indexed nonce,\n        address indexed sender,\n        address to,\n        ILaPoste.Message message,\n        bool success\n    );\n    /// @notice Ensures that only the adapter can call the function.\n    modifier onlyAdapter() {\n        if (msg.sender != adapter) revert OnlyAdapter();\n        _;\n    }\n    /// @notice Constructs the LaPoste contract.\n    /// @param _tokenFactory The address of the token factory.\n    constructor(address _tokenFactory, address _owner) {\n        tokenFactory = _tokenFactory;\n        _transferOwnership(_owner);\n    }\n    /// @notice Sends a message across chains\n    /// @param messageParams The message parameters\n    /// @dev This function is payable to cover cross-chain fees\n    function sendMessage(ILaPoste.MessageParams memory messageParams, uint256 additionalGasLimit) external payable {\n        if (adapter == address(0)) revert NoAdapterSet();\n        if (messageParams.destinationChainId == block.chainid) revert CannotSendToSelf();\n        /// 0. Initialize the message.\n        ILaPoste.Message memory message;\n        /// 1. Set the message fields.\n        message.destinationChainId = messageParams.destinationChainId;\n        message.to = messageParams.to;\n        message.sender = msg.sender;\n        message.payload = messageParams.payload;\n        /// 2. Set the nonce in the message\n        message.nonce = sentNonces[message.destinationChainId] + 1;\n        /// 3. Check if there's a token attached and mint it to the receiver.\n        if (messageParams.token.tokenAddress != address(0)) {\n            message.token = messageParams.token;\n            ITokenFactory(tokenFactory).burn(messageParams.token.tokenAddress, msg.sender, messageParams.token.amount);\n            (message.tokenMetadata.name, message.tokenMetadata.symbol, message.tokenMetadata.decimals) =\n                ITokenFactory(tokenFactory).getTokenMetadata(messageParams.token.tokenAddress);\n        }\n        (bool success,) = adapter.delegatecall(\n            abi.encodeWithSelector(\n                IAdapter.sendMessage.selector,\n                adapter,\n                additionalGasLimit,\n                message.destinationChainId,\n                abi.encode(message)\n            )\n        );\n        if (!success) revert ExecutionFailed();\n        // Increment the sent nonce for the specific chain after successful send\n        sentNonces[message.destinationChainId] = message.nonce;\n        emit MessageSent(message.destinationChainId, message.nonce, msg.sender, message.to, message);\n    }\n    /// @notice Receives a message from another chain\n    /// @param chainId The ID of the source chain\n    /// @param payload The encoded message payload\n    function receiveMessage(uint256 chainId, bytes calldata payload) external onlyAdapter {\n        ILaPoste.Message memory message = abi.decode(payload, (ILaPoste.Message));\n        // Check if the message has already been processed\n        if (message.nonce <= receivedNonces[chainId]) revert MessageAlreadyProcessed();\n        /// 1. Check if there's a token attached and release or mint it to the receiver.\n        if (message.token.tokenAddress != address(0) && message.token.amount > 0) {\n            ITokenFactory(tokenFactory).mint(\n                message.token.tokenAddress,\n                message.to,\n                message.token.amount,\n                message.tokenMetadata.name,\n                message.tokenMetadata.symbol,\n                message.tokenMetadata.decimals\n            );\n        }\n        /// 2. Execute the message.\n        bool success;\n        if (message.payload.length > 0) {\n            try IMessageReceiver(message.to).receiveMessage(chainId, message.sender, message.payload) {\n                success = true;\n            } catch {\n                success = false;\n            }\n        }\n        // 3. Update the received nonce for the specific chain\n        receivedNonces[chainId] = message.nonce;\n        emit MessageReceived(chainId, message.nonce, message.sender, message.to, message, success);\n    }\n    /// @notice Sets the adapter address\n    /// @param _adapter The address of the new adapter\n    /// @dev It should be updated on all chains.\n    function setAdapter(address _adapter) external onlyOwner {\n        adapter = _adapter;\n    }\n}",
    "vulnerable_lines": [7],
    "vulnerable_functions": ["receiveMessage"]
  },
  
  "context_files": [],
  
  "call_flow": "Message 2 fails -> Message 3 succeeds, incrementing `receivedNonces` beyond 2 -> Manual execution of Message 2 is attempted (nonce 2) -> `receiveMessage` reverts with `MessageAlreadyProcessed` (2 <= 3).",
  "context_hint": "A critical flaw in non-sequential nonce handling for cross-chain retry mechanisms. By failing to account for skipped nonces, the protocol permanently invalidates the ability to manually execute failed, older messages, leading to a permanent locking of assets associated with those messages.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The resulting token lock makes the impact High, but since the core issue is a structural flaw in nonce implementation for retries, it's classified as Medium per the report. The reliance on sequential processing requires tighter control."
}

{
  "id": "gs_t1moh_laposte_M03",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "LaPoste Security Review",
  "source_finding_id": "[M-03]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/LaPoste-security-review-October.pdf",
  "github_repo_url": "https://github.com/stake-dao/laposte/tree/0bf0be29ea9d78aa147cc7a924a4c10dba262669",
  "contest_date": "2025-10-22",
  
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "receiveMessage() will revert when it runs out of gas",
  "finding_description": "The `LaPoste.receiveMessage()` function uses a `try/catch` block to handle external calls to the message receiver's contract (`IMessageReceiver(message.to).receiveMessage(...)`). However, Solidity's `try/catch` mechanism does **not** catch out-of-gas errors. If an attacker crafts a message to a malicious receiver contract that intentionally consumes all the remaining gas in the external call, the `LaPoste.receiveMessage()` function will revert entirely on an out-of-gas exception. Since CCIP operates in a strict, sequential manner, this reversion blocks all subsequent messages for that lane (source/destination chain pair) from being processed, causing a Denial of Service (DOS) and potentially locking all associated tokens.",
  "attack_scenario": "1. Attacker sends a message to the destination chain, targeting a custom contract designed to waste gas in its `receiveMessage` implementation.\n2. `LaPoste.receiveMessage` on the destination chain executes the external call.\n3. The external call runs out of gas, causing `LaPoste.receiveMessage` to revert (as the out-of-gas error is not caught).\n4. Due to CCIP's strict ordering, this reverts the entire transaction, and the nonce for this lane is not updated.\n5. All subsequent legitimate messages on this lane are blocked, leading to a DOS on cross-chain communication and permanent locking of tokens on the source chain.",
  "fix_description": "Add an `executionGasLimit` field to the `ILaposte.Message` struct. When making the external call, specify this gas limit using the `call` syntax: `try IMessageReceiver(message.to).{gas: message.executionGasLimit}receiveMessage(...)`. This ensures the external call runs with a constrained amount of gas, protecting the outer transaction from an attacker's gas exhaustion.",
  
  "primary_file": {
    "path": "LaPoste.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.19;\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// #########################################################\n/// #########################################################\n/// ##############################################################\n/// ####################################################################\n/// ##########################################################################################\n/// #######################################################\n/// ########################################################\n/// #############################################################\n/// ################################################################\n/// ####################################################################\n/// ####################################################################\n/// #################################################################\n/// ################################################################\n/// #################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// #####################################################\n/// #############################################################\n/// ###############################################################\n/// ####################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\n/// ##########################################################################################\nimport "src/interfaces/ILaPoste.sol";\nimport "src/interfaces/IAdapter.sol";\nimport "src/interfaces/ITokenFactory.sol";\nimport "src/interfaces/IMessageReceiver.sol";\nimport "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport "@openzeppelin/contracts/access/Ownable2Step.sol";\nimport "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\n/// @title LaPoste\n/// @notice A contract for cross-chain message passing and token transfers\n/// @author StakeDAO - @warrenception\n/// @dev This contract uses a single adapter for governance-controlled bridge interactions\ncontract LaPoste is Ownable2Step {\n    using SafeERC20 for IERC20;\n    /// @notice The address of the token factory\n    address public immutable tokenFactory;\n    /// @notice The address of the adapter\n    address public adapter;\n    /// @notice Nonce for sent messages, per chain\n    mapping(uint256 => uint256) public sentNonces;\n    /// @notice Nonce for received messages, per chain\n    mapping(uint256 => uint256) public receivedNonces;\n    /// @notice Thrown when the sender is not the adapter.\n    error OnlyAdapter();\n    /// @notice Thrown when no adapter is set.\n    error NoAdapterSet();\n    /// @notice Thrown when a message execution fails.\n    error ExecutionFailed();\n    /// @notice Thrown when a message is expired.\n    error ExpiredMessage();\n    /// @notice Thrown when a message has already been processed.\n    error MessageAlreadyProcessed();\n    /// @notice Thrown when a message is sent to the same chain.\n    error CannotSendToSelf();\n    event MessageSent(\n        uint256 indexed chainId, uint256 indexed nonce, address indexed sender, address to, ILaPoste.Message message\n    );\n    event MessageReceived(\n        uint256 indexed chainId,\n        uint256 indexed nonce,\n        address indexed sender,\n        address to,\n        ILaPoste.Message message,\n        bool success\n    );\n    /// @notice Ensures that only the adapter can call the function.\n    modifier onlyAdapter() {\n        if (msg.sender != adapter) revert OnlyAdapter();\n        _;\n    }\n    /// @notice Constructs the LaPoste contract.\n    /// @param _tokenFactory The address of the token factory.\n    constructor(address _tokenFactory, address _owner) {\n        tokenFactory = _tokenFactory;\n        _transferOwnership(_owner);\n    }\n    /// @notice Sends a message across chains\n    /// @param messageParams The message parameters\n    /// @dev This function is payable to cover cross-chain fees\n    function sendMessage(ILaPoste.MessageParams memory messageParams, uint256 additionalGasLimit) external payable {\n        if (adapter == address(0)) revert NoAdapterSet();\n        if (messageParams.destinationChainId == block.chainid) revert CannotSendToSelf();\n        /// 0. Initialize the message.\n        ILaPoste.Message memory message;\n        /// 1. Set the message fields.\n        message.destinationChainId = messageParams.destinationChainId;\n        message.to = messageParams.to;\n        message.sender = msg.sender;\n        message.payload = messageParams.payload;\n        /// 2. Set the nonce in the message\n        message.nonce = sentNonces[message.destinationChainId] + 1;\n        /// 3. Check if there's a token attached and mint it to the receiver.\n        if (messageParams.token.tokenAddress != address(0)) {\n            message.token = messageParams.token;\n            ITokenFactory(tokenFactory).burn(messageParams.token.tokenAddress, msg.sender, messageParams.token.amount);\n            (message.tokenMetadata.name, message.tokenMetadata.symbol, message.tokenMetadata.decimals) =\n                ITokenFactory(tokenFactory).getTokenMetadata(messageParams.token.tokenAddress);\n        }\n        (bool success,) = adapter.delegatecall(\n            abi.encodeWithSelector(\n                IAdapter.sendMessage.selector,\n                adapter,\n                additionalGasLimit,\n                message.destinationChainId,\n                abi.encode(message)\n            )\n        );\n        if (!success) revert ExecutionFailed();\n        // Increment the sent nonce for the specific chain after successful send\n        sentNonces[message.destinationChainId] = message.nonce;\n        emit MessageSent(message.destinationChainId, message.nonce, msg.sender, message.to, message);\n    }\n    /// @notice Receives a message from another chain\n    /// @param chainId The ID of the source chain\n    /// @param payload The encoded message payload\n    function receiveMessage(uint256 chainId, bytes calldata payload) external onlyAdapter {\n        ILaPoste.Message memory message = abi.decode(payload, (ILaPoste.Message));\n        // Check if the message has already been processed\n        if (message.nonce <= receivedNonces[chainId]) revert MessageAlreadyProcessed();\n        /// 1. Check if there's a token attached and release or mint it to the receiver.\n        if (message.token.tokenAddress != address(0) && message.token.amount > 0) {\n            ITokenFactory(tokenFactory).mint(\n                message.token.tokenAddress,\n                message.to,\n                message.token.amount,\n                message.tokenMetadata.name,\n                message.tokenMetadata.symbol,\n                message.tokenMetadata.decimals\n            );\n        }\n        /// 2. Execute the message.\n        bool success;\n        if (message.payload.length > 0) {\n            try IMessageReceiver(message.to).receiveMessage(chainId, message.sender, message.payload) {\n                success = true;\n            } catch {\n                success = false;\n            }\n        }\n        // 3. Update the received nonce for the specific chain\n        receivedNonces[chainId] = message.nonce;\n        emit MessageReceived(chainId, message.nonce, message.sender, message.to, message, success);\n    }\n    /// @notice Sets the adapter address\n    /// @param _adapter The address of the new adapter\n    /// @dev It should be updated on all chains.\n    function setAdapter(address _adapter) external onlyOwner {\n        adapter = _adapter;\n    }\n}",
    "vulnerable_lines": [5],
    "vulnerable_functions": ["receiveMessage"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker sends message to malicious receiver -> `LaPoste.receiveMessage` executes external call -> Malicious receiver wastes gas -> External call runs out of gas -> `LaPoste.receiveMessage` reverts entirely -> CCIP lane is DOSed.",
  "context_hint": "A critical gas-related DOS vector. By exploiting the limitation of Solidity's `try/catch` (it doesn't catch out-of-gas), an attacker can reliably cause the entire transaction to revert, halting all sequential messaging for that cross-chain lane and locking assets.",
  
  "is_vulnerable": true,
  
  "expert_notes": "High impact due to chain-wide DOS and permanent fund lock on the source chain. The fix is essential for robust cross-chain messaging and involves setting a ceiling on the gas supplied to external calls."
}

