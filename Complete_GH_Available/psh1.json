{
  "id": "gs_auditors_arcadia_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Arcadia Accounts V2 Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Arcadia-security-review-October.pdf",
  "github_repo_url": "https://github.com/arcadia-finance/accounts-v2/tree/08bc2a06dcc73ec13d326fe812179d865e3c67c5",
  "contest_date": "2025-10-24",
  
  "severity": "medium",
  "vulnerability_type": "incorrect_transfer_recipient",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "ETH withdrawn is sent to msg.sender instead of the to address",
  "finding_description": "In the AccountSpot contract, the `_withdraw` function does not use the `to` address as the recipient of the withdrawn funds in the case of an ETH withdrawal but instead uses `msg.sender` as the recipient. This removes the ability of the withdrawer to specify a different address to receive the funds and, what is more, can lead to the loss of funds if the caller is expecting the funds to be sent to the `to` address, as the NatSpec comment explicitly states that the `to` address is the recipient of the withdrawn funds.",
  "attack_scenario": "A user or contract calls the `_withdraw` function and specifies a custom recipient address in the `to` parameter (e.g., a cold wallet or a relayer contract). However, when withdrawing native ETH (`assetAddresses[i] == address(0)`), the function sends the ETH to `msg.sender` instead of the specified `to` address. This violates the documented behavior, potentially causing the calling contract to hold unexpected funds or the user to lose track of the assets if they were expecting them at the specified `to` address.",
  "fix_description": "Use the `to` address as the recipient of the withdrawn funds in the case of an ETH withdrawal. Change the vulnerable line from `payable(msg.sender).call{value: assetAmounts[i]}(\"\")` to `payable(to).call{value: assetAmounts[i]}(\"\")`. If the expected behavior is that funds can only be withdrawn to the caller, add a condition to check that `to == msg.sender` and revert otherwise.",
  
  "primary_file": {
    "path": "src/accounts/AccountSpot.sol",
    "content": "/**\n * Created by Pragma Labs\n * SPDX-License-Identifier: BUSL-1.1\n */\npragma solidity 0.8.22;\n\nimport { AccountErrors } from "../libraries/Errors.sol";\nimport { AccountStorageV1 } from "./AccountStorageV1.sol";\nimport { ActionData, IActionBase } from "../interfaces/IActionBase.sol";\nimport { ERC20, SafeTransferLib } from "../../lib/solmate/src/utils/SafeTransferLib.sol";\nimport { IAccount } from "../interfaces/IAccount.sol";\nimport { IERC721 } from "../interfaces/IERC721.sol";\nimport { IERC1155 } from "../interfaces/IERC1155.sol";\nimport { IPermit2 } from "../interfaces/IPermit2.sol";\n\n/**\n * @title Arcadia Spot Account\n * @author Pragma Labs\n * @notice Arcadia Spot Accounts enables individuals, DAOs, and other protocols to deposit and manage a variety of assets easily through Asset Managers.\n * Asset Managers are selected by Spot Account holders and can facilitate automation for tasks such as Liquidity Management and Compounding, among others.\n */\ncontract AccountSpot is AccountStorageV1, IAccount {\n    using SafeTransferLib for ERC20;\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTANTS\n    ////////////////////////////////////////////////////////////// */\n\n    // The current Account Version.\n    uint256 public constant ACCOUNT_VERSION = 2;\n    // The cool-down period after an account action, that might be disadvantageous for a new Owner,\n    // during which ownership cannot be transferred to prevent the old Owner from frontrunning a transferFrom().\n    uint256 public constant COOL_DOWN_PERIOD = 5 minutes;\n    // Storage slot with the address of the current implementation.\n    // This is the hardcoded keccak-256 hash of: "eip1967.proxy.implementation" subtracted by 1.\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    // The contract address of the Arcadia Accounts Factory.\n    address public immutable FACTORY;\n    // Uniswap Permit2 contract\n    IPermit2 internal immutable PERMIT2 = IPermit2(0x000000000022D473030F116dDEE9F6B43aC78BA3);\n\n    // Storage slot for the Account implementation, a struct to avoid storage conflict when dealing with upgradeable contracts.\n    struct AddressSlot {\n        address value;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                EVENTS\n    ////////////////////////////////////////////////////////////// */\n\n    event AssetManagerSet(address indexed owner, address indexed assetManager, bool value);\n\n    /* //////////////////////////////////////////////////////////////\n                                MODIFIERS\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @dev Throws if function is reentered.\n     */\n    modifier nonReentrant() {\n        if (locked != 1) revert AccountErrors.NoReentry();\n        locked = 2;\n        _;\n        locked = 1;\n    }\n\n    /**\n     * @dev Throws if called by any address other than an Asset Manager or the owner.\n     */\n    modifier onlyAssetManager() {\n        // A custom error would need to read out owner + isAssetManager storage\n        require(msg.sender == owner || isAssetManager[owner][msg.sender], "A: Only Asset Manager");\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the Factory address.\n     */\n    modifier onlyFactory() {\n        if (msg.sender != FACTORY) revert AccountErrors.OnlyFactory();\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any address other than the owner.\n     */\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert AccountErrors.OnlyOwner();\n        _;\n    }\n\n    /**\n     * @dev Starts the cool-down period during which ownership cannot be transferred.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    modifier updateActionTimestamp() {\n        lastActionTimestamp = uint32(block.timestamp);\n        _;\n    }\n\n    /* //////////////////////////////////////////////////////////////\n                                CONSTRUCTOR\n    ////////////////////////////////////////////////////////////// */\n\n    /**\n     * @param factory The contract address of the Arcadia Accounts Factory.\n     */\n    constructor(address factory) {\n        // This will only be the owner of the Account implementation.\n        // and will not affect any subsequent proxy implementation using this Account implementation.\n        owner = msg.sender;\n\n        FACTORY = factory;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                          ACCOUNT MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Initiates the variables of the Account.\n     * @param owner_ The sender of the 'createAccount' on the Factory\n     * @param registry_ The 'beacon' contract with the external logic to price assets.\n     * @dev A proxy will be used to interact with the Account implementation.\n     * This function will only be called (once) in the same transaction as the proxy Account creation through the Factory.\n     * @dev initialize has implicitly a nonReentrant guard, since the "locked" variable has value zero until the end of the function.\n     * @dev The Registry is not used in spot accounts, but a valid registry must be set to be compatible with V1 Accounts.\n     */\n    function initialize(address owner_, address registry_, address) external onlyFactory {\n        if (registry_ == address(0)) revert AccountErrors.InvalidRegistry();\n        owner = owner_;\n        registry = registry_;\n\n        locked = 1;\n    }\n\n    /**\n     * @notice Upgrades the Account version and stores a new address in the EIP1967 implementation slot.\n     * @param newImplementation The new contract address of the Account implementation.\n     * @param newRegistry The Registry for this specific newImplementation.\n     * @param data Arbitrary data, can contain instructions to execute when updating Account to new implementation.\n     * @dev This function MUST be added to new Account implementations.\n     */\n    function upgradeAccount(address newImplementation, address newRegistry, uint256, bytes calldata data)\n        external\n        onlyFactory\n        nonReentrant\n        updateActionTimestamp\n    {\n        // Cache old parameters.\n        address oldImplementation = _getAddressSlot(IMPLEMENTATION_SLOT).value;\n        uint256 oldVersion = ACCOUNT_VERSION;\n\n        // Store new parameters.\n        _getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n        registry = newRegistry;\n\n        // Hook on the new logic to finalize upgrade.\n        // Used to eg. Remove exposure from old Registry and add exposure to the new Registry.\n        // Extra data can be added by the Factory for complex instructions.\n        this.upgradeHook(oldImplementation, address(0), oldVersion, data);\n\n        // Event emitted by Factory.\n    }\n\n    /**\n     * @notice Returns the "AddressSlot" with member "value" located at "slot".\n     * @param slot The slot where the address of the Logic contract is stored.\n     * @return r The address stored in slot.\n     */\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @notice Finalizes the Upgrade from a different Account version to this version.\n     * param oldImplementation The old contract address of the Account implementation.\n     * param oldRegistry The Registry of the old version (might be identical to the new registry)\n     * param oldVersion The old version of the Account implementation.\n     * param data Arbitrary data, can contain instructions to execute in this function.\n     * @dev If upgradeHook() is implemented, it MUST verify that msg.sender == address(this).\n     * @dev We delete the deprecated AccountStorageV1 variables.\n     */\n    function upgradeHook(address, address, uint256, bytes calldata) external {\n        if (msg.sender != address(this)) revert AccountErrors.OnlySelf();\n        if (registry == address(0)) revert AccountErrors.InvalidRegistry();\n\n        // Require that no creditor is set and no auctions are ongoing.\n        // (This should always be enforced in the old Version we upgrade from, but we do a redundant safety check).\n        if (creditor != address(0) || inAuction) revert AccountErrors.InvalidUpgrade();\n\n        // Delete margin account related storage data (should normally already be empty).\n        delete liquidator;\n        delete minimumMargin;\n        delete numeraire;\n\n        // Delete asset related storage data.\n        uint256 erc20StoredLength = erc20Stored.length;\n        for (uint256 i = 0; i < erc20StoredLength; ++i) {\n            delete erc20Balances[erc20Stored[i]];\n        }\n        delete erc20Stored;\n\n        delete erc721Stored;\n        delete erc721TokenIds;\n\n        uint256 erc1155StoredLength = erc1155Stored.length;\n        for (uint256 j = 0; j < erc1155StoredLength; ++j) {\n            delete erc1155Balances[erc1155Stored[j]][erc1155TokenIds[j]];\n        }\n        delete erc1155Stored;\n        delete erc1155TokenIds;\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        OWNERSHIP MANAGEMENT\n    /////////////////////////////////////////////////////////////// */\n\n    /**\n     * @notice Transfers ownership of the contract to a new Account.\n     * @param newOwner The new owner of the Account.\n     * @dev Can only be called by the current owner via the Factory.\n     * A transfer of ownership of the Account is triggered by a transfer\n     * of ownership of the accompanying ERC721 Account NFT, issued by the Factory.\n     * Owner of Account NFT = owner of Account\n     * @dev Function uses a cool-down period during which ownership cannot be transferred.\n     * Cool-down period is triggered after any account action, that might be disadvantageous for a new Owner.\n     * This prevents the old Owner from frontrunning a transferFrom().\n     */\n    function transferOwnership(address newOwner) external onlyFactory {\n        if (block.timestamp <= lastActionTimestamp + COOL_DOWN_PERIOD) revert AccountErrors.CoolDownPeriodNotPassed();\n\n        // The Factory will check that the new owner is not address(0).\n        owner = newOwner;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       ASSET MANAGER ACTIONS\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Add or remove an Asset Manager.\n     * @param assetManager The address of the Asset Manager.\n     * @param value A boolean giving permissions to or taking permissions from an Asset Manager.\n     * @dev Only set trusted addresses as Asset Manager. Asset Managers have full control over assets in the Account.\n     * @dev No need to set the Owner as Asset Manager as they will automatically have all permissions of an Asset Manager.\n     * @dev Potential use-cases of the Asset Manager might be to:\n     * - Liquidity Management.\n     * - Do flash actions (optimistic actions).\n     * - Compounding.\n     * - Chain multiple interactions together.\n     * @dev Anyone can set the Asset Manager for themselves, this will not impact the current owner of the Account\n     * since the combination of "stored owner -> asset manager" is used in authentication checks.\n     * This guarantees that when the ownership of the Account is transferred, the asset managers of the old owner have no\n     * impact on the new owner. But the new owner can still remove any existing asset managers before the transfer.\n     */\n    function setAssetManager(address assetManager, bool value) external {\n        emit AssetManagerSet(msg.sender, assetManager, isAssetManager[msg.sender][assetManager] = value);\n    }\n\n    /**\n     * @notice Executes a flash action.\n     * @param actionTarget The contract address of the actionTarget to execute external logic.\n     * @param actionData A bytes object containing three structs and two bytes objects.\n     * The first struct contains the info about the assets to withdraw from this Account to the actionTarget.\n     * The second struct contains the info about the owner's assets that need to be transferred from the owner to the actionTarget.\n     * The third struct contains the permit for the Permit2 transfer.\n     * The first bytes object contains the signature for the Permit2 transfer.\n     * The second bytes object contains the encoded input for the actionTarget.\n     * @dev This function optimistically chains multiple actions together (= do a flash action):\n     * - It can optimistically withdraw assets from the Account to the actionTarget.\n     * - It can transfer assets directly from the owner to the actionTarget.\n     * - It can execute external logic on the actionTarget, and interact with any DeFi protocol to swap, stake, claim...\n     * - It can deposit all recipient tokens from the actionTarget back into the Account.\n     */\n    function flashAction(address actionTarget, bytes calldata actionData)\n        external\n        payable\n        onlyAssetManager\n        nonReentrant\n        updateActionTimestamp\n    {\n        // Decode flash action data.\n        (\n            ActionData memory withdrawData,\n            ActionData memory transferFromOwnerData,\n            IPermit2.PermitBatchTransferFrom memory permit,\n            bytes memory signature,\n            bytes memory actionTargetData\n        ) = abi.decode(actionData, (ActionData, ActionData, IPermit2.PermitBatchTransferFrom, bytes, bytes));\n\n        // Withdraw assets to the actionTarget.\n        _withdraw(\n            withdrawData.assets, withdrawData.assetIds, withdrawData.assetAmounts, withdrawData.assetTypes, actionTarget\n        );\n\n        // Transfer assets from owner (that are not assets in this account) to the actionTarget.\n        if (transferFromOwnerData.assets.length > 0) {\n            _transferFromOwner(transferFromOwnerData, actionTarget);\n        }\n\n        // If the function input includes a signature and non-empty token permissions,\n        // initiate a transfer from the owner to the actionTarget via Permit2.\n        if (signature.length > 0 && permit.permitted.length > 0) {\n            _transferFromOwnerWithPermit(permit, signature, actionTarget);\n        }\n\n        // Execute external logic on the actionTarget.\n        ActionData memory depositData = IActionBase(actionTarget).executeAction(actionTargetData);\n\n        // Deposit assets from actionTarget into Account.\n        _deposit(\n            depositData.assets, depositData.assetIds, depositData.assetAmounts, depositData.assetTypes, actionTarget\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                          ASSET MANAGEMENT\n    ///////////////////////////////////////////////////////////////*/\n\n    /**\n     * @notice Deposits assets into the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     */\n    function deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes\n    ) external payable onlyOwner nonReentrant {\n        _deposit(assetAddresses, assetIds, assetAmounts, assetTypes, msg.sender);\n    }\n\n    /**\n     * @notice Deposits assets into the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     * @param from The assets deposited into the Account will come from this address.\n     */\n    function _deposit(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes,\n        address from\n    ) internal {\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent transferring addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetTypes[i] == 1) {\n                ERC20(assetAddresses[i]).safeTransferFrom(from, address(this), assetAmounts[i]);\n            } else if (assetTypes[i] == 2) {\n                IERC721(assetAddresses[i]).safeTransferFrom(from, address(this), assetIds[i]);\n            } else if (assetTypes[i] == 3) {\n                IERC1155(assetAddresses[i]).safeTransferFrom(from, address(this), assetIds[i], assetAmounts[i], "");\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Withdraws assets from the Account to the owner.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     */\n    function withdraw(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes\n    ) public onlyOwner nonReentrant updateActionTimestamp {\n        _withdraw(assetAddresses, assetIds, assetAmounts, assetTypes, msg.sender);\n    }\n\n    /**\n     * @notice Withdraws assets from the Account.\n     * @param assetAddresses Array of the contract addresses of the assets.\n     * @param assetIds Array of the IDs of the assets.\n     * @param assetAmounts Array with the amounts of the assets.\n     * @param assetTypes Array of the asset types.\n     * @param to The address to withdraw to.\n     */\n    function _withdraw(\n        address[] memory assetAddresses,\n        uint256[] memory assetIds,\n        uint256[] memory assetAmounts,\n        uint256[] memory assetTypes,\n        address to\n    ) internal {\n        for (uint256 i; i < assetAddresses.length; ++i) {\n            // Skip if amount is 0 to prevent transferring addresses that have 0 balance.\n            if (assetAmounts[i] == 0) continue;\n\n            if (assetAddresses[i] == address(0)) {\n                (bool success, bytes memory result) = payable(msg.sender).call{ value: assetAmounts[i] }("");\n                require(success, string(result));\n            } else if (assetTypes[i] == 1) {\n                ERC20(assetAddresses[i]).safeTransfer(to, assetAmounts[i]);\n            } else if (assetTypes[i] == 2) {\n                IERC721(assetAddresses[i]).safeTransferFrom(address(this), to, assetIds[i]);\n            } else if (assetTypes[i] == 3) {\n                IERC1155(assetAddresses[i]).safeTransferFrom(address(this), to, assetIds[i], assetAmounts[i], "");\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers assets directly from the owner to the actionTarget contract.\n     * @param transferFromOwnerData A struct containing the info of all assets transferred from the owner that are not in this account.\n     * @param to The address to withdraw to.\n     */\n    function _transferFromOwner(ActionData memory transferFromOwnerData, address to) internal {\n        uint256 assetAddressesLength = transferFromOwnerData.assets.length;\n        address owner_ = owner;\n        for (uint256 i; i < assetAddressesLength; ++i) {\n            // Skip if amount is 0 to prevent transferring 0 balances.\n            if (transferFromOwnerData.assetAmounts[i] == 0) continue;\n\n            if (transferFromOwnerData.assetTypes[i] == 1) {\n                ERC20(transferFromOwnerData.assets[i]).safeTransferFrom(\n                    owner_, to, transferFromOwnerData.assetAmounts[i]\n                );\n            } else if (transferFromOwnerData.assetTypes[i] == 2) {\n                IERC721(transferFromOwnerData.assets[i]).safeTransferFrom(owner_, to, transferFromOwnerData.assetIds[i]);\n            } else if (transferFromOwnerData.assetTypes[i] == 3) {\n                IERC1155(transferFromOwnerData.assets[i]).safeTransferFrom(\n                    owner_, to, transferFromOwnerData.assetIds[i], transferFromOwnerData.assetAmounts[i], ""\n                );\n            } else {\n                revert AccountErrors.UnknownAssetType();\n            }\n        }\n    }\n\n    /**\n     * @notice Transfers assets from the owner to the actionTarget contract via Permit2.\n     * @param permit Data specifying the terms of the transfer.\n     * @param signature The signature to verify.\n     * @param to_ The address to withdraw to.\n     */\n    function _transferFromOwnerWithPermit(\n        IPermit2.PermitBatchTransferFrom memory permit,\n        bytes memory signature,\n        address to_\n    ) internal {\n        uint256 tokenPermissionsLength = permit.permitted.length;\n        IPermit2.SignatureTransferDetails[] memory transferDetails =\n            new IPermit2.SignatureTransferDetails[](tokenPermissionsLength);\n\n        for (uint256 i; i < tokenPermissionsLength; ++i) {\n            transferDetails[i].to = to_;\n            transferDetails[i].requestedAmount = permit.permitted[i].amount;\n        }\n\n        PERMIT2.permitTransferFrom(permit, transferDetails, owner, signature);\n    }\n\n    /* ///////////////////////////////////////////////////////////////\n                        HELPER FUNCTIONS\n    /////////////////////////////////////////////////////////////// */\n\n    /* \n    @notice Returns the onERC721Received selector.\n    @dev Needed to receive ERC721 tokens.\n    */\n    function onERC721Received(address, address, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /*\n    @notice Returns the onERC1155Received selector.\n    @dev Needed to receive ERC1155 tokens.\n    */\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) public pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /*\n    @notice Called when function selector doesn't match any other.\n    @dev No fallback allowed.\n    */\n    fallback() external {\n        revert AccountErrors.NoFallback();\n    }\n\n    /*\n    @notice Called on a plain ETH transfer.\n    */\n    receive() external payable { }\n}",
    "vulnerable_lines": [31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53],
    "vulnerable_functions": ["_withdraw"]
  },
  
  "context_files": [],
  
  "call_flow": "User calls public withdraw function -> Internal call to `_withdraw(..., to)` -> Inside loop, when `assetAddresses[i] == address(0)` (for ETH) -> Execution of `payable(msg.sender).call{value: amount}(\"\")` -> ETH is sent to `msg.sender` instead of the `to` parameter.",
  "context_hint": "A logic error where the code for native ETH withdrawal uses `msg.sender` as the recipient of the funds, despite the function signature and NatSpec comment explicitly defining a separate `to` address parameter. The code for ERC20/ERC721/ERC1155 correctly uses the `to` parameter.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The vulnerability is a direct contradiction between the function's documentation (`@param to The address to withdraw to`) and its implementation (`payable(msg.sender).call{...}`). This is a high-impact logic bug for users expecting to be able to withdraw to an arbitrary address."
}

{
  "id": "gs_pashov_bunni_C01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "arbitrary_token_claim",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "claimRecurPool does not verify the provided incentiveToken is equal to rewardToken",
  "finding_description": "When the `claimRecurPool` function is called, it iterates through the claims but does not verify that the `incentiveToken` provided in the `RecurClaimParams` is equal to the `rewardToken` associated with the claimed `RecurPoolKey`. This allows an attacker to claim rewards denominated in one token but receive a different, possibly more valuable, token.",
  "attack_scenario": "1. Attacker creates a fake Recur Pool with an arbitrary/worthless reward token but provides a high `rewardRate`.\n2. When calling `claimRecurPool`, the attacker uses the ID of their fake pool but sets the `incentiveToken` parameter to the address of a valuable token (e.g., WETH, or a core protocol token) that is held by the `MasterBunni` contract (e.g., from a genuine pool).\n3. The reward amount is calculated based on the fake pool's high rate, and this high amount of the valuable token is transferred to the recipient, effectively stealing funds from the contract's overall balance.",
  "fix_description": "Validate that the provided `incentiveToken` (from `params[i].incentiveToken`) is equal to the `rewardToken` of each `RecurPoolKey` being processed within the loop.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [11],
    "vulnerable_functions": ["claimRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.claimRecurPool(fakePoolKey, recipient) -> MasterBunni calculates reward for fakePoolKey (which uses rewardToken A) -> MasterBunni transfers `totalClaimableAmount` of `incentiveToken B` (specified by attacker) to recipient. Token B is stolen.",
  "context_hint": "The claim function relies on a user-provided `incentiveToken` parameter for the final transfer, rather than enforcing that the `incentiveToken` matches the `rewardToken` determined by the `RecurPoolKey`. This decouples the reward calculation from the token being paid out, leading to critical asset theft.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A very high-impact logic error allowing asset drain via a token substitution attack. Crucial state integrity check is missing."
}

{
  "id": "gs_pashov_bunni_C02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "inconsistent_state_update",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "incentiveToken is not verified within incentivizeRecurPool",
  "finding_description": "The `incentivizeRecurPool` function allows a user to update the `state.rewardRate` for a pool using an arbitrary `incentiveToken` provided as an argument, without verifying that this token matches the pool's actual `rewardToken` (which is part of the `RecurPoolKey`). This allows a malicious actor to deposit a worthless token while increasing the reward rate for the pool's legitimate reward token.",
  "attack_scenario": "1. A legitimate pool exists where `rewardToken` is WETH.\n2. An attacker calls `incentivizeRecurPool` for this pool, providing a large `incentiveAmount` and setting `incentiveToken` to a worthless token (e.g., AttackerToken).\n3. The reward rate for the WETH pool is updated based on the large amount.\n4. The function executes a `safeTransferFrom` of the worthless AttackerToken, which successfully transfers the token to the contract.\n5. Legitimate users see a high reward rate for WETH, but when they try to claim, the contract quickly runs out of WETH (the actual reward token), or the pool accounting is permanently ruined because the reward token stored in the contract is useless (AttackerToken) but the promised reward is WETH.",
  "fix_description": "Validate that the `incentiveToken` parameter is equal to the `rewardToken` associated with the `RecurPoolKey` within the `incentivizeRecurPool` function.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [47],
    "vulnerable_functions": ["incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.incentivizeRecurPool(validPoolKey, AttackerToken) -> MasterBunni updates the rewardRate state for the pool's actual rewardToken (e.g., WETH) -> MasterBunni transfers AttackerToken into the contract (the WETH reward is now under-collateralized/unclaimable).",
  "context_hint": "The function calculates the reward rate update based on the pool's configuration (which implies a `rewardToken`), but accepts a separate, unvalidated `incentiveToken` parameter for the token transfer itself, allowing the attacker to increase the effective reward rate of a valuable token by depositing a worthless one.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Similar to C-01, this is a critical integrity check failure leading to corrupted reward state and potential denial of service or asset loss for LPs relying on the correct reward mechanism."
}

{
  "id": "gs_pashov_bunni_C03",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[C-03]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "critical",
  "vulnerability_type": "reward_loss_logic",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "Previous rewardRate is removed when periodFinish has not yet been reached",
  "finding_description": "In `incentivizeRecurPool`, when adding a new incentive while the current reward period (`periodFinish`) is still active, the new reward rate (`newRewardRate`) is calculated and then assigned directly to `state.rewardRate` instead of being added to the existing `state.rewardRate`. This overwrites and effectively removes the previous incentive provider's reward rate, causing their provided reward amount to be lost/unclaimable.",
  "attack_scenario": "1. User A provides an incentive for 30 days, setting a high `state.rewardRate`.\n2. Before the 30 days are up, User B calls `incentivizeRecurPool` with a new, smaller incentive amount.\n3. The code calculates the `newRewardRate` based only on User B's incentive and the remaining duration.\n4. This calculated `newRewardRate` (B) is assigned to `state.rewardRate`, overwriting the previous, higher `state.rewardRate` (A).\n5. LPs who staked for User A's incentive will receive significantly fewer rewards than promised for the remainder of the period, as the reward rate has been artificially lowered by the overwrite. User A's funds are essentially locked or permanently lost due to the incorrect accounting.",
  "fix_description": "When the current period is still active (`block.timestamp < periodFinish`), the calculated `newRewardRate` (based on the new deposit) must be added to the existing `state.rewardRate`. The fix is changing `state.rewardRate = newRewardRate;` to `state.rewardRate += newRewardRate;` in the `else` block.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [28],
    "vulnerable_functions": ["incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "User A calls incentivizeRecurPool (Period Active) -> User B calls incentivizeRecurPool (Period Active) -> MasterBunni calculates B's `newRewardRate` -> MasterBunni sets `state.rewardRate = newRewardRate` (overwrites A's contribution) -> A's funds are effectively locked/lost.",
  "context_hint": "A fundamental accounting error in managing concurrent incentives. By assigning the newly calculated rate instead of adding it, the pool's reward state is reset, causing rewards promised by previous depositors to be canceled for the remainder of the period.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a direct economic exploit that steals or locks existing incentive providers' funds, causing material loss and breaking trust in the staking mechanism. Easily fixable by changing assignment to addition."
}

{
  "id": "gs_pashov_bunni_H01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[H-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "high",
  "vulnerability_type": "denial_of_unstake",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "joinRecurPool can incorrectly increment userPoolCounts",
  "finding_description": "The `joinRecurPool` function incorrectly increments `userPoolCounts[msgSender][key.stakeToken]` even when the user is only updating their staked balance (i.e., not the first time joining the pool). Since `userPoolCounts` is designed to track the number of distinct pools a user has joined for a specific stake token, its inflation will prevent users from successfully calling the unlock mechanism (which relies on this counter decreasing to zero for the final unlock), leading to a permanent denial of unstake for the affected tokens.",
  "attack_scenario": "1. User A joins a Recur Pool (Pool 1) with Stake Token X. `userPoolCounts[A][X]` becomes 1.\n2. User A later increases their balance of Stake Token X and calls `joinRecurPool` again for Pool 1 (to update their staked amount).\n3. The code incorrectly executes `++userPoolCounts[A][X]`, making the counter 2.\n4. When User A exits all pools, the unlock function will attempt to decrement this counter, but it will never reach zero, permanently locking User A's Stake Token X.",
  "fix_description": "Increment `userPoolCounts` only if the previous staked balance (`stakedBalance`) was zero, indicating the user is joining the pool for the first time. Add a check: `if (stakedBalance == 0) { ++userPoolCounts[msgSender][key.stakeToken]; }`.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [23],
    "vulnerable_functions": ["joinRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "User calls `joinRecurPool` second time (to update stake) -> `stakedBalance > 0` -> `++userPoolCounts` executes redundantly -> Counter becomes $> 1$ for a single pool -> Token unlock mechanism fails.",
  "context_hint": "A state accounting error tied to a core component (`userPoolCounts`) used for token locking/unlocking. Over-incrementing this counter prevents the user from ever fully unlocking their token, leading to permanent asset loss.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This is a severe vulnerability as it locks user funds. The fix requires checking the prior state (`stakedBalance == 0`) before incrementing the pool count."
}

{
  "id": "gs_pashov_bunni_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "transfer_logic_bypass",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "depositIncentive and incentivizeRecurPool do not verify if the incentiveToken exists",
  "finding_description": "Both `depositIncentive` (for RushPools) and `incentivizeRecurPool` (for RecurPools) use a version of Solady's `safeTransferFrom2` which does not check the code size of the `incentiveToken` address before performing the transfer call. In Solidity's assembly, if there is no return data (which happens when calling a non-contract address), the call is treated as successful. This allows an attacker to provide a non-contract address as the `incentiveToken` and proceed with updating the reward accounting state without actually transferring any tokens, or use a predictable address of a token that is yet to be created.",
  "attack_scenario": "1. An attacker determines the predictable future address of a legitimate Bunni LP token (Token X).\n2. The attacker calls `incentivizeRecurPool`, using the address of the uncreated Token X and providing a huge fake `incentiveAmount`.\n3. The `safeTransferFrom2` call to the uncreated address is treated as successful due to the lack of code size check, and no actual tokens are transferred to the protocol.\n4. The reward accounting state is updated based on the huge fake incentive, immediately disrupting the pool's reward rate and potentially leading to a permanent locking of real rewards deposited later.",
  "fix_description": "Upgrade the protocol to use the latest version of Solady's SafeTransferLib, which includes a code size check for contract addresses during transfers, or manually implement a code size check (`address(incentiveToken).code.length > 0`) before initiating the transfer.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["depositIncentive", "incentivizeRecurPool"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.depositIncentive(..., uncreatedTokenAddress) -> MasterBunni calls `uncreatedTokenAddress.safeTransferFrom2(...)` -> Solady's underlying assembly accepts the transfer as successful (due to no return data from non-contract) -> Reward state is corrupted without deposit.",
  "context_hint": "An issue stemming from reliance on a vulnerable/outdated external library implementation (`SafeTransferLib`). This allows attackers to manipulate reward accounting state using fake deposits to non-existent contract addresses, leading to reward corruption/disruption.",
  
  "is_vulnerable": true,
  
  "expert_notes": "While the impact can be high (reward corruption), the likelihood depends on the attacker's ability to predict addresses (Medium/Low), hence the Medium severity. The core issue is the missing code size check for the token address."
}

{
  "id": "gs_pashov_bunni_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "denial_of_service",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "DOS Attack in joinRushPool",
  "finding_description": "The `joinRushPool` function allows users to stake tokens up to a maximum cap. However, the lack of time restrictions (such as a minimum stake duration or an unstaking delay) allows malicious actors to perform a sandwich attack, repeatedly front-running and back-running legitimate users' stake transactions to keep the pool permanently full.",
  "attack_scenario": "1. Attacker observes a pending transaction where a legitimate user attempts to call `joinRushPool`.\n2. **Front-run:** Attacker calls `joinRushPool` to fill the pool up to its stake cap.\n3. Victim's transaction fails because the pool capacity is zero.\n4. **Back-run:** Attacker immediately calls `exitRushPool` to withdraw their stake, emptying the pool for the next opportunity.\n5. The attacker can repeat this process indefinitely, preventing legitimate users from ever staking, costing only the gas fees for the sandwich transactions.",
  "fix_description": "It is recommended to implement an anti-sandwich measure, such as a minimum stake duration or an unstaking delay, to increase the cost and reduce the profitability of this DOS attack.",
  
  "primary_file": {
    "path": "contracts/MasterBunni.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.4;\n\nimport {LibMulticaller} from "multicaller/LibMulticaller.sol";\n\nimport {ERC20} from "solady/tokens/ERC20.sol";\nimport {SafeTransferLib} from "solady/utils/SafeTransferLib.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport {RushPoolId} from "./types/RushPoolId.sol";\nimport {RushPoolKey} from "./types/RushPoolKey.sol";\nimport {RecurPoolId} from "./types/RecurPoolId.sol";\nimport {RecurPoolKey} from "./types/RecurPoolKey.sol";\nimport {ReentrancyGuard} from "./lib/ReentrancyGuard.sol";\nimport {IMasterBunni} from "./interfaces/IMasterBunni.sol";\nimport {IERC20Unlocker} from "./external/IERC20Unlocker.sol";\nimport {IERC20Lockable} from "./external/IERC20Lockable.sol";\n\ncontract MasterBunni is IMasterBunni, ReentrancyGuard {\n    using FixedPointMathLib for *;\n    using SafeTransferLib for address;\n\n    uint256 internal constant PRECISION = 1e36;\n    uint256 internal constant REWARD_RATE_PRECISION = 1e6;\n    uint256 internal constant PRECISION_DIV_REWARD_RATE_PRECISION = PRECISION / REWARD_RATE_PRECISION;\n\n    mapping(address user => mapping(IERC20Lockable stakeToken => uint256)) public userPoolCounts;\n\n    mapping(RushPoolId id => RushStakeState) public rushPoolStates;\n    mapping(RushPoolId id => mapping(address incentiveToken => uint256)) public rushPoolIncentiveAmounts;\n    mapping(RushPoolId id => mapping(address incentiveToken => mapping(address depositor => uint256))) public\n        rushPoolIncentiveDeposits;\n    mapping(RushPoolId id => mapping(address user => RushStakeState)) public rushPoolUserStates;\n    mapping(RushPoolId id => mapping(address user => mapping(address incentiveToken => uint256))) public\n        rushPoolUserRewardPaid;\n\n    mapping(RecurPoolId id => RecurPoolState) public recurPoolStates;\n\n    /// -----------------------------------------------------------------------\n    /// Incentivizer actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function depositIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // record incentive in each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up incentive amount\n            totalIncentiveAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // add incentive to pool\n            rushPoolIncentiveAmounts[id][incentiveToken] += params[i].incentiveAmount;\n\n            // add incentive to depositor\n            rushPoolIncentiveDeposits[id][incentiveToken][recipient] += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit DepositIncentive(msgSender, incentiveToken, recipient, params, totalIncentiveAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function withdrawIncentive(RushIncentiveParams[] calldata params, address incentiveToken, address recipient)\n        external\n        nonReentrant\n        returns (uint256 totalWithdrawnAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        // subtract incentive tokens from each pool\n        for (uint256 i; i < params.length; i++) {\n            if (!isValidRushPoolKey(params[i].key) || block.timestamp >= params[i].key.startTimestamp) {\n                // key is invalid or program is already active, skip\n                continue;\n            }\n\n            // sum up withdrawn amount\n            totalWithdrawnAmount += params[i].incentiveAmount;\n\n            RushPoolId id = params[i].key.toId();\n\n            // subtract incentive from pool\n            rushPoolIncentiveAmounts[id][incentiveToken] -= params[i].incentiveAmount;\n\n            // subtract incentive from sender\n            rushPoolIncentiveDeposits[id][incentiveToken][msgSender] -= params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens to recipient\n        if (totalWithdrawnAmount != 0) {\n            incentiveToken.safeTransfer(recipient, totalWithdrawnAmount);\n        }\n\n        // emit event\n        emit WithdrawIncentive(msgSender, incentiveToken, recipient, params, totalWithdrawnAmount);\n    }\n\n    /// @inheritdoc IMasterBunni\n    function refundIncentive(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalRefundAmount;\n            for (uint256 j; j < params[i].keys.length; j++) {\n                // the program should be over\n                RushPoolKey calldata key = params[i].keys[j];\n                if (!isValidRushPoolKey(key) || block.timestamp <= key.startTimestamp + key.programLength) {\n                    continue;\n                }\n\n                // load state\n                RushPoolId id = key.toId();\n                RushStakeState memory poolState = rushPoolStates[id];\n                uint256 incentiveAmount = rushPoolIncentiveDeposits[id][incentiveToken][msgSender]; // the incentives added by msgSender\n                if (incentiveAmount == 0) {\n                    continue;\n                }\n\n                // compute refund amount\n                // refund amount is the provided incentive amount minus the reward paid to stakers\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 refundAmount = incentiveAmount - rewardAccrued;\n\n                // delete incentive deposit to mark the incentive as refunded\n                delete rushPoolIncentiveDeposits[id][incentiveToken][msgSender];\n\n                // accumulate refund amount\n                totalRefundAmount += refundAmount;\n            }\n\n            // transfer refund amount to recipient\n            if (totalRefundAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalRefundAmount);\n            }\n\n            // emit event\n            emit RefundIncentive(msgSender, incentiveToken, recipient, totalRefundAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function incentivizeRecurPool(RecurIncentiveParams[] calldata params, address incentiveToken)\n        external\n        returns (uint256 totalIncentiveAmount)\n    {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            if (params[i].incentiveAmount == 0) continue;\n\n            RecurPoolKey calldata key = params[i].key;\n            if (!isValidRecurPoolKey(key)) continue;\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint256 rewardRate = state.rewardRate;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = _rewardPerToken(\n                state.rewardPerTokenStored, state.totalSupply, lastTimeRewardApplicable, lastUpdateTime, rewardRate\n            );\n\n            // record new reward\n            uint256 newRewardRate;\n            if (block.timestamp >= periodFinish) {\n                // current period is over\n                newRewardRate = params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, key.duration);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n                state.periodFinish = uint64(block.timestamp + key.duration);\n            } else {\n                // period is still active\n                // add the new reward to the existing period\n                uint256 remaining = periodFinish - block.timestamp;\n                newRewardRate += params[i].incentiveAmount.mulDiv(REWARD_RATE_PRECISION, remaining);\n\n                state.rewardRate = newRewardRate;\n                state.lastUpdateTime = uint64(block.timestamp);\n            }\n            // prevent overflow when computing rewardPerToken\n            if (newRewardRate >= ((type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION) / key.duration)) {\n                revert MasterBunni__AmountTooLarge();\n            }\n\n            totalIncentiveAmount += params[i].incentiveAmount;\n        }\n\n        // transfer incentive tokens from msgSender to this contract\n        if (totalIncentiveAmount != 0) {\n            incentiveToken.safeTransferFrom2(msgSender, address(this), totalIncentiveAmount);\n        }\n\n        // emit event\n        emit IncentivizeRecurPool(msgSender, incentiveToken, params, totalIncentiveAmount);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Staker actions\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function joinRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // pool needs to be active\n            if (\n                !isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp\n                    || block.timestamp > keys[i].startTimestamp + keys[i].programLength\n            ) {\n                continue;\n            }\n\n            // msgSender should be locked with address(this) as the unlocker\n            if (\n                !keys[i].stakeToken.isLocked(msgSender)\n                    || keys[i].stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 remainderStakeAmount = poolState.stakeAmount - userState.stakeAmount; // stake in pool minus the user's existing stake\n            uint256 stakeAmountUpdated;\n            {\n                uint256 balance = ERC20(address(keys[i].stakeToken)).balanceOf(msgSender);\n                stakeAmountUpdated = remainderStakeAmount + balance > keys[i].stakeCap\n                    ? keys[i].stakeCap - remainderStakeAmount\n                    : balance;\n            }\n\n            // ensure there is capacity left and that we're increasing the user's stake\n            // the user's stake may increase when either\n            // 1) the user isn't staked yet or\n            // 2) the user staked & hit the stake cap but more capacity has opened up since then\n            if (stakeAmountUpdated == 0 || stakeAmountUpdated <= userState.stakeAmount) {\n                continue;\n            }\n\n            // update user state\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: stakeAmountUpdated,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n            if (userState.stakeAmount == 0) {\n                // user didn't have any stake in this pool before\n                unchecked {\n                    ++userPoolCounts[msgSender][keys[i].stakeToken];\n                }\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i],\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, keys[i].startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: remainderStakeAmount + stakeAmountUpdated,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRushPool(RushPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            // should be past pool's start timestamp\n            if (!isValidRushPoolKey(keys[i]) || block.timestamp < keys[i].startTimestamp) {\n                continue;\n            }\n\n            RushPoolId id = keys[i].toId();\n            RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n\n            // user should have staked in the pool\n            if (userState.stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            uint256 endTimestamp = keys[i].startTimestamp + keys[i].programLength;\n            uint256 latestActiveTimestamp = FixedPointMathLib.min(block.timestamp, endTimestamp);\n            uint256 userStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolUserStates[id][msgSender] = RushStakeState({\n                stakeAmount: 0,\n                stakeXTimeStored: userStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n            unchecked {\n                --userPoolCounts[msgSender][keys[i].stakeToken];\n            }\n\n            // update pool state\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 poolStakeXTimeUpdated = _computeStakeXTime(\n                keys[i], poolState.stakeXTimeStored, poolState.stakeAmount, poolState.lastStakeAmountUpdateTimestamp\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount - userState.stakeAmount,\n                stakeXTimeStored: poolStakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: latestActiveTimestamp\n            });\n\n            // emit event\n            emit ExitRushPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function joinRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            // user should have non-zero balance\n            uint256 balance = ERC20(address(key.stakeToken)).balanceOf(msgSender);\n            if (balance == 0) {\n                continue;\n            }\n\n            // user's balance should be locked with this contract as the unlocker\n            if (\n                !key.stakeToken.isLocked(msgSender)\n                    || key.stakeToken.unlockerOf(msgSender) != IERC20Unlocker(address(this))\n            ) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // can't stake in a pool twice\n            if (balance <= stakedBalance) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply - stakedBalance + balance;\n            state.balanceOf[msgSender] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function exitRecurPool(RecurPoolKey[] calldata keys) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < keys.length; i++) {\n            RecurPoolKey calldata key = keys[i];\n\n            /// -----------------------------------------------------------------------\n            /// Validation\n            /// -----------------------------------------------------------------------\n\n            // key should be valid\n            if (!isValidRecurPoolKey(key)) continue;\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[msgSender];\n\n            // user should have staked in the pool\n            if (stakedBalance == 0) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.rewards[msgSender] = _earned(\n                state.userRewardPerTokenPaid[msgSender], stakedBalance, rewardPerTokenUpdated, state.rewards[msgSender]\n            );\n            state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n            // remove stake\n            delete state.balanceOf[msgSender];\n            // total supply has 1:1 relationship with staked amounts\n            // so can't ever underflow\n            unchecked {\n                state.totalSupply = totalSupply - stakedBalance;\n            }\n\n            // decrement user pool count\n            unchecked {\n                --userPoolCounts[msgSender][key.stakeToken];\n            }\n\n            // emit event\n            emit ExitRecurPool(msgSender, keys[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function unlock(IERC20Lockable[] calldata stakeTokens) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < stakeTokens.length; i++) {\n            // pool count should be 0\n            if (userPoolCounts[msgSender][stakeTokens[i]] != 0) {\n                continue;\n            }\n\n            // address(this) should be the unlocker of msgSender\n            // and msgSender should be locked\n            if (\n                stakeTokens[i].unlockerOf(msgSender) != IERC20Unlocker(address(this))\n                    || !stakeTokens[i].isLocked(msgSender)\n            ) {\n                continue;\n            }\n\n            // unlock stake token\n            stakeTokens[i].unlock(msgSender);\n\n            // emit event\n            emit Unlock(msgSender, stakeTokens[i]);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRushPool(RushClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RushPoolKey calldata key = params[i].keys[j];\n                RushPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRushPoolKey(key)) continue;\n\n                // load state\n                RushStakeState memory userState = rushPoolUserStates[id][msgSender];\n                uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n                uint256 rewardPaid = rushPoolUserRewardPaid[id][msgSender][incentiveToken];\n\n                // compute claimable reward\n                uint256 stakeXTimeUpdated = _computeStakeXTime(\n                    key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n                );\n                uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n                uint256 claimableReward = rewardAccrued - rewardPaid;\n\n                // update claim state\n                rushPoolUserRewardPaid[id][msgSender][incentiveToken] = rewardAccrued;\n\n                // accumulate claimable reward\n                totalClaimableAmount += claimableReward;\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// @inheritdoc IMasterBunni\n    function claimRecurPool(RecurClaimParams[] calldata params, address recipient) external nonReentrant {\n        address msgSender = LibMulticaller.senderOrSigner();\n\n        for (uint256 i; i < params.length; i++) {\n            address incentiveToken = params[i].incentiveToken;\n            uint256 totalClaimableAmount;\n\n            for (uint256 j; j < params[i].keys.length; j++) {\n                RecurPoolKey calldata key = params[i].keys[j];\n                RecurPoolId id = key.toId();\n\n                // key should be valid\n                if (!isValidRecurPoolKey(key)) continue;\n\n                /// -----------------------------------------------------------------------\n                /// Storage loads\n                /// -----------------------------------------------------------------------\n\n                // load state\n                RecurPoolState storage state = recurPoolStates[id];\n                uint64 lastUpdateTime = state.lastUpdateTime;\n                uint64 periodFinish = state.periodFinish;\n                uint64 lastTimeRewardApplicable =\n                    block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n                uint256 rewardPerTokenUpdated = _rewardPerToken(\n                    state.rewardPerTokenStored,\n                    state.totalSupply,\n                    lastTimeRewardApplicable,\n                    lastUpdateTime,\n                    state.rewardRate\n                );\n\n                /// -----------------------------------------------------------------------\n                /// State updates\n                /// -----------------------------------------------------------------------\n\n                // accrue rewards\n                uint256 reward = _earned(\n                    state.userRewardPerTokenPaid[msgSender],\n                    state.balanceOf[msgSender],\n                    rewardPerTokenUpdated,\n                    state.rewards[msgSender]\n                );\n                state.rewardPerTokenStored = rewardPerTokenUpdated;\n                state.lastUpdateTime = lastTimeRewardApplicable;\n                state.userRewardPerTokenPaid[msgSender] = rewardPerTokenUpdated;\n\n                if (reward != 0) {\n                    // delete accrued rewards\n                    delete state.rewards[msgSender];\n\n                    // accumulate claimable amount\n                    totalClaimableAmount += reward;\n                }\n            }\n\n            // transfer incentive tokens to user\n            if (totalClaimableAmount != 0) {\n                incentiveToken.safeTransfer(recipient, totalClaimableAmount);\n            }\n\n            // emit event\n            emit ClaimReward(msgSender, incentiveToken, recipient, totalClaimableAmount);\n        }\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IMasterBunni\n    function getRushPoolClaimableReward(RushPoolKey calldata key, address user, address incentiveToken)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        // load state\n        RushPoolId id = key.toId();\n        RushStakeState memory userState = rushPoolUserStates[id][user];\n        uint256 incentiveAmount = rushPoolIncentiveAmounts[id][incentiveToken];\n        uint256 rewardPaid = rushPoolUserRewardPaid[id][user][incentiveToken];\n\n        // compute claimable reward\n        uint256 stakeXTimeUpdated = _computeStakeXTime(\n            key, userState.stakeXTimeStored, userState.stakeAmount, userState.lastStakeAmountUpdateTimestamp\n        );\n        uint256 rewardAccrued = incentiveAmount.mulDiv(stakeXTimeUpdated, PRECISION);\n        return rewardAccrued - rewardPaid;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function getRecurPoolClaimableReward(RecurPoolKey calldata key, address user)\n        external\n        view\n        returns (uint256 claimableReward)\n    {\n        // no need to validate key since we just return 0 if it's invalid\n        RecurPoolId id = key.toId();\n        RecurPoolState storage state = recurPoolStates[id];\n        uint64 periodFinish = state.periodFinish;\n        uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n        uint256 rewardPerTokenUpdated = _rewardPerToken(\n            state.rewardPerTokenStored,\n            state.totalSupply,\n            lastTimeRewardApplicable,\n            state.lastUpdateTime,\n            state.rewardRate\n        );\n        return _earned(\n            state.userRewardPerTokenPaid[user], state.balanceOf[user], rewardPerTokenUpdated, state.rewards[ user]\n        );\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolStakeBalanceOf(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].balanceOf[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolUserRewardPerTokenPaid(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].userRewardPerTokenPaid[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function recurPoolRewards(RecurPoolId id, address user) external view returns (uint256) {\n        return recurPoolStates[id].rewards[user];\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRushPoolKey(RushPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.stakeCap != 0 && key.startTimestamp != 0\n            && key.programLength != 0;\n    }\n\n    /// @inheritdoc IMasterBunni\n    function isValidRecurPoolKey(RecurPoolKey memory key) public pure returns (bool) {\n        return address(key.stakeToken) != address(0) && key.rewardToken != address(0) && key.duration != 0;\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Callbacks\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IERC20Unlocker\n    /// @dev Should initialize the user's stake position.\n    function lockCallback(address account, uint256 balance, bytes calldata data) external nonReentrant {\n        LockCallbackData memory callbackData = abi.decode(data, (LockCallbackData));\n        IERC20Lockable stakeToken = IERC20Lockable(msg.sender);\n\n        for (uint256 i; i < callbackData.rushKeys.length; i++) {\n            RushPoolKey memory key = callbackData.rushKeys[i];\n            uint256 endTimestamp = key.startTimestamp + key.programLength;\n\n            // validate key\n            // - key should be valid\n            // - pool should be active\n            // - stakeToken of key should be msg.sender\n            if (\n                !isValidRushPoolKey(key) || key.stakeToken != stakeToken || block.timestamp < key.startTimestamp\n                    || block.timestamp > endTimestamp\n            ) {\n                continue;\n            }\n\n            RushPoolId id = key.toId();\n            uint256 userStakeAmount = rushPoolUserStates[id][account].stakeAmount;\n            // can't stake in a pool twice\n            if (userStakeAmount != 0) {\n                continue;\n            }\n            RushStakeState memory poolState = rushPoolStates[id];\n            uint256 stakeAmount =\n                poolState.stakeAmount + balance > key.stakeCap ? key.stakeCap - poolState.stakeAmount : balance;\n            // ensure there is capacity left\n            if (stakeAmount == 0) {\n                continue;\n            }\n\n            // update user state\n            // leave stakeXTime unchanged since stakeAmount was zero since the last update\n            // block.timestamp is at most endTimestamp\n            // since we already checked that the program is active\n            rushPoolUserStates[id][account].stakeAmount = stakeAmount;\n            rushPoolUserStates[id][account].lastStakeAmountUpdateTimestamp = block.timestamp;\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // update pool state\n            // poolState.lastStakeAmountUpdateTimestamp might be 0 if the pool has never had stakers\n            // so we bound it by the start timestamp of the program\n            uint256 stakeXTimeUpdated = _computeStakeXTime(\n                key,\n                poolState.stakeXTimeStored,\n                poolState.stakeAmount,\n                FixedPointMathLib.max(poolState.lastStakeAmountUpdateTimestamp, key.startTimestamp)\n            );\n            rushPoolStates[id] = RushStakeState({\n                stakeAmount: poolState.stakeAmount + stakeAmount,\n                stakeXTimeStored: stakeXTimeUpdated,\n                lastStakeAmountUpdateTimestamp: block.timestamp\n            });\n\n            // emit event\n            emit JoinRushPool(account, key);\n        }\n\n        for (uint256 i; i < callbackData.recurKeys.length; i++) {\n            RecurPoolKey memory key = callbackData.recurKeys[i];\n\n            // validate key\n            // - key should be valid\n            // - stakeToken of key should be msg.sender\n            if (!isValidRecurPoolKey(key) || key.stakeToken != stakeToken) {\n                continue;\n            }\n\n            /// -----------------------------------------------------------------------\n            /// Storage loads\n            /// -----------------------------------------------------------------------\n\n            RecurPoolId id = key.toId();\n            RecurPoolState storage state = recurPoolStates[id];\n            uint256 stakedBalance = state.balanceOf[account];\n\n            // can't stake in a pool twice\n            if (stakedBalance != 0) {\n                continue;\n            }\n\n            uint64 lastUpdateTime = state.lastUpdateTime;\n            uint64 periodFinish = state.periodFinish;\n            uint64 lastTimeRewardApplicable = block.timestamp < periodFinish ? uint64(block.timestamp) : periodFinish;\n            uint256 totalSupply = state.totalSupply;\n            uint256 rewardPerTokenUpdated = _rewardPerToken(\n                state.rewardPerTokenStored, totalSupply, lastTimeRewardApplicable, lastUpdateTime, state.rewardRate\n            );\n\n            /// -----------------------------------------------------------------------\n            /// State updates\n            /// -----------------------------------------------------------------------\n\n            // accrue rewards\n            // stakedBalance has been 0 so no need to update state.rewards[account]\n            state.rewardPerTokenStored = rewardPerTokenUpdated;\n            state.lastUpdateTime = lastTimeRewardApplicable;\n            state.userRewardPerTokenPaid[account] = rewardPerTokenUpdated;\n\n            // stake\n            state.totalSupply = totalSupply + balance;\n            state.balanceOf[account] = balance;\n\n            // increment user pool count\n            unchecked {\n                ++userPoolCounts[account][key.stakeToken];\n            }\n\n            // emit event\n            emit JoinRecurPool(account, key);\n        }\n    }\n\n    /// @inheritdoc IERC20Unlocker\n    function lockedUserReceiveCallback(address account, uint256 receiveAmount) external {}\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the updated (normalized stake amount) x (normalized time since program start) value. This value is useful\n    /// since (stake x time) x (incentive amount) is the incentive amount accrued for the user / pool so far.\n    /// Example: If a user has staked 0.5 x stakeCap tokens for 0.3 x programLength seconds, the stake x time value is 0.15 which is\n    /// the proportion of the total incentive amount that the user has accrued so far.\n    /// @param key The rush pool key.\n    /// @param stakeXTimeStored The stake x time value stored in the state.\n    /// @param stakeAmount The stake amount of the user between the last update and now.\n    /// @param lastStakeAmountUpdateTimestamp The timestamp of the last update. Should be at most the end timestamp of the program.\n    /// @return The updated stake x time value.\n    function _computeStakeXTime(\n        RushPoolKey memory key,\n        uint256 stakeXTimeStored,\n        uint256 stakeAmount,\n        uint256 lastStakeAmountUpdateTimestamp\n    ) internal view returns (uint256) {\n        if (block.timestamp < key.startTimestamp) {\n            return 0;\n        }\n        uint256 endTimestamp = key.startTimestamp + key.programLength;\n        uint256 timeElapsedSinceLastUpdate =\n            FixedPointMathLib.min(block.timestamp, endTimestamp) - lastStakeAmountUpdateTimestamp;\n        return stakeXTimeStored\n            + PRECISION.mulDiv(stakeAmount, key.stakeCap).mulDiv(timeElapsedSinceLastUpdate, key.programLength);\n    }\n\n    function _earned(\n        uint256 userRewardPerTokenPaid,\n        uint256 accountBalance,\n        uint256 rewardPerToken,\n        uint256 accountRewards\n    ) internal pure returns (uint256) {\n        return FixedPointMathLib.fullMulDiv(accountBalance, rewardPerToken - userRewardPerTokenPaid, PRECISION)\n            + accountRewards;\n    }\n\n    function _rewardPerToken(\n        uint256 rewardPerTokenStored,\n        uint256 totalSupply,\n        uint256 lastTimeRewardApplicable,\n        uint256 lastUpdateTime,\n        uint256 rewardRate\n    ) internal pure returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        // mulDiv won't overflow since we check that rewardRate is less than (type(uint256).max / PRECISION_DIV_REWARD_RATE_PRECISION / duration)\n        return rewardPerTokenStored\n            + FixedPointMathLib.mulDiv(\n                (lastTimeRewardApplicable - lastUpdateTime) * PRECISION_DIV_REWARD_RATE_PRECISION, rewardRate, totalSupply\n            );\n    }\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["joinRushPool", "exitRushPool"],
    "vulnerable_lines": [10]
  },
  
  "context_files": [],
  
  "call_flow": "Victim.joinRushPool (pending) -> Attacker.joinRushPool (fills cap) -> Victim TX reverts -> Attacker.exitRushPool (empties cap) -> Repeat.",
  "context_hint": "Economic Denial of Service vulnerability arising from the lack of temporal restrictions on staking and unstaking in a capped pool. The attacker uses cheap, reversible transactions to maintain a persistent block on legitimate users.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A standard mechanism for DOS in capped pools without time locks. While it doesn't lead to direct asset loss from the protocol, it severely harms user experience and can disrupt the protocol's liquidity acquisition strategy."
}


{
  "id": "gs_pashov_bunni_M04",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Bunni Tokenomics Audit",
  "source_finding_id": "[M-04]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Bunni-security-review-October.pdf",
  "github_repo_url": "https://github.com/Bunniapp/tokenomics/tree/13a77bfa1983336e6fb5980a042d503f0e8b6c25",
  "contest_date": "2025-10-17",
  
  "severity": "medium",
  "vulnerability_type": "incorrect_arithmetic_rounding",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Incorrect tick rounding in TWAP calculation",
  "finding_description": "In `BunniHookOracle._queryTwap()`, the arithmetic mean tick is calculated by dividing the cumulative tick delta (`tickCumulativesDelta`) by the window size. When `tickCumulativesDelta` is negative, Solidity's integer division rounds toward zero (upward). Correct TWAP tick calculation requires rounding toward negative infinity (downward) to maintain accuracy and consistency with price definitions, especially for negative ticks. The current implementation can result in the tick value being off by 1.",
  "attack_scenario": "The incorrect rounding can result in a mispriced oracle value (off by one tick) when the calculated average tick is negative and not an exact integer. This slight mispricing can be abused by arbitrageurs or lead to inaccurate price-dependent operations in the protocol, potentially costing small amounts of value in each transaction relying on the TWAP.",
  "fix_description": "Implement consistent rounding-down behavior for the tick calculation by adding a check: if `tickCumulativesDelta < 0` and the remainder of the division is non-zero, decrement the resulting tick by 1.",
  
  "primary_file": {
    "path": "contracts/BunniHookOracle.sol",
    "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.13;\n\nimport {Ownable} from "solady/auth/Ownable.sol";\nimport {SSTORE2} from "solady/utils/SSTORE2.sol";\nimport {FixedPointMathLib} from "solady/utils/FixedPointMathLib.sol";\n\nimport "../external/IBunniHook.sol";\nimport {TickMath} from "../lib/TickMath.sol";\nimport {IOracle} from "../interfaces/IOracle.sol";\n\n/// @title Oracle using BunniHook TWAP oracle as data source\n/// @author zefram.eth\n/// @notice The oracle contract that provides the current price to purchase\n/// the underlying token while exercising options. Uses BunniHook TWAP oracle\n/// as data source, and then applies a multiplier & lower bound.\ncontract BunniHookOracle is IOracle, Ownable {\n    /// -----------------------------------------------------------------------\n    /// Library usage\n    /// -----------------------------------------------------------------------\n\n    using SSTORE2 for *;\n    using TickMath for *;\n    using FixedPointMathLib for *;\n\n    /// -----------------------------------------------------------------------\n    /// Errors\n    /// -----------------------------------------------------------------------\n\n    error BunniHookOracle__InvalidPoolKey();\n\n    /// -----------------------------------------------------------------------\n    /// Events\n    /// -----------------------------------------------------------------------\n\n    event SetParams(uint16 multiplier, uint32 secs, uint32 ago, uint128 minPrice);\n    event SetPoolKey(PoolKey poolKey);\n\n    /// -----------------------------------------------------------------------\n    /// Constants\n    /// -----------------------------------------------------------------------\n\n    /// @notice The denominator for converting the multiplier into a decimal number.\n    /// i.e. multiplier uses 4 decimals.\n    uint256 internal constant MULTIPLIER_DENOM = 10000;\n\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n\n    /// -----------------------------------------------------------------------\n    /// Immutable parameters\n    /// -----------------------------------------------------------------------\n\n    /// @notice The BunniHook contract\n    IBunniHook public immutable bunniHook;\n\n    /// @inheritdoc IOracle\n    address public immutable paymentToken;\n\n    /// @inheritdoc IOracle\n    address public immutable underlyingToken;\n\n    /// -----------------------------------------------------------------------\n    /// Storage variables\n    /// -----------------------------------------------------------------------\n\n    /// @notice The multiplier applied to the TWAP value. Encodes the discount of\n    /// the options token. Uses 4 decimals.\n    uint16 public multiplier;\n\n    /// @notice The size of the window to take the TWAP value over in seconds.\n    uint32 public secs;\n\n    /// @notice The number of seconds in the past to take the TWAP from. The window\n    /// would be (block.timestamp - secs - ago, block.timestamp - ago].\n    uint32 public ago;\n\n    /// @notice The minimum value returned by getPrice(). Maintains a floor for the\n    /// price to mitigate potential attacks on the TWAP oracle.\n    uint128 public minPrice;\n\n    /// @notice The SSTORE2 pointer to the PoolKey used to query the BunniHook TWAP oracle.\n    address public poolKeyPointer;\n\n    /// -----------------------------------------------------------------------\n    /// Constructor\n    /// -----------------------------------------------------------------------\n\n    constructor(\n        IBunniHook bunniHook_,\n        PoolKey memory poolKey,\n        address paymentToken_,\n        address underlyingToken_,\n        address owner_,\n        uint16 multiplier_,\n        uint32 secs_,\n        uint32 ago_,\n        uint128 minPrice_\n    ) {\n        bunniHook = bunniHook_;\n        paymentToken = paymentToken_;\n        underlyingToken = underlyingToken_;\n\n        multiplier = multiplier_;\n        secs = secs_;\n        ago = ago_;\n        minPrice = minPrice_;\n\n        emit SetParams(multiplier_, secs_, ago_, minPrice_);\n\n        _initializeOwner(owner_);\n\n        if (\n            !(\n                (poolKey.currency0 == paymentToken_ && poolKey.currency1 == underlyingToken_)\n                    || (poolKey.currency0 == underlyingToken_ && poolKey.currency1 == paymentToken_)\n            ) || poolKey.hooks != address(bunniHook_)\n        ) {\n            revert BunniHookOracle__InvalidPoolKey();\n        }\n        poolKeyPointer = abi.encode(poolKey).write();\n        emit SetPoolKey(poolKey);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// IOracle\n    /// -----------------------------------------------------------------------\n\n    /// @inheritdoc IOracle\n    function getPrice() external view override returns (uint256 price) {\n        /// -----------------------------------------------------------------------\n        /// Storage loads\n        /// -----------------------------------------------------------------------\n\n        uint16 multiplier_ = multiplier;\n        uint32 secs_ = secs;\n        uint32 ago_ = ago;\n        uint256 minPrice_ = minPrice;\n\n        /// -----------------------------------------------------------------------\n        /// Computation\n        /// -----------------------------------------------------------------------\n\n        // query BunniHook to get TWAP value\n        {\n            // get average tick\n            PoolKey memory poolKey = getPoolKey();\n            int24 arithmeticMeanTick = _queryTwap(poolKey, secs_ + ago_, ago_);\n\n            // the unit of the average price is (currency1 / currency0)\n            // if paymentToken is not currency1 of the pool, negate the tick\n            // so that the unit of the average price is (paymentToken / underlyingToken)\n            arithmeticMeanTick = paymentToken == poolKey.currency1 ? arithmeticMeanTick : -arithmeticMeanTick;\n\n            // convert tick to sqrtPriceX96\n            uint256 sqrtPriceX96 = arithmeticMeanTick.getSqrtPriceAtTick();\n\n            // convert sqrtPriceX96 in Q96 (2**96) to price in WAD (1e18)\n            // mulDiv cannot overflow since log2(MAX_SQRT_PRICE * WAD) ~= 219.79 < 256\n            uint256 sqrtPriceWad = sqrtPriceX96.mulDiv(WAD, Q96);\n\n            // compute the price by squaring the sqrtPriceWad\n            // mulWad cannot overflow since log2((MAX_SQRT_PRICE * WAD / Q96)**2) ~= 247.94 < 256\n            price = sqrtPriceWad.mulWad(sqrtPriceWad);\n        }\n\n        // apply multiplier to price\n        price = price.mulDivUp(multiplier_, MULTIPLIER_DENOM);\n\n        // bound price above minPrice\n        price = FixedPointMathLib.max(price, minPrice_);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Getters\n    /// -----------------------------------------------------------------------\n\n    /// @notice Returns the pool key used to query the BunniHook TWAP oracle.\n    function getPoolKey() public view returns (PoolKey memory) {\n        return abi.decode(poolKeyPointer.read(), (PoolKey));\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Owner functions\n    /// -----------------------------------------------------------------------\n\n    /// @notice Updates the oracle parameters. Only callable by the owner.\n    /// @param multiplier_ The multiplier applied to the TWAP value. Encodes the discount of\n    /// the options token. Uses 4 decimals.\n    /// @param secs_ The size of the window to take the TWAP value over in seconds.\n    /// @param ago_ The number of seconds in the past to take the TWAP from. The window\n    /// would be (block.timestamp - secs - ago, block.timestamp - ago].\n    /// @param minPrice_ The minimum value returned by getPrice(). Maintains a floor for the\n    /// price to mitigate potential attacks on the TWAP oracle.\n    function setParams(uint16 multiplier_, uint32 secs_, uint32 ago_, uint128 minPrice_) external onlyOwner {\n        multiplier = multiplier_;\n        secs = secs_;\n        ago = ago_;\n        minPrice = minPrice_;\n        emit SetParams(multiplier_, secs_, ago_, minPrice_);\n    }\n\n    /// @notice Sets the pool key used to query the BunniHook TWAP oracle.\n    /// Only callable by the owner.\n    /// @param poolKey The new pool key\n    function setPoolKey(PoolKey calldata poolKey) external onlyOwner {\n        // validate pool key\n        if (\n            !(\n                (poolKey.currency0 == paymentToken && poolKey.currency1 == underlyingToken)\n                    || (poolKey.currency0 == underlyingToken && poolKey.currency1 == paymentToken)\n            ) || poolKey.hooks != address(bunniHook)\n        ) {\n            revert BunniHookOracle__InvalidPoolKey();\n        }\n\n        poolKeyPointer = abi.encode(poolKey).write();\n        emit SetPoolKey(poolKey);\n    }\n\n    /// -----------------------------------------------------------------------\n    /// Internal utilities\n    /// -----------------------------------------------------------------------\n\n    /// @dev Computes the arithmetic mean tick of the TWAP window.\n    /// The TWAP window is defined by (block.timestamp - twapSecondsAgoStart, block.timestamp - twapSecondsAgoEnd].\n    /// The window size is (twapSecondsAgoStart - twapSecondsAgoEnd).\n    /// The unit of the average price is (currency1 / currency0).\n    function _queryTwap(PoolKey memory poolKey, uint32 twapSecondsAgoStart, uint32 twapSecondsAgoEnd)\n        internal\n        view\n        returns (int24 arithmeticMeanTick)\n    {\n        uint32 windowSize = twapSecondsAgoStart - twapSecondsAgoEnd;\n        IBunniHook hook = IBunniHook(address(poolKey.hooks));\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = twapSecondsAgoStart;\n        secondsAgos[1] = twapSecondsAgoEnd;\n        int56[] memory tickCumulatives = hook.observe(poolKey, secondsAgos);\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        return int24(tickCumulativesDelta / int56(uint56(windowSize)));\n    }\n}",
    "vulnerable_lines": [14],
    "vulnerable_functions": ["_queryTwap"]
  },
  
  "context_files": [],
  
  "call_flow": "Oracle calls `_queryTwap` -> `tickCumulativesDelta` is negative -> Solidity division rounds up (toward zero) -> Oracle returns an inaccurate tick value (off by 1).",
  "context_hint": "A subtle but common bug in Solidity when dealing with signed integer division. It leads to inaccurate TWAP calculation, which can be exploitable by sophisticated users for marginal gain. The issue is in not implementing the 'round towards negative infinity' standard for tick math.",
  
  "is_vulnerable": true,
  
  "expert_notes": "Essential for accurate price oracles. While the impact of one tick difference is typically low, consistent price inaccuracy breaks guarantees and can be exploited. Severity is Medium for an oracle function."
}

{
  "id": "gs_auditors_tcap_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "TCAP V2.0 Audit",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Cryptex-security-review.pdf",
  "github_repo_url": "https://github.com/cryptexfinance/tcapv2.0/tree/f0168f3fe66c1fba4fd70ffdcdc87287e8f0cb6a",
  "contest_date": "2025-09-30",
  
  "severity": "medium",
  "vulnerability_type": "oracle_manipulation_logic",
  "difficulty_tier": 3,
  "context_level": "single_file",
  
  "finding_title": "Circuit breakers are not considered when processing Chainlink's answer",
  "finding_description": "The oracle implementation does not validate Chainlink's returned price (`answer`) against the feed's `minAnswer` and `maxAnswer` circuit breaker limits. On some EVM chains like Arbitrum, Chainlink actively caps the returned price to these limits. If the actual asset price drops below `minAnswer`, the oracle will use the capped price (which is higher than the true market price), leading to an incorrect, inflated price being used by the protocol.",
  "attack_scenario": "1. The price of an asset, monitored by a Chainlink feed on Arbitrum, drops below the feed's configured `minAnswer`.\n2. The Chainlink feed returns the `minAnswer` (the capped value) instead of the true, lower market price.\n3. The protocol's `latestPrice()` function, lacking a check against `minAnswer`, accepts this artificially inflated price.\n4. This results in incorrect (overstated) collateralization ratios, preventing necessary liquidations and increasing the protocol's risk of insolvency.",
  "fix_description": "Implement checks within `latestPrice` to ensure the returned price (`answer`) is strictly between the aggregator's `MIN_ANSWER` and `MAX_ANSWER` (and also greater than 0), reverting if the returned answer is capped by the circuit breaker: `require(answer > MIN_ANSWER && answer < MAX_ANSWER);`.",
  
  "primary_file": {
    "path": "src/oracle/AggregatedChainlinkOracle.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\nimport {BaseOracleUSD} from "./BaseOracleUSD.sol";\nimport {AggregatorV3Interface} from "@chainlink/interfaces/feeds/AggregatorV3Interface.sol";\n/// @title Aggregated Chainlink Oracle USD\n/// @dev all oracles are priced in USD with 18 decimals\ncontract AggregatedChainlinkOracle is BaseOracleUSD {\n    AggregatorV3Interface public immutable feed;\n    uint256 public immutable feedDecimals;\n    constructor(address feed_, address token) BaseOracleUSD(token) {\n        feed = AggregatorV3Interface(feed_);\n        feedDecimals = feed.decimals();\n    }\n    function latestPrice(bool checkStaleness) public view virtual override returns (uint256) {\n        (, int256 answer,, uint256 updatedAt,) = feed.latestRoundData();\n        // @audit in case of a stale oracle do not revert because it would prevent users from withdrawing\n        // @audit only check staleness during minting to ensure staleness of price doesn't allow for arbitrage\n        if (checkStaleness) {\n            if (updatedAt < block.timestamp - 1 days) {\n                revert StaleOracle();\n            }\n        }\n        assert(answer > 0);\n        // @audit feed decimals cannot exceed 18\n        uint256 adjustedDecimalsAnswer = uint256(answer) * 10 ** (18 - feedDecimals);\n        return adjustedDecimalsAnswer;\n    }\n}",
    "vulnerable_lines": [15],
    "vulnerable_functions": ["latestPrice"]
  },
  
  "context_files": [],
  
  "call_flow": "Protocol calls `latestPrice()` -> Chainlink on Arbitrum returns capped price (because actual price < `minAnswer`) -> `latestPrice()` uses capped price without validation -> Protocol calculates over-collateralized ratio and skips liquidation.",
  "context_hint": "A critical flaw in price oracle validation stemming from misunderstanding Chainlink's circuit breaker implementation on specific chains (like Arbitrum). The protocol relies on a potentially inflated price, compromising its ability to manage solvency risk.",
  
  "is_vulnerable": true,
  
  "expert_notes": "This issue highlights the importance of chain-specific Chainlink documentation. The impact is High because it directly compromises the liquidation mechanism, but the likelihood is Low due to the requirement for specific market conditions (price crossing the circuit breaker)."
}

{
  "id": "gs_auditors_tcap_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "TCAP V2.0 Audit",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Cryptex-security-review.pdf",
  "github_repo_url": "https://github.com/cryptexfinance/tcapv2.0/tree/f0168f3fe66c1fba4fd70ffdcdc87287e8f0cb6a",
  "contest_date": "2025-09-30",
  
  "severity": "medium",
  "vulnerability_type": "missing_access_control",
  "difficulty_tier": 1,
  "context_level": "single_file",
  
  "finding_title": "Add a form of access control to takeFee",
  "finding_description": "The `takeFee()` function is external and lacks any access control, allowing anyone to call it for any user's debt. This function executes fee calculation and share reduction via `_takeFee`. An external actor can selectively and repeatedly call this function for targeted depositors, gradually decreasing their shares and, in effect, increasing the proportional ownership of depositors whose fees have not been taken.",
  "attack_scenario": "1. Depositors A, B, and C hold equal shares. \n2. An attacker calls `takeFee()` targeting only Depositor A and B's debt/shares, causing their share balances to slightly decrease due to the fee subtraction.\n3. Depositor C's shares remain unchanged.\n4. This selective fee application causes C's proportional claim on the underlying assets to increase at the expense of A and B, enabling a griefing or subtle profit redistribution attack that is detrimental to the targeted users.",
  "fix_description": "Consider limiting the function to a protected role (e.g., `onlyKeeper`, `onlyOwner`) and/or modifying the function to only allow a user to call `takeFee` for their own position, e.g., by adding a check that `user == msg.sender`.",
  
  "primary_file": {
    "path": "contracts/Vault.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {AccessControlUpgradeable as AccessControl} from "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";\nimport {Multicall} from "./lib/Multicall.sol";\nimport {ITCAPV2, IERC20} from "./interface/ITCAPV2.sol";\nimport {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";\nimport {IVault, IVersioned} from "./interface/IVault.sol";\nimport {IPocket} from "./interface/pockets/IPocket.sol";\nimport {FeeCalculatorLib} from "./lib/FeeCalculatorLib.sol";\nimport {IPermit2, ISignatureTransfer} from "permit2/src/interfaces/IPermit2.sol";\nimport {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport {SafeTransferLib} from "solady/src/utils/SafeTransferLib.sol";\nimport {IOracle} from "./interface/IOracle.sol";\nimport {Constants, Roles} from "./lib/Constants.sol";\nimport {LiquidationLib} from "./lib/LiquidationLib.sol";\n\n/// @title Vault\n/// @notice Vaults manage deposits of collateral and mint TCAP tokens\ncontract Vault is IVault, AccessControl, Multicall {\n    using FeeCalculatorLib for MintData;\n    using SafeCast for uint256;\n    using SafeTransferLib for address;\n\n    struct Deposit {\n        uint256 mintAmount;\n        uint256 feeIndex;\n        uint256 accruedInterest;\n    }\n\n    struct Pocket {\n        IPocket pocket;\n        bool enabled;\n    }\n\n    struct FeeData {\n        uint256 index;\n        uint16 fee;\n        uint40 lastUpdated;\n    }\n\n    struct MintData {\n        mapping(uint256 mintId => Deposit deposit) deposits;\n        FeeData feeData;\n    }\n\n    /// @custom:storage-location erc7201:tcapv2.storage.vault\n    struct VaultStorage {\n        mapping(uint96 pocketId => Pocket pocket) pockets;\n        uint96 pocketCounter;\n        IOracle oracle;\n        address feeRecipient;\n        IVault.LiquidationParams liquidationParams;\n        MintData mintData;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256("tcapv2.storage.vault")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant VaultStorageLocation = 0xead32f79207e43129359e4c6890b619e37e73a4cc1d61050c081a5aea1b4df00;\n\n    ITCAPV2 public immutable TCAPV2;\n    IERC20 public immutable COLLATERAL;\n    IPermit2 private immutable PERMIT2;\n    uint8 private immutable COLLATERAL_DECIMALS;\n\n    /// @dev ensures loan is healthy after any action is performed\n    modifier ensureLoanHealthy(address user, uint96 pocketId, bool checkStaleness) {\n        _;\n        if (_healthFactor(user, pocketId, checkStaleness) < liquidationParams().threshold) revert LoanNotHealthy();\n    }\n\n    constructor(ITCAPV2 tCAPV2_, IERC20 collateral_, IPermit2 permit2_) {\n        TCAPV2 = tCAPV2_;\n        COLLATERAL = collateral_;\n        PERMIT2 = permit2_;\n        COLLATERAL_DECIMALS = IERC20Metadata(address(collateral_)).decimals();\n        _disableInitializers();\n    }\n\n    function initialize(address admin, uint16 initialFee, address oracle_, address feeRecipient_, IVault.LiquidationParams calldata liquidationParams_)\n        public\n        initializer\n    {\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\n        _updateInterestRate(initialFee);\n        _updateOracle(oracle_);\n        _updateFeeRecipient(feeRecipient_);\n        _updateLiquidationParams(liquidationParams_);\n    }\n\n    function _getVaultStorage() private pure returns (VaultStorage storage $) {\n        assembly {\n            $.slot := VaultStorageLocation\n        }\n    }\n\n    /// @inheritdoc IVault\n    function addPocket(IPocket pocket) external onlyRole(Roles.POCKET_SETTER_ROLE) returns (uint96 pocketId) {\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        if (address(pocket.VAULT()) != address(this)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        if (pocket.UNDERLYING_TOKEN() != COLLATERAL) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET_COLLATERAL);\n        VaultStorage storage $ = _getVaultStorage();\n        pocketId = ++$.pocketCounter;\n        $.pockets[pocketId] = Pocket({pocket: pocket, enabled: true});\n        emit PocketAdded(pocketId, pocket);\n    }\n\n    /// @inheritdoc IVault\n    function disablePocket(uint96 pocketId) external onlyRole(Roles.POCKET_SETTER_ROLE) {\n        VaultStorage storage $ = _getVaultStorage();\n        if (!$.pockets[pocketId].enabled) revert PocketNotEnabled(pocketId);\n        $.pockets[pocketId].enabled = false;\n        emit PocketDisabled(pocketId);\n    }\n\n    /// @inheritdoc IVault\n    function updateInterestRate(uint16 fee) external onlyRole(Roles.FEE_SETTER_ROLE) {\n        _updateInterestRate(fee);\n    }\n\n    /// @inheritdoc IVault\n    function updateFeeRecipient(address newFeeRecipient) external onlyRole(Roles.FEE_SETTER_ROLE) {\n        _updateFeeRecipient(newFeeRecipient);\n    }\n\n    /// @inheritdoc IVault\n    function updateOracle(address newOracle) external onlyRole(Roles.ORACLE_SETTER_ROLE) {\n        _updateOracle(newOracle);\n    }\n\n    /// @inheritdoc IVault\n    function updateLiquidationParams(LiquidationParams calldata newParams) external onlyRole(Roles.LIQUIDATION_SETTER_ROLE) {\n        _updateLiquidationParams(newParams);\n    }\n\n    /// @inheritdoc IVault\n    function deposit(uint96 pocketId, uint256 amount) external returns (uint256 shares) {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        IPocket pocket = _getPocket(pocketId);\n        address(COLLATERAL).safeTransferFrom(msg.sender, address(pocket), amount);\n        shares = pocket.registerDeposit(msg.sender, amount);\n        emit Deposited(msg.sender, pocketId, amount, shares);\n    }\n\n    /// @inheritdoc IVault\n    function depositWithPermit(uint96 pocketId, uint256 amount, IPermit2.PermitTransferFrom calldata permit, bytes calldata signature)\n        external\n        returns (uint256 shares)\n    {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        if (permit.permitted.token != address(COLLATERAL)) revert InvalidToken();\n        IPocket pocket = _getPocket(pocketId);\n        IPermit2.SignatureTransferDetails memory transferDetails = ISignatureTransfer.SignatureTransferDetails({to: address(pocket), requestedAmount: amount});\n        PERMIT2.permitTransferFrom(permit, transferDetails, msg.sender, signature);\n        shares = pocket.registerDeposit(msg.sender, amount);\n        emit Deposited(msg.sender, pocketId, amount, shares);\n    }\n\n    /// @inheritdoc IVault\n    function withdraw(uint96 pocketId, uint256 amount, address to) external ensureLoanHealthy(msg.sender, pocketId, false) returns (uint256 shares) {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        // @audit should be able to withdraw even if pocket is disabled\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        _takeFee(pocket, msg.sender, pocketId);\n        shares = pocket.withdraw(msg.sender, amount, to);\n        emit Withdrawn(msg.sender, pocketId, to, amount, shares);\n    }\n\n    /// @inheritdoc IVault\n    function mint(uint96 pocketId, uint256 amount) external ensureLoanHealthy(msg.sender, pocketId, true) {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        MintData storage $ = _getVaultStorage().mintData;\n        $.modifyPosition(_toMintId(msg.sender, pocketId), amount.toInt256());\n        TCAPV2.mint(msg.sender, amount);\n        emit Minted(msg.sender, pocketId, amount);\n    }\n\n    /// @inheritdoc IVault\n    function burn(uint96 pocketId, uint256 amount) external {\n        if (amount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        MintData storage $ = _getVaultStorage().mintData;\n        uint256 mintId = _toMintId(msg.sender, pocketId);\n        if ($.deposits[mintId].mintAmount < amount) revert InsufficientMintedAmount();\n        $.modifyPosition(mintId, -1 * (amount.toInt256()));\n        TCAPV2.burn(msg.sender, amount);\n        emit Burned(msg.sender, pocketId, amount);\n    }\n\n    /// @inheritdoc IVault\n    function liquidate(address user, uint96 pocketId, uint256 burnAmount) external returns (uint256 liquidationReward) {\n        if (burnAmount == 0) revert InvalidValue(IVault.ErrorCode.ZERO_VALUE);\n        // @audit should be able to liquidate even if pocket is disabled\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        _takeFee(pocket, user, pocketId);\n        uint256 mintAmount = mintedAmountOf(user, pocketId);\n        if (burnAmount > mintAmount) revert InvalidValue(IVault.ErrorCode.INVALID_BURN_AMOUNT);\n        uint256 tcapPrice = TCAPV2.latestPrice();\n        uint256 collateralAmount = collateralOf(user, pocketId);\n        uint256 collateralPrice = _latestPrice(false);\n        IVault.LiquidationParams memory liquidation = liquidationParams();\n        uint256 healthFactor_ = LiquidationLib.healthFactor(mintAmount, tcapPrice, collateralAmount, collateralPrice, COLLATERAL_DECIMALS);\n        if (healthFactor_ >= liquidation.threshold) revert LoanHealthy();\n\n        liquidationReward = LiquidationLib.liquidationReward(burnAmount, tcapPrice, collateralPrice, liquidation.penalty, COLLATERAL_DECIMALS);\n        if (liquidationReward > collateralAmount) {\n            // if mintValue < collateralValue + liquidationPenalty, liquidationReward will be > collateralAmount\n            // in this case, we will liquidate the entire collateral\n            // liquidation reward cannot be greater than collateral amount if the loan health is greater than 100% + liquidation penalty\n            if (burnAmount != mintAmount) revert InvalidValue(IVault.ErrorCode.MUST_LIQUIDATE_ENTIRE_POSITION);\n            liquidationReward = collateralAmount;\n        } else {\n            uint256 minBurnAmount = LiquidationLib.tokensRequiredForTargetHealthFactor(\n                healthFactor_, liquidation.threshold + liquidation.minHealthFactor, mintAmount, liquidation.penalty\n            );\n\n            // if the minimum burn amount required to reach the minimum health factor is greater than the minted amount, we need to liquidate the entire position\n            if (minBurnAmount > mintAmount) minBurnAmount = mintAmount;\n\n            // ensure health factor is above liquidation threshold + min health factor delta after liquidation, e.g., 150% + 10% = 160%\n            if (burnAmount < minBurnAmount) {\n                revert InvalidValue(IVault.ErrorCode.HEALTH_FACTOR_BELOW_MINIMUM);\n            }\n            // ensure health factor is below liquidation threshold + max health factor delta after liquidation, e.g., 150% + 30% = 180%\n            if (\n                burnAmount\n                    > LiquidationLib.tokensRequiredForTargetHealthFactor(\n                        healthFactor_, liquidation.threshold + liquidation.maxHealthFactor, mintAmount, liquidation.penalty\n                    )\n            ) {\n                revert InvalidValue(IVault.ErrorCode.HEALTH_FACTOR_ABOVE_MAXIMUM);\n            }\n        }\n\n        _getVaultStorage().mintData.modifyPosition(_toMintId(user, pocketId), -1 * (burnAmount.toInt256()));\n        TCAPV2.burn(msg.sender, burnAmount);\n        pocket.withdraw(user, liquidationReward, msg.sender);\n        emit Liquidated(msg.sender, user, pocketId, liquidationReward, burnAmount);\n    }\n\n    /// @inheritdoc IVault\n    function takeFee(address user, uint96 pocketId) external {\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        _takeFee(pocket, user, pocketId);\n    }\n\n    /// @inheritdoc IVault\n    function collateralValueOfUser(address user, uint96 pocketId) external view returns (uint256) {\n        return collateralValueOf(collateralOf(user, pocketId));\n    }\n\n    /// @inheritdoc IVault\n    function healthFactor(address user, uint96 pocketId) external view returns (uint256) {\n        return _healthFactor(user, pocketId, false);\n    }\n\n    /// @inheritdoc IVault\n    function collateralValueOf(uint256 amount) public view returns (uint256) {\n        return amount * _latestPrice(false) / 10 ** COLLATERAL_DECIMALS;\n    }\n\n    /// @inheritdoc IVault\n    function mintedValueOf(uint256 amount) public view returns (uint256) {\n        return TCAPV2.latestPriceOf(amount);\n    }\n\n    /// @inheritdoc IVault\n    function mintedValueOfUser(address user, uint96 pocketId) external view returns (uint256) {\n        return mintedValueOf(mintedAmountOf(user, pocketId));\n    }\n\n    /// @inheritdoc IVault\n    function collateralOf(address user, uint96 pocketId) public view returns (uint256) {\n        uint256 balance = _balanceOf(user, pocketId);\n        uint256 interest = outstandingInterestOf(user, pocketId);\n        if (interest > balance) return 0;\n        return balance - interest;\n    }\n\n    /// @inheritdoc IVault\n    function mintedAmountOf(address user, uint96 pocketId) public view returns (uint256) {\n        return _getVaultStorage().mintData.deposits[_toMintId(user, pocketId)].mintAmount;\n    }\n\n    /// @inheritdoc IVault\n    function outstandingInterestOf(address user, uint96 pocketId) public view returns (uint256) {\n        MintData storage $ = _getVaultStorage().mintData;\n        uint256 interestAmount = $.interestOf(_toMintId(user, pocketId));\n        return interestAmount * TCAPV2.latestPrice() / _latestPrice(false) * 10 ** COLLATERAL_DECIMALS / 10 ** Constants.TCAP_DECIMALS;\n    }\n\n    /// @inheritdoc IVault\n    function latestPrice() external view returns (uint256) {\n        return _latestPrice(false);\n    }\n\n    /// @inheritdoc IVault\n    function oracle() external view returns (address) {\n        return address(_getVaultStorage().oracle);\n    }\n\n    /// @inheritdoc IVault\n    function interestRate() external view returns (uint16) {\n        return _getVaultStorage().mintData.feeData.fee;\n    }\n\n    /// @inheritdoc IVault\n    function feeRecipient() external view returns (address) {\n        return _getVaultStorage().feeRecipient;\n    }\n\n    /// @inheritdoc IVault\n    function liquidationParams() public view returns (IVault.LiquidationParams memory params) {\n        params = _getVaultStorage().liquidationParams;\n    }\n\n    /// @inheritdoc IVault\n    function pockets(uint96 id) external view returns (IPocket) {\n        return _getVaultStorage().pockets[id].pocket;\n    }\n\n    /// @inheritdoc IVault\n    function pocketEnabled(uint96 id) external view returns (bool) {\n        return _getVaultStorage().pockets[id].enabled;\n    }\n\n    function _takeFee(IPocket pocket, address user, uint96 pocketId) internal {\n        uint256 interest = outstandingInterestOf(user, pocketId);\n        uint256 collateral = _balanceOf(user, pocketId);\n        if (interest > collateral) interest = collateral;\n        VaultStorage storage $ = _getVaultStorage();\n        address feeRecipient_ = $.feeRecipient;\n        if (interest != 0 && feeRecipient_ != address(0)) {\n            $.mintData.resetInterestOf(_toMintId(user, pocketId));\n            pocket.withdraw(user, interest, feeRecipient_);\n            emit FeeCollected(user, pocketId, feeRecipient_, interest);\n        }\n    }\n\n    function _updateInterestRate(uint16 fee) internal {\n        if (fee > Constants.MAX_FEE) revert InvalidValue(IVault.ErrorCode.MAX_FEE);\n        VaultStorage storage $ = _getVaultStorage();\n        $.mintData.setInterestRate(fee);\n        emit InterestRateUpdated(fee);\n    }\n\n    function _updateFeeRecipient(address newFeeRecipient) internal {\n        VaultStorage storage $ = _getVaultStorage();\n        $.feeRecipient = newFeeRecipient;\n        emit FeeRecipientUpdated(newFeeRecipient);\n    }\n\n    function _updateLiquidationParams(IVault.LiquidationParams calldata liquidation) internal {\n        if (liquidation.penalty > Constants.MAX_LIQUIDATION_PENALTY) revert InvalidValue(IVault.ErrorCode.MAX_LIQUIDATION_PENALTY);\n        if (liquidation.threshold > Constants.MAX_LIQUIDATION_THRESHOLD - liquidation.penalty) revert InvalidValue(IVault.ErrorCode.MAX_LIQUIDATION_THRESHOLD);\n        if (liquidation.threshold < Constants.MIN_LIQUIDATION_THRESHOLD + liquidation.penalty) {\n            revert InvalidValue(IVault.ErrorCode.MIN_LIQUIDATION_THRESHOLD);\n        }\n        if (liquidation.minHealthFactor < Constants.MIN_POST_LIQUIDATION_HEALTH_FACTOR) {\n            revert InvalidValue(IVault.ErrorCode.MIN_POST_LIQUIDATION_HEALTH_FACTOR);\n        }\n        if (liquidation.maxHealthFactor > Constants.MAX_POST_LIQUIDATION_HEALTH_FACTOR) {\n            revert InvalidValue(IVault.ErrorCode.MAX_POST_LIQUIDATION_HEALTH_FACTOR);\n        }\n        if (liquidation.minHealthFactor >= liquidation.maxHealthFactor) {\n            revert InvalidValue(IVault.ErrorCode.INCOMPATIBLE_MAX_POST_LIQUIDATION_HEALTH_FACTOR);\n        }\n        VaultStorage storage $ = _getVaultStorage();\n        $.liquidationParams = liquidation;\n        emit LiquidationParamsUpdated(liquidation);\n    }\n\n    function _updateOracle(address newOracle) internal {\n        if (IOracle(newOracle).asset() != address(COLLATERAL)) revert IOracle.InvalidOracle();\n        VaultStorage storage $ = _getVaultStorage();\n        $.oracle = IOracle(newOracle);\n        emit OracleUpdated(newOracle);\n    }\n\n    function _getPocket(uint96 pocketId) internal view returns (IPocket) {\n        Pocket storage p = _getVaultStorage().pockets[pocketId];\n        if (!p.enabled) revert PocketNotEnabled(pocketId);\n        return p.pocket;\n    }\n\n    function _latestPrice(bool checkStaleness) internal view returns (uint256) {\n        return _getVaultStorage().oracle.latestPrice(checkStaleness);\n    }\n\n    function _healthFactor(address user, uint96 pocketId, bool checkStaleness) internal view returns (uint256) {\n        return LiquidationLib.healthFactor(\n            mintedAmountOf(user, pocketId), TCAPV2.latestPrice(), collateralOf(user, pocketId), _latestPrice(checkStaleness), COLLATERAL_DECIMALS\n        );\n    }\n\n    function _balanceOf(address user, uint96 pocketId) internal view returns (uint256) {\n        IPocket pocket = _getVaultStorage().pockets[pocketId].pocket;\n        if (address(pocket) == address(0)) revert InvalidValue(IVault.ErrorCode.INVALID_POCKET);\n        return pocket.balanceOf(user);\n    }\n\n    function _toMintId(address user, uint96 pocketId) internal pure returns (uint256) {\n        return uint256(keccak256(abi.encode(user, pocketId)));\n    }\n\n    /// @inheritdoc IVersioned\n    function version() external pure returns (string memory) {\n        return "1.0.0";\n    }\n}",
    "vulnerable_lines": [9],
    "vulnerable_functions": ["takeFee"]
  },
  
  "context_files": [],
  
  "call_flow": "Attacker.takeFee(TargetUser, pocketId) -> Vault.takeFee executes without access check -> Fee is subtracted from TargetUser's shares -> Proportional ownership is unfairly redistributed.",
  "context_hint": "Missing access control on a maintenance function that mutates state (adjusts user shares based on accrued fee). The lack of protection allows for selective application of the fee, disrupting proportional ownership among depositors.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The vulnerability lies in the function's external visibility combined with its state-mutating effect on a specific user's shares. Since fee accrual is constant, the time it is applied should be protected or symmetric."
}

{
  "id": "gs_koolex_hydration_H01",
  "subset": "gold_standard",
  "language": "rust",
  "chain": "other",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Hydration Tokenomics Audit",
  "source_finding_id": "[H-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Hydration-security-review-October.pdf",
  "github_repo_url": "https://github.com/galacticcouncil/hydration-node/tree/90eb2543cbe037626ed2c5f263f876bc5db6825a",
  "contest_date": "2025-10-17",
  
  "severity": "high",
  "vulnerability_type": "incorrect_function_modifier",
  "difficulty_tier": 2,
  "context_level": "single_file",
  
  "finding_title": "TransferFrom is incorrectly treated as a view function",
  "finding_description": "In the `execute` function of the MultiCurrencyPrecompile module, the `check_function_modifier` logic incorrectly defaults `Function::TransferFrom` to `FunctionModifier::View`. This happens because `Function::TransferFrom` is missing from the `match selector` statement, causing it to fall through to the default `_ => FunctionModifier::View`. This is incorrect because `TransferFrom` is a state-changing function that requires `FunctionModifier::NonPayable`.",
  "attack_scenario": "If the `MultiCurrencyPrecompile` is executed in a context that strictly enforces view-only restrictions (e.g., in a query or a context that doesn't permit state changes), a call intended to execute `TransferFrom` will fail or revert because the precompile incorrectly signals it as a view function. This breaks a core token transfer mechanism and can lead to unexpected failures in dApps or cross-chain operations relying on this precompile.",
  "fix_description": "Include `Function::TransferFrom` in the `check_function_modifier` match statement and assign it `FunctionModifier::NonPayable`, mirroring the treatment of `Function::Transfer`.",
  
  "primary_file": {
    "path": "precompiles/utils/src/precompile_set.rs",
    "content": "// Copyright 2019-2022 PureStake Inc.\n// This file is part of Moonbeam.\n\n// Moonbeam is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// Moonbeam is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with Moonbeam.  If not, see <http://www.gnu.org/licenses/>.\n\n//! Provide utils to assemble precompiles and precompilesets into a\n//! final precompile set with security checks. All security checks are enabled by\n//! default and must be disabled explicely throught type annotations.\n\nuse crate::{\n\tevm::handle::PrecompileHandleExt,\n\tsolidity::{codec::String, revert::revert},\n\tEvmResult,\n};\nuse fp_evm::{\n\tExitError, IsPrecompileResult, Precompile, PrecompileFailure, PrecompileHandle, PrecompileResult, PrecompileSet,\n};\nuse frame_support::pallet_prelude::Get;\nuse impl_trait_for_tuples::impl_for_tuples;\nuse pallet_evm::AddressMapping;\nuse sp_core::{H160, H256};\nuse sp_std::{\n\tcell::RefCell, collections::btree_map::BTreeMap, marker::PhantomData, ops::RangeInclusive, vec, vec::Vec,\n};\n\n/// Trait representing checks that can be made on a precompile call.\n/// Types implementing this trait are made to be chained in a tuple.\n///\n/// For that reason every method returns an Option, None meaning that\n/// the implementor have no constraint and the decision is left to\n/// latter elements in the chain. If None is returned by all elements of\n/// the chain then sensible defaults are used.\n///\n/// Both `PrecompileAt` and `PrecompileSetStartingWith` have a type parameter that must\n/// implement this trait to configure the checks of the precompile(set) it represents.\npub trait PrecompileChecks {\n\t#[inline(always)]\n\t/// Is there a limit to the amount of recursions this precompile\n\t/// can make using subcalls? 0 means this specific precompile will not\n\t/// be callable as a subcall of itself, 1 will allow one level of recursion,\n\t/// etc...\n\t///\n\t/// If all checks return None, defaults to `Some(0)` (no recursion allowed).\n\tfn recursion_limit() -> Option<Option<u16>> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Does this precompile supports being called with DELEGATECALL or CALLCODE?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn accept_delegate_call() -> Option<bool> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Is this precompile callable by a smart contract?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn callable_by_smart_contract(_caller: H160, _called_selector: Option<u32>) -> Option<bool> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Is this precompile callable by a precompile?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn callable_by_precompile(_caller: H160, _called_selector: Option<u32>) -> Option<bool> {\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\t/// Is this precompile able to do subcalls?\n\t///\n\t/// If all checks return None, defaults to `false`.\n\tfn allow_subcalls() -> Option<bool> {\n\t\tNone\n\t}\n\n\t/// Summarize the checks when being called by a smart contract.\n\tfn callable_by_smart_contract_summary() -> Option<String> {\n\t\tNone\n\t}\n\n\t/// Summarize the checks when being called by a precompile.\n\tfn callable_by_precompile_summary() -> Option<String> {\n\t\tNone\n\t}\n}\n\n#[derive(Debug, Clone)]\npub enum DiscriminantResult<T> {\n\tSome(T, u64),\n\tNone(u64),\n\tOutOfGas,\n}\n\nimpl<T> Into<IsPrecompileResult> for DiscriminantResult<T> {\n\tfn into(self) -> IsPrecompileResult {\n\t\tmatch self {\n\t\t\tSelf::Some(_, extra_cost) => IsPrecompileResult::Answer {\n\t\t\t\tis_precompile: true,\n\t\t\t\textra_cost,\n\t\t\t},\n\t\t\tSelf::None(extra_cost) => IsPrecompileResult::Answer {\n\t\t\t\tis_precompile: false,\n\t\t\t\textra_cost,\n\t\t\t},\n\t\t\tSelf::OutOfGas => IsPrecompileResult::OutOfGas,\n\t\t}\n\t}\n}\n\n#[derive(Debug, Clone)]\n#[cfg_attr(feature = "testing", derive(serde::Serialize, serde::Deserialize))]\npub enum PrecompileKind {\n\tSingle(H160),\n\tMultiple(Vec<H160>),\n\tPrefixed(Vec<u8>),\n}\n\n#[derive(Debug, Clone)]\n#[cfg_attr(feature = "testing", derive(serde::Serialize, serde::Deserialize))]\npub struct PrecompileCheckSummary {\n\tpub name: Option<String>,\n\tpub precompile_kind: PrecompileKind,\n\tpub recursion_limit: Option<u16>,\n\tpub accept_delegate_call: bool,\n\tpub callable_by_smart_contract: String,\n\tpub callable_by_precompile: String,\n}\n\n#[impl_for_tuples(0, 20)]\nimpl PrecompileChecks for Tuple {\n\t#[inline(always)]\n\tfn recursion_limit() -> Option<Option<u16>> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::recursion_limit() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn accept_delegate_call() -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::accept_delegate_call() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn callable_by_smart_contract(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_smart_contract(caller, called_selector) {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn callable_by_precompile(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_precompile(caller, called_selector) {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\t#[inline(always)]\n\tfn allow_subcalls() -> Option<bool> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::allow_subcalls() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\tfn callable_by_smart_contract_summary() -> Option<String> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_smart_contract_summary() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n\n\tfn callable_by_precompile_summary() -> Option<String> {\n\t\tfor_tuples!(#(\n\t\t\tif let Some(check) = Tuple::callable_by_precompile_summary() {\n\t\t\t\treturn Some(check);\n\t\t\t}\n\t\t)*);\n\n\t\tNone\n\t}\n}\n\n/// Precompile can be called using DELEGATECALL/CALLCODE.\npub struct AcceptDelegateCall;\n\nimpl PrecompileChecks for AcceptDelegateCall {\n\t#[inline(always)]\n\tfn accept_delegate_call() -> Option<bool> {\n\t\tSome(true)\n\t}\n}\n\n/// Precompile is able to do subcalls with provided nesting limit.\npub struct SubcallWithMaxNesting<const R: u16>;\n\nimpl<const R: u16> PrecompileChecks for SubcallWithMaxNesting<R> {\n\t#[inline(always)]\n\tfn recursion_limit() -> Option<Option<u16>> {\n\t\tSome(Some(R))\n\t}\n\n\t#[inline(always)]\n\tfn allow_subcalls() -> Option<bool> {\n\t\tSome(true)\n\t}\n}\n\npub trait SelectorFilter {\n\tfn is_allowed(_caller: H160, _selector: Option<u32>) -> bool;\n\n\tfn description() -> String;\n}\npub struct ForAllSelectors;\nimpl SelectorFilter for ForAllSelectors {\n\tfn is_allowed(_caller: H160, _selector: Option<u32>) -> bool {\n\t\ttrue\n\t}\n\n\tfn description() -> String {\n\t\t"Allowed for all selectors and callers".into()\n\t}\n}\n\npub struct OnlyFrom<T>(PhantomData<T>);\nimpl<T: Get<H160>> SelectorFilter for OnlyFrom<T> {\n\tfn is_allowed(caller: H160, _selector: Option<u32>) -> bool {\n\t\tcaller == T::get()\n\t}\n\n\tfn description() -> String {\n\t\talloc::format!("Allowed for all selectors only if called from {}", T::get())\n\t}\n}\n\npub struct CallableByContract<T = ForAllSelectors>(PhantomData<T>);\n\nimpl<T: SelectorFilter> PrecompileChecks for CallableByContract<T> {\n\t#[inline(always)]\n\tfn callable_by_smart_contract(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tSome(T::is_allowed(caller, called_selector))\n\t}\n\n\tfn callable_by_smart_contract_summary() -> Option<String> {\n\t\tSome(T::description())\n\t}\n}\n\n/// Precompiles are allowed to call this precompile.\npub struct CallableByPrecompile<T = ForAllSelectors>(PhantomData<T>);\n\nimpl<T: SelectorFilter> PrecompileChecks for CallableByPrecompile<T> {\n\t#[inline(always)]\n\tfn callable_by_precompile(caller: H160, called_selector: Option<u32>) -> Option<bool> {\n\t\tSome(T::is_allowed(caller, called_selector))\n\t}\n\n\tfn callable_by_precompile_summary() -> Option<String> {\n\t\tSome(T::description())\n\t}\n}\n\n/// The type of EVM address.\n#[derive(PartialEq)]\n#[cfg_attr(feature = "std", derive(Debug))]\npub enum AddressType {\n\t/// The code stored at the address is less than 5 bytes, but not well known.\n\tUnknown,\n\t/// No code is stored at the address, therefore is EOA.\n\tEOA,\n\t/// The 5-byte magic constant for a precompile is stored at the address.\n\tPrecompile,\n\t/// The code is greater than 5-bytes, potentially a Smart Contract.\n\tContract,\n}\n\n/// Retrieves the type of address demarcated by `AddressType`.\npub fn get_address_type<R: pallet_evm::Config>(\n\thandle: &mut impl PrecompileHandle,\n\taddress: H160,\n) -> Result<AddressType, ExitError> {\n\t// AccountCodesMetadata:\n\t// Blake2128(16) + H160(20) + CodeMetadata(40)\n\thandle.record_db_read::<R>(76)?;\n\tlet code_len = pallet_evm::Pallet::<R>::account_code_metadata(address).size;\n\n\t// 0 => either EOA or precompile without dummy code\n\tif code_len == 0 {\n\t\treturn Ok(AddressType::EOA);\n\t}\n\n\t// dummy code is 5 bytes long, so any other len means it is a contract.\n\tif code_len != 5 {\n\t\treturn Ok(AddressType::Contract);\n\t}\n\n\t// check code matches dummy code\n\thandle.record_db_read::<R>(code_len as usize)?;\n\tlet code = pallet_evm::AccountCodes::<R>::get(address);\n\tif &code == &[0x60, 0x00, 0x60, 0x00, 0xfd] {\n\t\treturn Ok(AddressType::Precompile);\n\t}\n\n\tOk(AddressType::Unknown)\n}\n\nfn is_address_eoa_or_precompile<R: pallet_evm::Config>(\n\thandle: &mut impl PrecompileHandle,\n\taddress: H160,\n) -> Result<bool, ExitError> {\n\tmatch get_address_type::<R>(handle, address)? {\n\t\tAddressType::EOA | AddressType::Precompile => Ok(true),\n\t\t_ => Ok(false),\n\t}\n}\n\n/// Common checks for precompile and precompile sets.\n/// Don't contain recursion check as precompile sets have recursion check for each member.\nfn common_checks<R: pallet_evm::Config, C: PrecompileChecks>(handle: &mut impl PrecompileHandle) -> EvmResult<()> {\n\tlet code_address = handle.code_address();\n\tlet caller = handle.context().caller;\n\n\t// Check DELEGATECALL config.\n\tlet accept_delegate_call = C::accept_delegate_call().unwrap_or(false);\n\tif !accept_delegate_call && code_address != handle.context().address {\n\t\treturn Err(revert("Cannot be called with DELEGATECALL or CALLCODE"));\n\t}\n\n\t// Extract which selector is called.\n\tlet selector = handle.input().get(0..4).map(|bytes| {\n\t\tlet mut buffer = [0u8; 4];\n\t\tbuffer.copy_from_slice(bytes);\n\t\tu32::from_be_bytes(buffer)\n\t});\n\n\t// Is this selector callable from a smart contract?\n\tlet callable_by_smart_contract = C::callable_by_smart_contract(caller, selector).unwrap_or(false);\n\tif !callable_by_smart_contract {\n\t\tif !is_address_eoa_or_precompile::<R>(handle, caller)? {\n\t\t\treturn Err(revert("Function not callable by smart contracts"));\n\t\t}\n\t}\n\n\t// Is this selector callable from a precompile?\n\tlet callable_by_precompile = C::callable_by_precompile(caller, selector).unwrap_or(false);\n\tif !callable_by_precompile && is_precompile_or_fail::<R>(caller, handle.remaining_gas())? {\n\t\treturn Err(revert("Function not callable by precompiles"));\n\t}\n\n\tOk(())\n}\n\npub fn is_precompile_or_fail<R: pallet_evm::Config>(address: H160, gas: u64) -> EvmResult<bool> {\n\tmatch <R as pallet_evm::Config>::PrecompilesValue::get().is_precompile(address, gas) {\n\t\tIsPrecompileResult::Answer { is_precompile, .. } => Ok(is_precompile),\n\t\tIsPrecompileResult::OutOfGas => Err(PrecompileFailure::Error {\n\t\t\texit_status: ExitError::OutOfGas,\n\t\t}),\n\t}\n}\n\npub struct AddressU64<const N: u64>;\nimpl<const N: u64> Get<H160> for AddressU64<N> {\n\t#[inline(always)]\n\tfn get() -> H160 {\n\t\tH160::from_low_u64_be(N)\n\t}\n}\n\npub struct RestrictiveHandle<'a, H> {\n\thandle: &'a mut H,\n\tallow_subcalls: bool,\n}\n\nimpl<'a, H: PrecompileHandle> PrecompileHandle for RestrictiveHandle<'a, H> {\n\tfn call(\n\t\t&mut self,\n\t\taddress: H160,\n\t\ttransfer: Option<fp_evm::Transfer>,\n\t\tinput: Vec<u8>,\n\t\ttarget_gas: Option<u64>,\n\t\tis_static: bool,\n\t\tcontext: &fp_evm::Context,\n\t) -> (fp_evm::ExitReason, Vec<u8>) {\n\t\tif !self.allow_subcalls {\n\t\t\treturn (\n\t\t\t\tfp_evm::ExitReason::Revert(fp_evm::ExitRevert::Reverted),\n\t\t\t\tcrate::solidity::revert::revert_as_bytes("subcalls disabled for this precompile"),\n\t\t\t);\n\t\t}\n\n\t\tself.handle\n\t\t\t.call(address, transfer, input, target_gas, is_static, context)\n\t}\n\n\tfn record_cost(&mut self, cost: u64) -> Result<(), fp_evm::ExitError> {\n\t\tself.handle.record_cost(cost)\n\t}\n\n\tfn remaining_gas(&self) -> u64 {\n\t\tself.handle.remaining_gas()\n\t}\n\n\tfn log(&mut self, address: H160, topics: Vec<H256>, data: Vec<u8>) -> Result<(), fp_evm::ExitError> {\n\t\tself.handle.log(address, topics, data)\n\t}\n\n\tfn code_address(&self) -> H160 {\n\t\tself.handle.code_address()\n\t}\n\n\tfn input(&self) -> &[u8] {\n\t\tself.handle.input()\n\t}\n\n\tfn context(&self) -> &fp_evm::Context {\n\t\tself.handle.context()\n\t}\n\n\tfn is_static(&self) -> bool {\n\t\tself.handle.is_static()\n\t}\n\n\tfn gas_limit(&self) -> Option<u64> {\n\t\tself.handle.gas_limit()\n\t}\n\n\tfn record_external_cost(\n\t\t&mut self,\n\t\tref_time: Option<u64>,\n\t\tproof_size: Option<u64>,\n\t\tstorage_growth: Option<u64>,\n\t) -> Result<(), ExitError> {\n\t\tself.handle.record_external_cost(ref_time, proof_size, storage_growth)\n\t}\n\n\tfn refund_external_cost(&mut self, ref_time: Option<u64>, proof_size: Option<u64>) {\n\t\tself.handle.refund_external_cost(ref_time, proof_size)\n\t}\n}\n\n/// Allows to know if a precompile is active or not.\n/// This allows to detect deactivated precompile, that are still considered precompiles by\n/// the EVM but that will always revert when called.\npub trait IsActivePrecompile {\n\t/// Is the provided address an active precompile, a precompile that has\n\t/// not be deactivated. Note that a deactivated precompile is still considered a precompile\n\t/// for the EVM, but it will always revert when called.\n\tfn is_active_precompile(&self, address: H160, gas: u64) -> IsPrecompileResult;\n}\n\n// INDIVIDUAL PRECOMPILE(SET)\n\n/// A fragment of a PrecompileSet. Should be implemented as is it\n/// was a PrecompileSet containing only the precompile(set) it wraps.\n/// They can be combined into a real PrecompileSet using `PrecompileSetBuilder`.\npub trait PrecompileSetFragment {\n\t/// Instanciate the fragment.\n\tfn new() -> Self;\n\n\t/// Execute the fragment.\n\tfn execute<R: pallet_evm::Config>(&self, handle: &mut impl PrecompileHandle) -> Option<PrecompileResult>;\n\n\t/// Is the provided address a precompile in this fragment?\n\tfn is_precompile(&self, address: H160, gas: u64) -> IsPrecompileResult;\n\n\t/// Return the list of addresses covered by this fragment.\n\tfn used_addresses(&self) -> Vec<H160>;\n\n\t/// Summarize\n\tfn summarize_checks(&self) -> Vec<PrecompileCheckSummary>;\n}\n\n/// Wraps a stateless precompile: a type implementing the `Precompile` trait.\n/// Type parameters allow to define:\n/// - A: The address of the precompile\n/// - R: The recursion limit (defaults to 1)\n/// - D: If DELEGATECALL is supported (default to no)\npub struct PrecompileAt<A, P, C = ()> {\n\tcurrent_recursion_level: RefCell<u16>,\n\t_phantom: PhantomData<(A, P, C)>,\n}\n\nimpl<A, P, C> PrecompileSetFragment for PrecompileAt<A, P, C>\nwhere\n\tA: Get<H160>,\n\tP: Precompile,\n\tC: PrecompileChecks,\n{\n\t#[inline(always)]\n\tfn new() -> Self {\n\t\tSelf {\n\t\t\tcurrent_recursion_level: RefCell::new(0),\n\t\t\t_phantom: PhantomData,\n\t\t}\n\t}\n\n\t#[inline(always)]\n\tfn execute<R: pallet_evm::Config>(&self, handle: &mut impl PrecompileHandle) -> Option<PrecompileResult> {\n\t\tlet code_address = handle.code_address();\n\n\t\t// Check if this is the address of the precompile.\n\t\tif A::get() != code_address {\n\t\t\treturn None;\n\t\t}\n\n\t\t// Perform common checks.\n\t\tif let Err(err) = common_checks::<R, C>(handle) {\n\t\t\treturn Some(Err(err));\n\t\t}\n\n\t\t// Check and increase recursion level if needed.\n\t\tlet recursion_limit = C::recursion_limit().unwrap_or(Some(0));\n\t\tif let Some(max_recursion_level) = recursion_limit {\n\t\t\tmatch self.current_recursion_level.try_borrow_mut() {\n\t\t\t\tOk(mut recursion_level) => {\n\t\t\t\t\tif *recursion_level > max_recursion_level {\n\t\t\t\t\t\treturn Some(Err(revert("Precompile is called with too high nesting").into()));\n\t\t\t\t\t}\n\n\t\t\t\t\t*recursion_level += 1;\n\t\t\t\t}\n\t\t\t\t// We don't hold the borrow and are in single-threaded code, thus we should\n\t\t\t\t// not be able to fail borrowing in nested calls.\n\t\t\t\tErr(_) => return Some(Err(revert("Couldn't check precompile nesting").into())),\n\t\t\t}\n\t\t}\n\n\t\t// Subcall protection.\n\t\tlet allow_subcalls = C::allow_subcalls().unwrap_or(false);\n\t\tlet mut handle = RestrictiveHandle { handle, allow_subcalls };\n\n\t\tlet res = P::execute(&mut handle);\n\n\t\t// Decrease recursion level if needed.\n\t\tif recursion_limit.is_some() {\n\t\t\tmatch self.current_recursion_level.try_borrow_mut() {\n\t\t\t\tOk(mut recursion_level) => {\n\t\t\t\t\t*recursion_level -= 1;\n\t\t\t\t}\n\t\t\t\t// We don't hold the borrow and are in single-threaded code, thus we should\n\t\t\t\t// not be able to fail borrowing in nested calls.\n\t\t\t\tErr(_) => return Some(Err(revert("Couldn't check precompile nesting").into())),\n\t\t\t}\n\t\t}\n\n\t\tSome(res)\n\t}\n\n\t#[inline(always)]\n\tfn is_precompile(&self, address: H160, _gas: u64) -> IsPrecompileResult {\n\t\tIsPrecompileResult::Answer {\n\t\t\tis_precompile: address == A::get(),\n\t\t\textra_cost: 0,\n\t\t}\n\t}\n\n\t#[inline(always)]\n\tfn used_addresses(&self) -> Vec<H160> {\n\t\tvec![A::get()]\n\t}\n\n\tfn summarize_checks(&self) -> Vec<PrecompileCheckSummary> {\n\t\tvec![PrecompileCheckSummary {\n\t\t\tname: None,\n\t\t\tprecompile_kind: PrecompileKind::Single(A::get()),\n\t\t\trecursion_limit: C::recursion_limit().unwrap_or(Some(0)),\n\t\t\taccept_delegate_call: C::accept_delegate_call().unwrap_or(false),\n\t\t\tcallable_by_smart_contract: C::callable_by_smart_contract_summary()\n\t\t\t\t.unwrap_or_else(|| "Not callable".into()),\n\t\t\tcallable_by_precompile: C::callable_by_precompile_summary().unwrap_or_else(|| "Not callable".into()),\n\t\t}]\n\t}\n}\n\nimpl<A, P, C> IsActivePrecompile for PrecompileAt<A, P, C>\nwhere\n\tA: Get<H160>,\n{\n\t#[inline(always)]\n\tfn is_active_precompile(&self, address: H160, _gas: u64) -> IsPrecompileResult {\n\t\tIsPrecompileResult::Answer {\n\t\t\tis_precompile: address == A::get(),\n\t\t\textra_cost: 0,\n\t\t}\n\t}\n}\n\n/// Wraps an inner PrecompileSet with all its addresses starting with\n/// a common prefix.\n/// Type parameters allow to define:\n/// - A: The common prefix\n/// - D: If DELEGATECALL is supported (default to no)\npub struct PrecompileSetStartingWith<A, P, C = ()> {\n\tprecompile_set: P,\n\tcurrent_recursion_level: RefCell<BTreeMap<H160, u16>>,\n\t_phantom: PhantomData<(A, C)>,\n}\n\nimpl<A, P, C> PrecompileSetFragment for PrecompileSetStartingWith<A, P, C>\nwhere\n\tA: Get<&'static [u8]>,\n\tP: PrecompileSet + Default,\n\tC: PrecompileChecks,\n{\n\t#[inline(always)]\n\tfn new() -> Self {\n\t\tSelf {\n\t\t\tprecompile_set: P::default(),\n\t\t\tcurrent_recursion_level: RefCell::new(BTreeMap::new()),\n\t\t\t_phantom: PhantomData,\n",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["execute"]
  },
  
  "context_files": [],
  
  "call_flow": "EVM call to Precompile -> `execute` function -> `check_function_modifier(match selector)` -> `TransferFrom` is not matched -> Defaults to `FunctionModifier::View` -> Execution environment rejects state change.",
  "context_hint": "A logic error in the EVM precompile wrapper for token transfers. By misclassifying the `TransferFrom` state-changing function as a view function, the precompile violates the expected execution context, leading to high-impact failures of core token functionality.",
  
  "is_vulnerable": true,
  
  "expert_notes": "A fundamental issue in the precompile implementation that breaks standard ERC20 compatibility. While the impact is a failure/revert rather than fund loss, disabling a core transfer mechanism is a High severity DOS."
}

{
  "id": "gs_pashov_hyperbeat_M01",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Hyperbeat Security Review",
  "source_finding_id": "[M-01]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Hyperbeat-security-review_2025-09-03.pdf",
  "github_repo_url": "https://github.com/etherfi-protocol/beHYPE/tree/c620e61aaf8fe5767e713bb9d7447bd9fbc40148/src",
  "contest_date": "2025-09-03",
  
  "severity": "medium",
  "vulnerability_type": "liquidity_miscalculation",
  "difficulty_tier": 2,
  "context_level": "multi_file",
  
  "finding_title": "getTotalProtocolHype() includes pending withdrawal amounts",
  "finding_description": "The `getTotalProtocolHype()` function in `StakingCore.sol`, which calculates the total HYPE (the underlying asset) owned by the protocol, fails to subtract the amount of HYPE that has been requested for withdrawal (`hypeRequestedForWithdraw`) but not yet finalized (i.e., not yet transferred from `StakingCore` to `WithdrawManager`). This inflated TVL calculation is then used by functions like `lowWatermarkInHYPE()` and `getLiquidHypeAmount()` in `WithdrawManager.sol`, leading to an incorrect calculation of `withdrawableAmount` during instant withdrawal flow.",
  "attack_scenario": "1. A user queues a delayed withdrawal for 1000 HYPE, increasing `hypeRequestedForWithdraw`. The total protocol HYPE is 10000 HYPE.\n2. Since `getTotalProtocolHype()` still returns 10000 HYPE, the calculated liquid available for instant withdrawal is incorrectly inflated by 1000 HYPE.\n3. A malicious user can exploit this window before `finalizeWithdrawals()` is called to instantly withdraw more liquidity than is actually available to the protocol, leading to a temporary liquidity crunch and potential denial of service for future instant withdrawals.",
  "fix_description": "Create a separate function, `getAvailableProtocolHype()`, which calculates the total HYPE but subtracts `hypeRequestedForWithdraw` from the total. This new function should be used when calculating the instant withdrawal limit (e.g., in `lowWatermarkInHYPE()` and `getLiquidHypeAmount()`) to prevent temporary over-withdrawal. In `getLiquidHypeAmount()`, ensure the subtraction is protected from underflow.",
  
  "primary_file": {
    "path": "StakingCore.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport {Math} from "@openzeppelin/contracts/utils/math/Math.sol";\nimport {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";\nimport {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\nimport {IRoleRegistry} from "./interfaces/IRoleRegistry.sol";\nimport {IBeHYPEToken} from "./interfaces/IBeHYPE.sol";\nimport {IStakingCore} from "./interfaces/IStakingCore.sol";\nimport {IWithdrawManager} from "./interfaces/IWithdrawManager.sol";\nimport {L1Read} from "./lib/L1Read.sol";\nimport {CoreWriter} from "./lib/CoreWriter.sol";\n\ncontract StakingCore is IStakingCore, Initializable, UUPSUpgradeable, PausableUpgradeable {\n\n    IRoleRegistry public roleRegistry;\n    IBeHYPEToken public beHypeToken;\n    address public withdrawManager;\n    uint256 public exchangeRatio;\n    uint16 public acceptablAprInBps;\n    bool public exchangeRateGuard;\n    uint256 public lastExchangeRatioUpdate;\n    uint256 public withdrawalCooldownPeriod;\n    uint256 public lastWithdrawalTimestamp;\n    uint256 public lastHyperCoreOperationBlock;\n\n    uint64 public constant HYPE_TOKEN_ID = 150;\n    address public constant L1_HYPE_CONTRACT = 0x2222222222222222222222222222222222222222;\n    L1Read public constant l1Read = L1Read(0xb7467E0524Afba7006957701d1F06A59000d15A2);\n    CoreWriter public constant coreWriter = CoreWriter(0x3333333333333333333333333333333333333333);\n    uint256 public constant MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE = 5;\n\n    constructor() { _disableInitializers(); }\n    \n    function initialize(address _roleRegistry, address _beHype, address _withdrawManager, uint16 _acceptablAprInBps, bool _exchangeRateGuard, uint256 _withdrawalCooldownPeriod) public initializer {\n        __UUPSUpgradeable_init();\n        roleRegistry = IRoleRegistry(_roleRegistry);\n        beHypeToken = IBeHYPEToken(_beHype);\n        acceptablAprInBps = _acceptablAprInBps;\n        exchangeRateGuard = _exchangeRateGuard;\n        withdrawManager = _withdrawManager;\n        exchangeRatio = 1 ether;\n        lastExchangeRatioUpdate = block.timestamp;\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        lastWithdrawalTimestamp = block.timestamp;\n        lastHyperCoreOperationBlock = block.number;\n    }\n\n    function stake(string memory communityCode) public payable {\n       if (paused()) revert StakingPaused();\n       beHypeToken.mint(msg.sender, HYPEToBeHYPE(msg.value));\n       emit Deposit(msg.sender, msg.value, communityCode); \n    }\n\n    function updateExchangeRatio() external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 blocksPassed = block.number - lastHyperCoreOperationBlock;\n        if (blocksPassed < MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE) {\n            revert ExchangeRatioUpdateTooSoon(MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE, blocksPassed);\n        }\n        uint256 totalProtocolHype = getTotalProtocolHype();\n        uint256 newRatio = Math.mulDiv(totalProtocolHype, 1e18, beHypeToken.totalSupply());\n        uint256 ratioChange;\n        if (newRatio > exchangeRatio) {\n            ratioChange = newRatio - exchangeRatio;\n        } else {\n            ratioChange = exchangeRatio - newRatio;\n        }\n        uint256 elapsedTime = block.timestamp - lastExchangeRatioUpdate;\n        if (elapsedTime == 0) revert ElapsedTimeCannotBeZero();\n        uint256 percentageChange = Math.mulDiv(ratioChange, 1e18, exchangeRatio);\n        uint256 yearlyRate = Math.mulDiv(percentageChange, 365 days, elapsedTime);\n        uint256 yearlyRateInBps = yearlyRate / 1e14;\n        uint16 yearlyRateInBps16 = uint16(Math.min(yearlyRateInBps, type(uint16).max));\n        if (exchangeRateGuard) {\n            if (yearlyRateInBps16 > acceptablAprInBps) revert ExchangeRatioChangeExceedsThreshold(yearlyRateInBps16);\n        }\n        uint256 oldRatio = exchangeRatio;\n        exchangeRatio = newRatio;\n        lastExchangeRatioUpdate = block.timestamp;\n        emit ExchangeRatioUpdated(oldRatio, exchangeRatio, yearlyRateInBps16);\n    }\n\n    function sendFromWithdrawManager(uint256 amount, address to) external {\n        if (msg.sender != withdrawManager) revert NotAuthorized();\n        (bool success,) = payable(to).call{value: amount}("");\n        if (!success) revert FailedToSendFromWithdrawManager();\n    }\n\n    function setWithdrawManager(address _withdrawManager) external {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n        withdrawManager = _withdrawManager;\n        emit WithdrawManagerUpdated(withdrawManager);\n    }\n\n    function updateAcceptableApr(uint16 _acceptablAprInBps) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        acceptablAprInBps = _acceptablAprInBps;\n        emit AcceptableAprUpdated(_acceptablAprInBps);\n    }\n\n    function updateExchangeRateGuard(bool _exchangeRateGuard) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        exchangeRateGuard = _exchangeRateGuard;\n        emit ExchangeRateGuardUpdated(_exchangeRateGuard);\n    }\n\n    function updateWithdrawalCooldownPeriod(uint256 _withdrawalCooldownPeriod) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        emit WithdrawalCooldownPeriodUpdated(withdrawalCooldownPeriod);\n    }\n\n    function depositToHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 truncatedAmount = amount / 1e10 * 1e10;\n        if (amount != truncatedAmount) {\n            revert PrecisionLossDetected(amount, truncatedAmount);\n        }\n        (bool success,) = payable(L1_HYPE_CONTRACT).call{value: amount}("");\n        if (!success) revert FailedToDepositToHyperCore();\n        lastHyperCoreOperationBlock = block.number;\n        emit HyperCoreDeposit(amount);\n    }\n\n    function withdrawFromHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(6, abi.encode(L1_HYPE_CONTRACT, HYPE_TOKEN_ID, _convertTo8Decimals(amount)));\n        emit HyperCoreWithdraw(amount);\n    }\n\n    function depositToStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(4, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingDeposit(amount);\n    }\n\n    function withdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        if (amount > IWithdrawManager(withdrawManager).hypeRequestedForWithdraw()) revert ExceedsLimit();\n        if (block.timestamp < lastWithdrawalTimestamp + withdrawalCooldownPeriod) {\n            revert WithdrawalCooldownNotMet();\n        }\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        lastWithdrawalTimestamp = block.timestamp;\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function emergencyWithdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function delegateTokens(address validator, uint256 amount, bool isUndelegate) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(3, abi.encode(validator, _convertTo8Decimals(amount), isUndelegate));\n        emit TokenDelegated(validator, amount, isUndelegate);\n    }\n\n    function pauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _pause();\n    }\n\n    function unpauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _unpause();\n    }\n\n    function BeHYPEToHYPE(uint256 beHYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(beHYPEAmount, exchangeRatio, 1e18);\n    }\n    \n    function HYPEToBeHYPE(uint256 HYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(HYPEAmount, 1e18, exchangeRatio);\n    }\n\n    function getTotalProtocolHype() public view returns (uint256) {\n        L1Read.DelegatorSummary memory delegatorSummary = l1Read.delegatorSummary(address(this));\n        uint256 totalHypeInStakingAccount = _convertTo18Decimals(delegatorSummary.delegated) + _convertTo18Decimals(delegatorSummary.undelegated) + _convertTo18Decimals(delegatorSummary.totalPendingWithdrawal);\n        L1Read.SpotBalance memory spotBalance = l1Read.spotBalance(address(this), HYPE_TOKEN_ID);\n        uint256 totalHypeInSpotAccount = _convertTo18Decimals(spotBalance.total);\n        uint256 totalHypeInLiquidityPool = address(this).balance;\n        uint256 total = totalHypeInStakingAccount + totalHypeInSpotAccount + totalHypeInLiquidityPool;\n        return total;\n    }\n\n    function _convertTo8Decimals(uint256 amount) internal pure returns (uint64) {\n        uint256 truncatedAmount = amount / 1e10;\n        if (truncatedAmount > type(uint64).max) revert AmountExceedsUint64Max();\n        return uint64(truncatedAmount);\n    }\n\n    function _convertTo18Decimals(uint64 amount) internal pure returns (uint256) {\n        return uint256(amount) * 1e10;\n    }\n\n    function _encodeAction(uint8 actionId, bytes memory actionData) internal {\n        lastHyperCoreOperationBlock = block.number;\n        bytes memory data = new bytes(4 + actionData.length);\n        data[0] = 0x01;\n        data[1] = 0x00;\n        data[2] = 0x00;\n        data[3] = bytes1(actionId);\n        for (uint256 i = 0; i < actionData.length; i++) {\n            data[4 + i] = actionData[i];\n        }\n        coreWriter.sendRawAction(data);\n    }\n\n    function _authorizeUpgrade(address /* newImplementation */) internal view override {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n    }\n\n    receive() external payable {}\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["getTotalProtocolHype"]
  },
  
  "context_files": [
    {
      "path": "WithdrawManager.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\nimport {ReentrancyGuardUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";\nimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\nimport {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\nimport {Math} from "@openzeppelin/contracts/utils/math/Math.sol";\nimport {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";\nimport {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";\nimport {IRoleRegistry} from "./interfaces/IRoleRegistry.sol";\nimport {IBeHYPEToken} from "./interfaces/IBeHype.sol";\nimport {IStakingCore} from "./interfaces/IStakingCore.sol";\nimport {IWithdrawManager} from "./interfaces/IWithdrawManager.sol";\nimport {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";\nimport {BucketLimiter} from "./lib/BucketLimiter.sol";\ncontract WithdrawManager is Initializable, UUPSUpgradeable, IWithdrawManager, ReentrancyGuardUpgradeable, PausableUpgradeable {\n    using Math for uint256;\n    using SafeERC20 for IERC20;\n    IBeHYPEToken public beHypeToken;\n    IStakingCore public stakingCore;\n    IRoleRegistry public roleRegistry;\n    uint256 public hypeRequestedForWithdraw;\n    uint256 public lastFinalizedIndex;\n    WithdrawalEntry[] public withdrawalQueue;\n    mapping(address => uint256[]) public userWithdrawals;\n    uint256 public minWithdrawalAmount;\n    uint256 public maxWithdrawalAmount;\n    uint16 public instantWithdrawalFeeInBps;\n    uint16 public lowWatermarkInBpsOfTvl;\n    BucketLimiter.Limit public instantWithdrawalLimit;\n    uint256 public constant BUCKET_UNIT_SCALE = 1e12;\n    uint256 public constant BASIS_POINT_SCALE = 1e4;\n    constructor() { _disableInitializers(); }\n    function initialize(uint256 _minWithdrawAmount, uint256 _maxWithdrawAmount, uint16 _lowWatermarkInBpsOfTvl, uint16 _instantWithdrawalFeeInBps, address _roleRegistry, address _beHypeToken, address _stakingCore, uint256 _bucketCapacity, uint64 _bucketRefillRate) public initializer {\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        minWithdrawalAmount = _minWithdrawAmount;\n        maxWithdrawalAmount = _maxWithdrawAmount;\n        lowWatermarkInBpsOfTvl = _lowWatermarkInBpsOfTvl;\n        instantWithdrawalFeeInBps = _instantWithdrawalFeeInBps;\n        roleRegistry = IRoleRegistry(_roleRegistry);\n        beHypeToken = IBeHYPEToken(_beHypeToken);\n        stakingCore = IStakingCore(_stakingCore);\n        instantWithdrawalLimit = BucketLimiter.create(_convertToBucketUnit(_bucketCapacity, Math.Rounding.Floor), _bucketRefillRate);\n        withdrawalQueue.push(WithdrawalEntry({user: address(0), beHypeAmount: 0, hypeAmount: 0, claimed: true}));\n    }\n    function withdraw(uint256 beHypeAmount, bool instant, uint256 minAmountOut) external nonReentrant returns (uint256 withdrawalId) {\n        if (paused()) revert WithdrawalsPaused();\n        if (beHypeAmount < minWithdrawalAmount) revert InvalidAmount();\n        if (beHypeAmount > maxWithdrawalAmount) revert InvalidAmount();\n        if (beHypeToken.balanceOf(msg.sender) < beHypeAmount) revert InsufficientBeHYPEBalance();\n        uint256 hypeAmount = stakingCore.BeHYPEToHYPE(beHypeAmount);\n        if (instant) {\n            if (!_canRateLimiterConsume(hypeAmount)) revert InstantWithdrawalRateLimitExceeded();\n            if (!canInstantWithdraw(beHypeAmount)) revert InsufficientHYPELiquidity();\n            uint256 instantWithdrawalFee = beHypeAmount.mulDiv(instantWithdrawalFeeInBps, BASIS_POINT_SCALE);\n            uint256 beHypeWithdrawalAfterFee = beHypeAmount - instantWithdrawalFee;\n            uint256 hypeWithdrawalAfterFee = stakingCore.BeHYPEToHYPE(beHypeWithdrawalAfterFee);\n            if (hypeWithdrawalAfterFee < minAmountOut) revert InsufficientMinimumAmountOut();\n            _updateRateLimit(hypeAmount);\n            beHypeToken.transferFrom(msg.sender, address(this), beHypeAmount);\n            beHypeToken.transfer(roleRegistry.protocolTreasury(), instantWithdrawalFee);\n            beHypeToken.burn(address(this), beHypeWithdrawalAfterFee);\n            stakingCore.sendFromWithdrawManager(hypeWithdrawalAfterFee, msg.sender);\n            emit InstantWithdrawal(msg.sender, beHypeAmount, hypeWithdrawalAfterFee, instantWithdrawalFee);\n        } else {\n            if (hypeAmount < minAmountOut) revert InsufficientMinimumAmountOut();\n            withdrawalId = withdrawalQueue.length;\n            hypeRequestedForWithdraw += hypeAmount;\n            withdrawalQueue.push(WithdrawalEntry({user: msg.sender, beHypeAmount: beHypeAmount, hypeAmount: hypeAmount, claimed: false}));\n            userWithdrawals[msg.sender].push(withdrawalId);\n            beHypeToken.transferFrom(msg.sender, address(this), beHypeAmount);\n            emit WithdrawalQueued(msg.sender, withdrawalId, beHypeAmount, hypeAmount, withdrawalId);\n        }\n    }\n    function claimWithdrawal(uint256 withdrawalId) external nonReentrant {\n        if (paused()) revert WithdrawalsPaused();\n        if (!canClaimWithdrawal(withdrawalId)) revert WithdrawalNotClaimable();\n        WithdrawalEntry storage entry = withdrawalQueue[withdrawalId];\n        if (entry.claimed) revert AlreadyClaimed();\n        entry.claimed = true;\n        (bool success, ) = payable(entry.user).call{value: entry.hypeAmount}("");\n        if (!success) revert TransferFailed();\n        emit WithdrawalClaimed(entry.user, withdrawalId, entry.hypeAmount);\n    }\n    function finalizeWithdrawals(uint256 index) external nonReentrant {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        if (index >= withdrawalQueue.length) revert IndexOutOfBounds();\n        if (index <= lastFinalizedIndex) revert CanOnlyFinalizeForward();\n        uint256 hypeAmountToFinalize = 0;\n        uint256 beHypeAmountToFinalize = 0;\n        for (uint256 i = lastFinalizedIndex + 1; i <= index;) {\n            beHypeAmountToFinalize += withdrawalQueue[i].beHypeAmount;\n            hypeAmountToFinalize += withdrawalQueue[i].hypeAmount;\n            unchecked { ++i; }\n        }\n        lastFinalizedIndex = index;\n        beHypeToken.burn(address(this), beHypeAmountToFinalize);\n        stakingCore.sendFromWithdrawManager(hypeAmountToFinalize, address(this));\n        hypeRequestedForWithdraw -= hypeAmountToFinalize;\n        emit WithdrawalsBatchFinalized(index);\n    }\n    function setInstantWithdrawalFeeInBps(uint16 _instantWithdrawalFeeInBps) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        if (_instantWithdrawalFeeInBps > BASIS_POINT_SCALE) revert InvalidInstantWithdrawalFee();\n        instantWithdrawalFeeInBps = _instantWithdrawalFeeInBps;\n        emit InstantWithdrawalFeeInBpsUpdated(_instantWithdrawalFeeInBps);\n    }\n    function setInstantWithdrawalCapacity(uint256 capacity) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint64 bucketUnit = _convertToBucketUnit(capacity, Math.Rounding.Floor);\n        BucketLimiter.setCapacity(instantWithdrawalLimit, bucketUnit);\n        emit InstantWithdrawalCapacityUpdated(capacity);\n    }\n    function setInstantWithdrawalRefillRatePerSecond(uint64 refillRate) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        BucketLimiter.setRefillRate(instantWithdrawalLimit, refillRate);\n        emit InstantWithdrawalRefillRateUpdated(refillRate);\n    }\n    function pauseWithdrawals() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _pause();\n    }\n    function unpauseWithdrawals() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _unpause();\n    }\n    function getWithdrawalQueue(uint256 index) external view returns (WithdrawalEntry memory) {\n        return withdrawalQueue[index];\n    }\n    function canClaimWithdrawal(uint256 withdrawalId) public view returns (bool) {\n        if (withdrawalId >= withdrawalQueue.length) return false;\n        if (withdrawalId > lastFinalizedIndex) return false;\n        WithdrawalEntry storage entry = withdrawalQueue[withdrawalId];\n        return !entry.claimed;\n    }\n    function getUserUnclaimedWithdrawals(address user) external view returns (uint256[] memory) {\n        uint256[] memory unclaimedWithdrawals = new uint256[](userWithdrawals[user].length);\n        uint256 count = 0;\n        for (uint256 i = 0; i < userWithdrawals[user].length;) {\n            WithdrawalEntry storage entry = withdrawalQueue[userWithdrawals[user][i]];\n            if (!entry.claimed) {\n                unclaimedWithdrawals[count] = userWithdrawals[user][i];\n                unchecked { ++count; }\n            }\n            unchecked { ++i; }\n        }\n        assembly { mstore(unclaimedWithdrawals, count) }\n        return unclaimedWithdrawals;\n    }\n    function getTotalInstantWithdrawableBeHYPE() public view returns (uint256) {\n        if (getLiquidHypeAmount() < lowWatermarkInHYPE()) return 0;\n        uint256 withdrawableAmount = getLiquidHypeAmount() - lowWatermarkInHYPE();\n        uint256 rateLimitAllowedAmount = _convertFromBucketUnit(BucketLimiter.consumable(instantWithdrawalLimit));\n        return stakingCore.HYPEToBeHYPE(Math.min(withdrawableAmount, rateLimitAllowedAmount));\n    }\n    function canInstantWithdraw(uint256 beHypeAmount) public view returns (bool) {\n        return beHypeAmount <= getTotalInstantWithdrawableBeHYPE();\n    }\n    function getLiquidHypeAmount() public view returns (uint256) {\n        return address(stakingCore).balance;\n    }\n    function getPendingWithdrawalsCount() external view returns (uint256) {\n        return withdrawalQueue.length - lastFinalizedIndex - 1;\n    }\n    function lowWatermarkInHYPE() public view returns (uint256) {\n        return stakingCore.getTotalProtocolHype().mulDiv(lowWatermarkInBpsOfTvl, BASIS_POINT_SCALE);\n    }\n    function _updateRateLimit(uint256 amount) internal {\n        uint64 bucketUnit = _convertToBucketUnit(amount, Math.Rounding.Ceil);\n        if (!BucketLimiter.consume(instantWithdrawalLimit, bucketUnit)) revert InstantWithdrawalRateLimitExceeded();\n    }\n    function _canRateLimiterConsume(uint256 amount) internal view returns (bool) {\n        return BucketLimiter.canConsume(instantWithdrawalLimit, _convertToBucketUnit(amount, Math.Rounding.Ceil));\n    }\n    function _convertToBucketUnit(uint256 amount, Math.Rounding rounding) internal pure returns (uint64) {\n        require(amount < type(uint64).max * BUCKET_UNIT_SCALE, "WithdrawManager: Amount too large");\n        return (rounding == Math.Rounding.Ceil) ? SafeCast.toUint64((amount + BUCKET_UNIT_SCALE - 1) / BUCKET_UNIT_SCALE) : SafeCast.toUint64(amount / BUCKET_UNIT_SCALE);\n    }\n    function _convertFromBucketUnit(uint64 bucketUnit) internal pure returns (uint256) {\n        return bucketUnit * BUCKET_UNIT_SCALE;\n    }\n    function _authorizeUpgrade(address /* newImplementation */) internal view override {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n    }\n    receive() external payable {}\n}",
      "relevance": "This file uses the inflated values from `StakingCore.getTotalProtocolHype()` and `address(stakingCore).balance` (which includes pending withdrawals before finalization) to calculate the instant withdrawable amount, leading to the vulnerability."
    }
  ],
  
  "call_flow": "User calls WithdrawManager.withdraw() (queues withdrawal) -> `hypeRequestedForWithdraw` increases -> Instant Withdrawal check uses `StakingCore.getTotalProtocolHype()` -> Value is inflated -> Instant withdrawal is granted beyond true liquidity.",
  "context_hint": "An accounting inconsistency between two contracts during the multi-step withdrawal process. The `StakingCore` reports the underlying asset total without acknowledging the liability represented by the pending withdrawals (`hypeRequestedForWithdraw`) stored in `WithdrawManager` that have not yet moved off the core contract balance.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The Medium severity is appropriate as this only leads to a temporary liquidity crunch, not permanent loss, and only when there are unfinalized withdrawals. The fix requires careful separation of liquidity available for instant withdrawal vs. total assets for exchange rate calculation."
}

{
  "id": "gs_pashov_hyperbeat_M02",
  "subset": "gold_standard",
  "language": "solidity",
  "chain": "ethereum",
  
  "source_platform": "pashov_audit_group",
  "source_report": "Hyperbeat Security Review",
  "source_finding_id": "[M-02]",
  "report_url": "https://github.com/pashov/audits/blob/master/team/pdf/Hyperbeat-security-review_2025-09-03.pdf",
  "github_repo_url": "https://github.com/etherfi-protocol/beHYPE/tree/c620e61aaf8fe5767e713bb9d7447bd9fbc40148/src",
  "contest_date": "2025-09-03",
  
  "severity": "medium",
  "vulnerability_type": "exchange_rate_corruption",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  
  "finding_title": "Idle HYPE balance consideration allows silent bypass of exchange rate guard",
  "finding_description": "The `updateExchangeRatio()` function uses an APR guard to prevent the exchange rate from being corrupted by bad data reads from external HyperCore precompiles. The guard checks the calculated new ratio against the expected APR, but the new ratio calculation (via `getTotalProtocolHype()`) includes all assets, specifically the 'idle HYPE balance' present directly on the `StakingCore` contract's address (`address(this).balance`). If a bad precompile read occurs, the presence of sufficient idle liquidity in the `StakingCore` contract can artificially inflate the calculated total HYPE, making the ratio appear higher than it should be, thus allowing the corrupted ratio to silently bypass the APR guard and be accepted, corrupting the protocol's exchange rate.",
  "attack_scenario": "1. A bad read from the HyperCore precompile occurs, causing the reported delegated/undelegated balances to be much lower than reality, which should trigger the APR guard.\n2. The `StakingCore` contract holds a large, idle native HYPE balance (`address(this).balance`).\n3. This idle balance artificially boosts the `total` HYPE calculated by `getTotalProtocolHype()`, which is used to derive the new exchange ratio.\n4. The inflated total HYPE value compensates for the bad read, causing the resulting exchange ratio to still fall within the acceptable APR guard limits.\n5. The corrupted exchange rate is accepted by the protocol, causing an incorrect accounting of user shares and potentially affecting the `WithdrawManager::lowWatermarkInHYPE()` calculation.",
  "fix_description": "It is recommended to guard the `delegatorSummary` and `spotBalance` values (the results of the external HyperCore precompile calls) individually before aggregating them, rather than relying on a guard that uses the aggregated total which includes the local contract's balance.",
  
  "primary_file": {
    "path": "StakingCore.sol",
    "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.26;\n\nimport {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";\nimport {Math} from "@openzeppelin/contracts/utils/math/Math.sol";\nimport {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";\nimport {PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\nimport {IRoleRegistry} from "./interfaces/IRoleRegistry.sol";\nimport {IBeHYPEToken} from "./interfaces/IBeHYPE.sol";\nimport {IStakingCore} from "./interfaces/IStakingCore.sol";\nimport {IWithdrawManager} from "./interfaces/IWithdrawManager.sol";\nimport {L1Read} from "./lib/L1Read.sol";\nimport {CoreWriter} from "./lib/CoreWriter.sol";\n\ncontract StakingCore is IStakingCore, Initializable, UUPSUpgradeable, PausableUpgradeable {\n\n    IRoleRegistry public roleRegistry;\n    IBeHYPEToken public beHypeToken;\n    address public withdrawManager;\n    uint256 public exchangeRatio;\n    uint16 public acceptablAprInBps;\n    bool public exchangeRateGuard;\n    uint256 public lastExchangeRatioUpdate;\n    uint256 public withdrawalCooldownPeriod;\n    uint256 public lastWithdrawalTimestamp;\n    uint256 public lastHyperCoreOperationBlock;\n\n    uint64 public constant HYPE_TOKEN_ID = 150;\n    address public constant L1_HYPE_CONTRACT = 0x2222222222222222222222222222222222222222;\n    L1Read public constant l1Read = L1Read(0xb7467E0524Afba7006957701d1F06A59000d15A2);\n    CoreWriter public constant coreWriter = CoreWriter(0x3333333333333333333333333333333333333333);\n    uint256 public constant MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE = 5;\n\n    constructor() { _disableInitializers(); }\n    \n    function initialize(address _roleRegistry, address _beHype, address _withdrawManager, uint16 _acceptablAprInBps, bool _exchangeRateGuard, uint256 _withdrawalCooldownPeriod) public initializer {\n        __UUPSUpgradeable_init();\n        roleRegistry = IRoleRegistry(_roleRegistry);\n        beHypeToken = IBeHYPEToken(_beHype);\n        acceptablAprInBps = _acceptablAprInBps;\n        exchangeRateGuard = _exchangeRateGuard;\n        withdrawManager = _withdrawManager;\n        exchangeRatio = 1 ether;\n        lastExchangeRatioUpdate = block.timestamp;\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        lastWithdrawalTimestamp = block.timestamp;\n        lastHyperCoreOperationBlock = block.number;\n    }\n\n    function stake(string memory communityCode) public payable {\n       if (paused()) revert StakingPaused();\n       beHypeToken.mint(msg.sender, HYPEToBeHYPE(msg.value));\n       emit Deposit(msg.sender, msg.value, communityCode); \n    }\n\n    function updateExchangeRatio() external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 blocksPassed = block.number - lastHyperCoreOperationBlock;\n        if (blocksPassed < MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE) {\n            revert ExchangeRatioUpdateTooSoon(MIN_BLOCKS_BEFORE_EXCHANGE_RATIO_UPDATE, blocksPassed);\n        }\n        uint256 totalProtocolHype = getTotalProtocolHype();\n        uint256 newRatio = Math.mulDiv(totalProtocolHype, 1e18, beHypeToken.totalSupply());\n        uint256 ratioChange;\n        if (newRatio > exchangeRatio) {\n            ratioChange = newRatio - exchangeRatio;\n        } else {\n            ratioChange = exchangeRatio - newRatio;\n        }\n        uint256 elapsedTime = block.timestamp - lastExchangeRatioUpdate;\n        if (elapsedTime == 0) revert ElapsedTimeCannotBeZero();\n        uint256 percentageChange = Math.mulDiv(ratioChange, 1e18, exchangeRatio);\n        uint256 yearlyRate = Math.mulDiv(percentageChange, 365 days, elapsedTime);\n        uint256 yearlyRateInBps = yearlyRate / 1e14;\n        uint16 yearlyRateInBps16 = uint16(Math.min(yearlyRateInBps, type(uint16).max));\n        if (exchangeRateGuard) {\n            if (yearlyRateInBps16 > acceptablAprInBps) revert ExchangeRatioChangeExceedsThreshold(yearlyRateInBps16);\n        }\n        uint256 oldRatio = exchangeRatio;\n        exchangeRatio = newRatio;\n        lastExchangeRatioUpdate = block.timestamp;\n        emit ExchangeRatioUpdated(oldRatio, exchangeRatio, yearlyRateInBps16);\n    }\n\n    function sendFromWithdrawManager(uint256 amount, address to) external {\n        if (msg.sender != withdrawManager) revert NotAuthorized();\n        (bool success,) = payable(to).call{value: amount}("");\n        if (!success) revert FailedToSendFromWithdrawManager();\n    }\n\n    function setWithdrawManager(address _withdrawManager) external {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n        withdrawManager = _withdrawManager;\n        emit WithdrawManagerUpdated(withdrawManager);\n    }\n\n    function updateAcceptableApr(uint16 _acceptablAprInBps) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        acceptablAprInBps = _acceptablAprInBps;\n        emit AcceptableAprUpdated(_acceptablAprInBps);\n    }\n\n    function updateExchangeRateGuard(bool _exchangeRateGuard) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        exchangeRateGuard = _exchangeRateGuard;\n        emit ExchangeRateGuardUpdated(_exchangeRateGuard);\n    }\n\n    function updateWithdrawalCooldownPeriod(uint256 _withdrawalCooldownPeriod) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        withdrawalCooldownPeriod = _withdrawalCooldownPeriod;\n        emit WithdrawalCooldownPeriodUpdated(withdrawalCooldownPeriod);\n    }\n\n    function depositToHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        uint256 truncatedAmount = amount / 1e10 * 1e10;\n        if (amount != truncatedAmount) {\n            revert PrecisionLossDetected(amount, truncatedAmount);\n        }\n        (bool success,) = payable(L1_HYPE_CONTRACT).call{value: amount}("");\n        if (!success) revert FailedToDepositToHyperCore();\n        lastHyperCoreOperationBlock = block.number;\n        emit HyperCoreDeposit(amount);\n    }\n\n    function withdrawFromHyperCore(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(6, abi.encode(L1_HYPE_CONTRACT, HYPE_TOKEN_ID, _convertTo8Decimals(amount)));\n        emit HyperCoreWithdraw(amount);\n    }\n\n    function depositToStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(4, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingDeposit(amount);\n    }\n\n    function withdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        if (amount > IWithdrawManager(withdrawManager).hypeRequestedForWithdraw()) revert ExceedsLimit();\n        if (block.timestamp < lastWithdrawalTimestamp + withdrawalCooldownPeriod) {\n            revert WithdrawalCooldownNotMet();\n        }\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        lastWithdrawalTimestamp = block.timestamp;\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function emergencyWithdrawFromStaking(uint256 amount) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_GUARDIAN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(5, abi.encode(_convertTo8Decimals(amount)));\n        emit HyperCoreStakingWithdraw(amount);\n    }\n\n    function delegateTokens(address validator, uint256 amount, bool isUndelegate) external {\n        if (!roleRegistry.hasRole(roleRegistry.PROTOCOL_ADMIN(), msg.sender)) revert NotAuthorized();\n        _encodeAction(3, abi.encode(validator, _convertTo8Decimals(amount), isUndelegate));\n        emit TokenDelegated(validator, amount, isUndelegate);\n    }\n\n    function pauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _pause();\n    }\n\n    function unpauseStaking() external {\n        if (msg.sender != address(roleRegistry)) revert NotAuthorized();\n        _unpause();\n    }\n\n    function BeHYPEToHYPE(uint256 beHYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(beHYPEAmount, exchangeRatio, 1e18);\n    }\n    \n    function HYPEToBeHYPE(uint256 HYPEAmount) public view returns (uint256) {\n        return Math.mulDiv(HYPEAmount, 1e18, exchangeRatio);\n    }\n\n    function getTotalProtocolHype() public view returns (uint256) {\n        L1Read.DelegatorSummary memory delegatorSummary = l1Read.delegatorSummary(address(this));\n        uint256 totalHypeInStakingAccount = _convertTo18Decimals(delegatorSummary.delegated) + _convertTo18Decimals(delegatorSummary.undelegated) + _convertTo18Decimals(delegatorSummary.totalPendingWithdrawal);\n        L1Read.SpotBalance memory spotBalance = l1Read.spotBalance(address(this), HYPE_TOKEN_ID);\n        uint256 totalHypeInSpotAccount = _convertTo18Decimals(spotBalance.total);\n        uint256 totalHypeInLiquidityPool = address(this).balance;\n        uint256 total = totalHypeInStakingAccount + totalHypeInSpotAccount + totalHypeInLiquidityPool;\n        return total;\n    }\n\n    function _convertTo8Decimals(uint256 amount) internal pure returns (uint64) {\n        uint256 truncatedAmount = amount / 1e10;\n        if (truncatedAmount > type(uint64).max) revert AmountExceedsUint64Max();\n        return uint64(truncatedAmount);\n    }\n\n    function _convertTo18Decimals(uint64 amount) internal pure returns (uint256) {\n        return uint256(amount) * 1e10;\n    }\n\n    function _encodeAction(uint8 actionId, bytes memory actionData) internal {\n        lastHyperCoreOperationBlock = block.number;\n        bytes memory data = new bytes(4 + actionData.length);\n        data[0] = 0x01;\n        data[1] = 0x00;\n        data[2] = 0x00;\n        data[3] = bytes1(actionId);\n        for (uint256 i = 0; i < actionData.length; i++) {\n            data[4 + i] = actionData[i];\n        }\n        coreWriter.sendRawAction(data);\n    }\n\n    function _authorizeUpgrade(address /* newImplementation */) internal view override {\n        roleRegistry.onlyProtocolUpgrader(msg.sender);\n    }\n\n    receive() external payable {}\n}",
    "vulnerable_lines": [10],
    "vulnerable_functions": ["getTotalProtocolHype", "updateExchangeRatio"]
  },
  
  "context_files": [],
  
  "call_flow": "External Precompile returns corrupted data (low balances) -> `getTotalProtocolHype` calculates `total` -> High `address(this).balance` masks the corruption -> Calculated exchange ratio bypasses APR guard -> Corrupted ratio is written to state.",
  "context_hint": "The aggregation logic for the exchange rate calculation incorrectly combines externally sourced volatile data with locally held non-volatile data. This allows the local balance to act as a buffer, preventing a necessary safety check (APR guard) from detecting corrupted external data, leading to state corruption.",
  
  "is_vulnerable": true,
  
  "expert_notes": "The guard is rendered ineffective by the inclusion of the StakingCore contract's own balance. The fix shifts the guarding logic from the aggregated total to the individual external reads, which is the correct security boundary."
}