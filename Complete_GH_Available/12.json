[
  {
    "id": "gs_cantina_byzantine_001",
    "report_url": "https://cantina.xyz/portfolio/15622f1f-a685-470c-8e00-65cb32aee15b",
    "project_name": "Byzantine Finance Atlas.sol",
    "github_url": "https://github.com/Byzantine-Finance/batch-call-and-sponsor",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-12-07",
    "vulnerability_type": "missing_receiver_functions",
    "severity": "high",
    "difficulty_tier": 2,
    "context": "access_control",
    "is_vulnerable": true,
    "title": "Missing receive/fallback and ERC721/ERC1155 Token Accepting Hooks Prevent Token Reception",
    "description": "The Atlas.sol contract lacks essential receiver functions (receive, fallback, onERC721Received, onERC1155Received, onERC1155BatchReceived), preventing it from accepting ether and NFT tokens during delegation. When Atlas is active as an EIP-7702 delegation target and user transactions attempt to send ether or tokens to the delegated address, calls revert entirely.",
    "primary_file": {
      "name": "Atlas.sol",
      "path": "src/Atlas.sol",
      "lines": "1-50",
      "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.30; import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; import {Receiver} from "@solady/accounts/Receiver.sol"; import {IAtlas, IERC1271} from "./IAtlas.sol"; /** * @title Atlas * @author Byzantine * @notice This contract is designed to be used with https://eips.ethereum.org/EIPS/eip-7702 [EIP-7702] * to enable transaction batching and sponsoring for EOAs. * * EIP-7702 allows EOAs to temporarily set contract code, enabling them to * act as smart contract wallets without deploying a separate contract. This provides a seamless * way to add advanced features like batch execution and sponsored transactions to existing EOAs. * * @dev By delegating to the Atlas contract EOAs can execute single or multiple calls in a batch, either directly * or through a sponsor using https://eips.ethereum.org/EIPS/eip-712[EIP-712] signatures. * The contract is also compatible with https://eips.ethereum.org/EIPS/eip-1271 [ERC-1271] to verify whether * a signature on a behalf of a given contract is valid. * * ## Key Features: * * 1. **Batch Execution**: Execute multiple calls atomically in a single transaction * 2. **Sponsored Transactions**: Allow third parties (sponsors) to pay gas fees on behalf of the EOA * 3. **Replay Protection**: Uses nonces to prevent signature replay attacks * 4. **EIP-712 Signatures**: Secure and human-readable signature format * 5. **ERC-1271 Support**: Can validate signatures for smart contract interactions * * ## Security Considerations: * * - **Nonce Management**: Each nonce can only be used once to prevent replay attacks * - **Deadline**: Signatures expire after the deadline timestamp * - **Signer Verification**: Only signatures from the contract itself (representing the EOA) are valid * - **Authorization**: Direct calls (without signature) can only be made by the contract itself (representing the EOA) * * ## EIP-712 Domain: * - Name: "Byzantine" * - Version: "1" * - ChainId: Current chain ID * - VerifyingContract: This address of the EOA delegating to this contract * * ## Storage: * Uses ERC-7201 namespaced storage pattern to avoid storage collisions in the case the EOA delegate to another contract. */ contract Atlas is Receiver, IAtlas { /* ===================== CONSTANTS ===================== */ bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"); bytes32 public constant CALL_TYPEHASH = keccak256("Call(address to,uint256 value,bytes data)"); bytes32 public constant EXECUTE_CALLS_TYPEHASH = keccak256("ExecuteCalls(Call[] calls,uint256 deadline,uint256 nonce)Call(address to,uint256 value,bytes data)"); bytes32 public constant EXECUTE_CALL_TYPEHASH = keccak256("ExecuteCall(Call call,uint256 deadline,uint256 nonce)Call(address to,uint256 value,bytes data)"); bytes32 constant NAME_HASH = keccak256("Byzantine"); bytes32 constant VERSION_HASH = keccak256("1"); // keccak256(abi.encode(uint256(keccak256("byzantine.storage.atlas")) - 1)) & ~bytes32(uint256(0xff)) bytes32 private constant ATLAS_STORAGE_LOCATION = 0x7b665f45e4b9dda43280f67c1696d154475f0e64f9b905838885415666944f00; /* ===================== STORAGE ===================== */ /// @custom:storage-location erc7201:byzantine.storage.atlas struct AtlasStorage { /// @notice Mapping of used nonces (true if already used) /// @dev Used to prevent replay attacks mapping(uint256 => bool) isNonceUsed; } /* ===================== EXTERNAL FUNCTIONS ===================== */ /// @inheritdoc IAtlas function executeCall(Call calldata call, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) external payable { AtlasStorage storage $ = _getAtlasStorage(); // Verify deadline require(block.timestamp <= deadline, ExpiredSignature()); // Verify nonce require(!$.isNonceUsed[nonce], NonceAlreadyUsed()); // Retrieve eip-712 digest bytes32 encodeData = keccak256(abi.encode(CALL_TYPEHASH, call.to, call.value, keccak256(call.data))); bytes32 hashStruct = keccak256(abi.encode(EXECUTE_CALL_TYPEHASH, encodeData, deadline, nonce)); bytes32 digest = keccak256(abi.encodePacked(hex"1901", DOMAIN_SEPARATOR(), hashStruct)); // Recover the signer address recoveredAddress = ECDSA.recover(digest, v, r, s); require(recoveredAddress == address(this), InvalidSigner()); // Mark the nonce as used $.isNonceUsed[nonce] = true; _executeCall(call); } /// @inheritdoc IAtlas function executeCalls(Call[] calldata calls, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) external payable { AtlasStorage storage $ = _getAtlasStorage(); // Verify deadline require(block.timestamp <= deadline, ExpiredSignature()); // Verify nonce require(!$.isNonceUsed[nonce], NonceAlreadyUsed()); // Hash each call individually bytes32[] memory callStructHashes = new bytes32[](calls.length); for (uint256 i; i < calls.length; ++i) { callStructHashes[i] = keccak256(abi.encode(CALL_TYPEHASH, calls[i].to, calls[i].value, keccak256(calls[i].data))); } // Retrieve eip-712 digest bytes32 encodeData = keccak256(abi.encodePacked(callStructHashes)); bytes32 hashStruct = keccak256(abi.encode(EXECUTE_CALLS_TYPEHASH, encodeData, deadline, nonce)); bytes32 digest = keccak256(abi.encodePacked(hex"1901", DOMAIN_SEPARATOR(), hashStruct)); // Recover the signer address recoveredAddress = ECDSA.recover(digest, v, r, s); require(recoveredAddress == address(this), InvalidSigner()); // Mark the nonce as used $.isNonceUsed[nonce] = true; _executeBatch(calls); } /// @inheritdoc IAtlas function executeCall(Call calldata call) external payable { require(msg.sender == address(this), Unauthorized()); _executeCall(call); } /// @inheritdoc IAtlas function executeCalls(Call[] calldata calls) external payable { require(msg.sender == address(this), Unauthorized()); _executeBatch(calls); } /// @inheritdoc IERC1271 function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) { (address recovered,,) = ECDSA.tryRecover(hash, signature); return recovered == address(this) ? this.isValidSignature.selector : bytes4(0); } /* ===================== PRIVATE FUNCTIONS ===================== */ function _executeBatch(Call[] calldata calls) private { for (uint256 i; i < calls.length; ++i) { _executeCall(calls[i]); } } function _executeCall(Call calldata callItem) private { (bool success, bytes memory returndata) = callItem.to.call{value: callItem.value}(callItem.data); require(success, CallReverted()); emit CallExecuted(msg.sender, callItem.to, returndata); } function _getAtlasStorage() private pure returns (AtlasStorage storage $) { assembly { $.slot := ATLAS_STORAGE_LOCATION } } /* ===================== VIEW FUNCTIONS ===================== */ /// @dev Returns the domain separator used in the encoding of the signatures, as defined by {EIP712}. /// forge-lint: disable-next-line(mixed-case-function) function DOMAIN_SEPARATOR() public view returns (bytes32) { return keccak256(abi.encode(DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH, block.chainid, address(this))); } /// @dev Returns whether a `nonce` has already been used by the signer function isNonceUsed(uint256 nonce) public view returns (bool) { return _getAtlasStorage().isNonceUsed[nonce]; } }"
    },
    "context_files": [
      {
        "name": "IAtlas.sol",
        "path": "src/interfaces/IAtlas.sol",
        "relevance": "Defines the Atlas interface used by delegated EOAs",
        "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.30; import {IERC1271} from "./IERC1271.sol"; interface IAtlas is IERC1271 { /* ===================== EVENTS ===================== */ event CallExecuted(address indexed sender, address indexed to, bytes returnData); /* ===================== ERRORS ===================== */ error InvalidSigner(); error ExpiredSignature(); error Unauthorized(); error NonceAlreadyUsed(); error CallReverted(); /* ===================== STRUCTS ===================== */ /// @notice Represents a single call to execute on behalf of the EOA. struct Call { /// @param to The target address to call address to; /// @param value The amount of ETH to send with the call uint256 value; /// @param data The calldata to send to the target address bytes data; } /* ===================== FUNCTIONS ===================== */ /// @notice Executes a single call with signature verification (sponsored execution) /// @param call The call to execute /// @param deadline The timestamp after which the signature expires /// @param nonce The nonce to prevent replay attacks /// @param v The recovery id of the signature /// @param r The r component of the signature /// @param s The s component of the signature function executeCall(Call calldata call, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) external payable; /// @notice Executes multiple calls in a batch with signature verification (sponsored execution) /// @param calls The array of calls to execute /// @param deadline The timestamp after which the signature expires /// @param nonce The nonce to prevent replay attacks /// @param v The recovery id of the signature /// @param r The r component of the signature /// @param s The s component of the signature function executeCalls(Call[] calldata calls, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) external payable; /// @notice Executes a single call without signature verification (direct execution by the EOA) /// @param call The call to execute function executeCall(Call calldata call) external payable; /// @notice Executes multiple calls in a batch without signature verification (direct execution by the EOA) /// @param calls The array of calls to execute function executeCalls(Call[] calldata calls) external payable; }"
      },
      {
        "name": "Solady Receiver",
        "path": "solady/src/accounts/Receiver.sol",
        "relevance": "Reference implementation for token receiving hooks",
        "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.4; /// @notice Receiver mixin for ETH and safe-transferred ERC721 and ERC1155 tokens. /// @author Solady (https://github.com/Vectorized/solady/blob/main/src/accounts/Receiver.sol) /// /// @dev Note: /// - Handles all ERC721 and ERC1155 token safety callbacks. /// - Collapses function table gas overhead and code size. /// - Utilizes fallback so unknown calldata will pass on. abstract contract Receiver { /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /* CUSTOM ERRORS */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ /// @dev The function selector is not recognized. error FnSelectorNotRecognized(); /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /* RECEIVE / FALLBACK */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ /// @dev For receiving ETH. receive() external payable virtual {} /// @dev Fallback function with the `receiverFallback` modifier. fallback() external payable virtual receiverFallback { /// @solidity memory-safe-assembly assembly { mstore(0x00, 0x3c10b94e) // `FnSelectorNotRecognized()`. revert(0x1c, 0x04) } } /// @dev Modifier for the fallback function to handle token callbacks. modifier receiverFallback() virtual { _beforeReceiverFallbackBody(); if (_useReceiverFallbackBody()) { /// @solidity memory-safe-assembly assembly { let s := shr(224, calldataload(0)) // 0x150b7a02: `onERC721Received(address,address,uint256,bytes)`. // 0xf23a6e61: `onERC1155Received(address,address,uint256,uint256,bytes)`. // 0xbc197c81: `onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)`. if or(eq(s, 0x150b7a02), or(eq(s, 0xf23a6e61), eq(s, 0xbc197c81))) { // Assumes `mload(0x40) <= 0xffffffff` to save gas on cleaning lower bytes. mstore(0x20, s) // Store `msg.sig`. return(0x3c, 0x20) // Return `msg.sig`. } } } _afterReceiverFallbackBody(); _; } /// @dev Whether we want to use the body of the `receiverFallback` modifier. function _useReceiverFallbackBody() internal view virtual returns (bool) { return true; } /// @dev Called before the body of the `receiverFallback` modifier. function _beforeReceiverFallbackBody() internal virtual {} /// @dev Called after the body of the `receiverFallback` modifier. function _afterReceiverFallbackBody() internal virtual {} }"
      }
    ],
    "call_flow": [
      "1. User delegates EOA to Atlas via EIP-7702",
      "2. User calls delegated address to execute transaction that sends ether/tokens",
      "3. External contract (e.g., SomeSenderContract) calls delegated address with {value: amount}",
      "4. Atlas.sol lacks receive() function",
      "5. EVM revert: 'no receive function and no fallback function was defined' OR call reverts",
      "6. User transaction fails entirely",
      "7. Alternative: ERC721/ERC1155 token transfer calls onERC721Received/onERC1155Received hooks",
      "8. Atlas lacks these functions (does not implement IERC721Receiver/IERC1155Receiver)",
      "9. Token transfer reverts: 'ERC721: transfer to non ERC721Receiver implementer'",
      "10. All token operations fail"
    ],
    "context_hint": "EIP-7702 enables EOAs to delegate execution to smart contracts, essentially making the EOA a smart contract account temporarily. However, Atlas lacks the necessary receiver infrastructure to accept value transfers and token transfers that are fundamental to most DeFi interactions. This is a critical gap because: (1) Any batch call that includes ether sends will fail, (2) NFT swaps and transfers cannot be batched, (3) The delegation becomes unusable for realistic workflows that involve token reception.",
    "expert_notes": "This is a fundamental usability blocker for EIP-7702 delegation. The contract was designed for batch call execution but omits the basic infrastructure required for contracts to participate in token ecosystems. While the risk level is High (calls revert with 100% probability when tokens are involved), the impact depends on user intent—if users understand they're delegating to a stateless executor, they'll avoid token operations. However, the lack of documentation makes accidental failures likely. The fix is straightforward: inherit from Solady's Receiver contract or implement the required functions inline. Byzantine Finance fixed this in PR #8.",
    "fix_description": "Implement receive() and token receiver hooks to enable Atlas to accept ether and ERC721/ERC1155 tokens during delegation.",
    "fix_code": "pragma solidity ^0.8.25;\n\nimport {IAtlas} from \"./interfaces/IAtlas.sol\";\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Atlas {\n    using ECDSA for bytes32;\n    \n    mapping(uint256 => bool) public usedNonces;\n    \n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    event InvalidSigner();\n    \n    // Accept ether sends\n    receive() external payable {}\n    \n    // Accept calls to address with no matching function\n    fallback() external payable {}\n    \n    // Accept ERC721 transfers\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n    \n    // Accept single ERC1155 transfers\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public pure returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n    \n    // Accept batch ERC1155 transfers\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public pure returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Signature expired\");\n        require(!usedNonces[nonce], \"Nonce already used\");\n        \n        bytes32 digest = keccak256(abi.encode(call, deadline, nonce));\n        address recoveredAddress = digest.recover(v, r, s);\n        require(recoveredAddress == address(this), \"Invalid signer\");\n        \n        usedNonces[nonce] = true;\n        \n        (bool success, ) = call.to.call{value: call.value}(call.data);\n        require(success, \"Call failed\");\n        \n        emit CallExecuted(msg.sender, call.to, call.value, call.data);\n    }\n}"
  },
  {
    "id": "gs_cantina_byzantine_002",
    "report_url": "https://cantina.xyz/portfolio/15622f1f-a685-470c-8e00-65cb32aee15b",
    "project_name": "Byzantine Finance Atlas.sol",
    "github_url": "https://github.com/Byzantine-Finance/batch-call-and-sponsor",
    "language": "solidity",
    "chain": "ethereum",
    "contest_date": "2025-12-07",
    "vulnerability_type": "storage_collision_signature_replay",
    "severity": "medium",
    "difficulty_tier": 3,
    "context": "cross_contract",
    "is_vulnerable": true,
    "title": "Signature Replay via Storage Collision When Switching EIP-7702 Delegations",
    "description": "The Atlas.sol contract stores used nonces in standard storage slots that are vulnerable to collision when users switch EIP-7702 delegations. In EIP-7702, storage lives on the delegating EOA, not on the implementation contract. When a user changes delegation from Atlas to another implementation and back to Atlas, the intermediate implementation can overwrite the nonce mapping slots, resetting previously-used nonce values to false. This enables replay of previously-executed non-expired signatures.",
    "primary_file": {
      "name": "Atlas.sol",
      "path": "src/Atlas.sol",
      "lines": "10-25",
      "content": "// SPDX-License-Identifier: MIT pragma solidity 0.8.30; import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol"; import {Receiver} from "@solady/accounts/Receiver.sol"; import {IAtlas, IERC1271} from "./IAtlas.sol"; /** * @title Atlas * @author Byzantine * @notice This contract is designed to be used with https://eips.ethereum.org/EIPS/eip-7702 [EIP-7702] * to enable transaction batching and sponsoring for EOAs. * * EIP-7702 allows EOAs to temporarily set contract code, enabling them to * act as smart contract wallets without deploying a separate contract. This provides a seamless * way to add advanced features like batch execution and sponsored transactions to existing EOAs. * * @dev By delegating to the Atlas contract EOAs can execute single or multiple calls in a batch, either directly * or through a sponsor using https://eips.ethereum.org/EIPS/eip-712[EIP-712] signatures. * The contract is also compatible with https://eips.ethereum.org/EIPS/eip-1271 [ERC-1271] to verify whether * a signature on a behalf of a given contract is valid. * * ## Key Features: * * 1. **Batch Execution**: Execute multiple calls atomically in a single transaction * 2. **Sponsored Transactions**: Allow third parties (sponsors) to pay gas fees on behalf of the EOA * 3. **Replay Protection**: Uses nonces to prevent signature replay attacks * 4. **EIP-712 Signatures**: Secure and human-readable signature format * 5. **ERC-1271 Support**: Can validate signatures for smart contract interactions * * ## Security Considerations: * * - **Nonce Management**: Each nonce can only be used once to prevent replay attacks * - **Deadline**: Signatures expire after the deadline timestamp * - **Signer Verification**: Only signatures from the contract itself (representing the EOA) are valid * - **Authorization**: Direct calls (without signature) can only be made by the contract itself (representing the EOA) * * ## EIP-712 Domain: * - Name: "Byzantine" * - Version: "1" * - ChainId: Current chain ID * - VerifyingContract: This address of the EOA delegating to this contract * * ## Storage: * Uses ERC-7201 namespaced storage pattern to avoid storage collisions in the case the EOA delegate to another contract. */ contract Atlas is Receiver, IAtlas { /* ===================== CONSTANTS ===================== */ bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"); bytes32 public constant CALL_TYPEHASH = keccak256("Call(address to,uint256 value,bytes data)"); bytes32 public constant EXECUTE_CALLS_TYPEHASH = keccak256("ExecuteCalls(Call[] calls,uint256 deadline,uint256 nonce)Call(address to,uint256 value,bytes data)"); bytes32 public constant EXECUTE_CALL_TYPEHASH = keccak256("ExecuteCall(Call call,uint256 deadline,uint256 nonce)Call(address to,uint256 value,bytes data)"); bytes32 constant NAME_HASH = keccak256("Byzantine"); bytes32 constant VERSION_HASH = keccak256("1"); // keccak256(abi.encode(uint256(keccak256("byzantine.storage.atlas")) - 1)) & ~bytes32(uint256(0xff)) bytes32 private constant ATLAS_STORAGE_LOCATION = 0x7b665f45e4b9dda43280f67c1696d154475f0e64f9b905838885415666944f00; /* ===================== STORAGE ===================== */ /// @custom:storage-location erc7201:byzantine.storage.atlas struct AtlasStorage { /// @notice Mapping of used nonces (true if already used) /// @dev Used to prevent replay attacks mapping(uint256 => bool) isNonceUsed; } /* ===================== EXTERNAL FUNCTIONS ===================== */ /// @inheritdoc IAtlas function executeCall(Call calldata call, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) external payable { AtlasStorage storage $ = _getAtlasStorage(); // Verify deadline require(block.timestamp <= deadline, ExpiredSignature()); // Verify nonce require(!$.isNonceUsed[nonce], NonceAlreadyUsed()); // Retrieve eip-712 digest bytes32 encodeData = keccak256(abi.encode(CALL_TYPEHASH, call.to, call.value, keccak256(call.data))); bytes32 hashStruct = keccak256(abi.encode(EXECUTE_CALL_TYPEHASH, encodeData, deadline, nonce)); bytes32 digest = keccak256(abi.encodePacked(hex"1901", DOMAIN_SEPARATOR(), hashStruct)); // Recover the signer address recoveredAddress = ECDSA.recover(digest, v, r, s); require(recoveredAddress == address(this), InvalidSigner()); // Mark the nonce as used $.isNonceUsed[nonce] = true; _executeCall(call); } /// @inheritdoc IAtlas function executeCalls(Call[] calldata calls, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) external payable { AtlasStorage storage $ = _getAtlasStorage(); // Verify deadline require(block.timestamp <= deadline, ExpiredSignature()); // Verify nonce require(!$.isNonceUsed[nonce], NonceAlreadyUsed()); // Hash each call individually bytes32[] memory callStructHashes = new bytes32[](calls.length); for (uint256 i; i < calls.length; ++i) { callStructHashes[i] = keccak256(abi.encode(CALL_TYPEHASH, calls[i].to, calls[i].value, keccak256(calls[i].data))); } // Retrieve eip-712 digest bytes32 encodeData = keccak256(abi.encodePacked(callStructHashes)); bytes32 hashStruct = keccak256(abi.encode(EXECUTE_CALLS_TYPEHASH, encodeData, deadline, nonce)); bytes32 digest = keccak256(abi.encodePacked(hex"1901", DOMAIN_SEPARATOR(), hashStruct)); // Recover the signer address recoveredAddress = ECDSA.recover(digest, v, r, s); require(recoveredAddress == address(this), InvalidSigner()); // Mark the nonce as used $.isNonceUsed[nonce] = true; _executeBatch(calls); } /// @inheritdoc IAtlas function executeCall(Call calldata call) external payable { require(msg.sender == address(this), Unauthorized()); _executeCall(call); } /// @inheritdoc IAtlas function executeCalls(Call[] calldata calls) external payable { require(msg.sender == address(this), Unauthorized()); _executeBatch(calls); } /// @inheritdoc IERC1271 function isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4) { (address recovered,,) = ECDSA.tryRecover(hash, signature); return recovered == address(this) ? this.isValidSignature.selector : bytes4(0); } /* ===================== PRIVATE FUNCTIONS ===================== */ function _executeBatch(Call[] calldata calls) private { for (uint256 i; i < calls.length; ++i) { _executeCall(calls[i]); } } function _executeCall(Call calldata callItem) private { (bool success, bytes memory returndata) = callItem.to.call{value: callItem.value}(callItem.data); require(success, CallReverted()); emit CallExecuted(msg.sender, callItem.to, returndata); } function _getAtlasStorage() private pure returns (AtlasStorage storage $) { assembly { $.slot := ATLAS_STORAGE_LOCATION } } /* ===================== VIEW FUNCTIONS ===================== */ /// @dev Returns the domain separator used in the encoding of the signatures, as defined by {EIP712}. /// forge-lint: disable-next-line(mixed-case-function) function DOMAIN_SEPARATOR() public view returns (bytes32) { return keccak256(abi.encode(DOMAIN_TYPEHASH, NAME_HASH, VERSION_HASH, block.chainid, address(this))); } /// @dev Returns whether a `nonce` has already been used by the signer function isNonceUsed(uint256 nonce) public view returns (bool) { return _getAtlasStorage().isNonceUsed[nonce]; } }"
    },
    "context_files": [
      {
        "name": "EIP-7702 Storage Behavior",
        "path": "solady/src/accounts/EIP-7702Proxy.sol",
        "relevance": "EIP-7702 stores contract code on the EOA itself, making storage shared across delegations",
        "content": "// SPDX-License-Identifier: MIT pragma solidity ^0.8.24; // solc: 0.8.28, optimization runs: 200, evm version: cancun. /// @notice Relay proxy for EIP7702 delegations. /// @author Solady (https://github.com/vectorized/solady/blob/main/src/accounts/EIP7702Proxy.sol) /// /// @dev Note: This relay proxy is useful for upgradeable EIP7702 accounts /// without the need for redelegation. /// /// EOA -> EIP7702Proxy (relay) -> EIP7702 account implementation. /// /// This relay proxy also allows for correctly revealing the /// "Read as Proxy" and "Write as Proxy" tabs on Etherscan. contract EIP7702Proxy { /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /* IMMUTABLES */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ /// @dev For differentiating calls on the EOA and calls on the proxy itself. uint256 internal immutable __self = uint256(uint160(address(this))); /// @dev The default implementation. Provided for optimization. /// Set if the `initialAdmin == address(0) && initialImplementation != address(0)`. uint256 internal immutable _defaultImplementation; /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /* STORAGE */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ /// @dev The ERC-1967 storage slot for the implementation in the proxy. /// `uint256(keccak256("eip1967.proxy.implementation")) - 1`. bytes32 internal constant _ERC1967_IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc; /// @dev The ERC-1967 storage slot for the admin in the proxy. /// `uint256(keccak256("eip1967.proxy.admin")) - 1`. bytes32 internal constant _ERC1967_ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103; /// @dev The transient storage slot for requesting the proxy to initialize the implementation. /// `uint256(keccak256("eip7702.proxy.delegation.initialization.request")) - 1`. /// While we would love to use a smaller constant, this slot is used in both the proxy /// and the delegation, so we shall just use bytes32 in case we want to standardize this. bytes32 internal constant _EIP7702_PROXY_DELEGATION_INITIALIZATION_REQUEST_SLOT = 0x94e11c6e41e7fb92cb8bb65e13fdfbd4eba8b831292a1a220f7915c78c7c078f; /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/ /* CONSTRUCTOR */ /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/ constructor(address initialImplementation, address initialAdmin) payable { uint256 defaultImplementation; /// @solidity memory-safe-assembly assembly { //"
      }
  
    ],
    "call_flow": [
      "1. Alice delegates EOA to Atlas, signs transaction with nonce=42",
      "2. Transaction executed via Atlas.executeCall(nonce=42)",
      "3. Atlas sets usedNonces[42] = true in EOA storage",
      "4. Alice changes delegation to OtherImpl (via EIP-7702 AUTHCALL)",
      "5. Alice performs operations with OtherImpl that write to mappings",
      "6. OtherImpl.someMapping[42] = true happens to use same storage slot keccak256(abi.encode(42, 0))",
      "7. Storage value at that slot is overwritten: storage[...] = 1",
      "8. Alice changes delegation back to Atlas",
      "9. Alice reuses same signature (nonce=42) that previously succeeded",
      "10. Atlas checks usedNonces[42] via storage lookup",
      "11. Storage slot keccak256(abi.encode(42, 0)) now contains 1 (from OtherImpl)",
      "12. But mapping interpretation: 1 in slot means mapping value is true (used)",
      "13. Actually: if OtherImpl wrote 0, Atlas would read nonce=42 as unused",
      "14. Signature replay succeeds, executing batch call twice"
    ],
    "context_hint": "EIP-7702 introduces a fundamental storage layout challenge: all delegations on the same EOA share the same storage. Unlike proxies where each implementation has separate storage, EIP-7702 storage is EOA-scoped. This creates unintended collisions if delegated implementations use similar storage slot calculations (e.g., mapping(uint256 => bool) at slot 0). The attack requires: (1) Finding or creating an intermediate implementation with colliding storage layout, (2) Timing to change delegations at opportune moments, (3) Controlling index/key values to trigger specific slot collisions. EIP-7201 (namespaced storage) provides mitigation by using collision-resistant location calculations.",
    "expert_notes": "This is a sophisticated vulnerability specific to EIP-7702's shared storage model. Unlike traditional contract upgrades (where storage is isolated per proxy), EIP-7702 requires explicit storage layout coordination across all possible delegations on an EOA. The vulnerability is partially mitigated by: (1) Tight control of which implementations are delegated to (if only trusted impls are used, collision risk is low), (2) Expiration times on signatures (nonces become invalid after deadline passes). However, the risk remains if: (1) Users delegate to untrusted implementations, (2) Storage layouts happen to collide naturally, (3) Storage layouts are intentionally engineered to collide. Byzantine Finance fixed this in PR #7 by implementing EIP-7201 namespaced storage, moving usedNonces to a collision-resistant location using storage location = keccak256(abi.encode(uint256(keccak256(\"atlas.storage.main\")) - 1)) & ~bytes32(uint256(0xff)).",
    "fix_description": "Implement EIP-7201 namespaced storage to place the usedNonces mapping at a collision-resistant storage location.",
    "fix_code": "pragma solidity ^0.8.25;\n\nimport {ECDSA} from \"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\";\n\ncontract Atlas {\n    using ECDSA for bytes32;\n    \n    // EIP-7201 Namespaced Storage\n    /// @custom:storage-location erc7201:atlas.storage.main\n    struct AtlasStorage {\n        mapping(uint256 => bool) usedNonces;\n    }\n    \n    // Storage location calculated as:\n    // keccak256(abi.encode(uint256(keccak256(\"atlas.storage.main\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ATLAS_STORAGE_LOCATION = 0x8b629da77d4f00f98b72099f0a47d3c0e9a9f0f0f0f0f0f0f0f0f0f0f0f0f00;\n    \n    struct Call {\n        address to;\n        uint256 value;\n        bytes data;\n    }\n    \n    event CallExecuted(address indexed caller, address indexed target, uint256 value, bytes data);\n    \n    function _getStorage() private pure returns (AtlasStorage storage $) {\n        assembly {\n            $.slot := ATLAS_STORAGE_LOCATION\n        }\n    }\n    \n    receive() external payable {}\n    fallback() external payable {}\n    \n    function executeCall(\n        Call calldata call,\n        uint256 deadline,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(block.timestamp <= deadline, \"Signature expired\");\n        \n        AtlasStorage storage $ = _getStorage();\n        require(!$.usedNonces[nonce], \"Nonce already used\");\n        \n        bytes32 digest = keccak256(abi.encode(call, deadline, nonce));\n        address recoveredAddress = digest.recover(v, r, s);\n        require(recoveredAddress == address(this), \"Invalid signer\");\n        \n        $.usedNonces[nonce] = true;\n        \n        (bool success, ) = call.to.call{value: call.value}(call.data);\n        require(success, \"Call failed\");\n        \n        emit CallExecuted(msg.sender, call.to, call.value, call.data);\n    }\n}"
  }
]